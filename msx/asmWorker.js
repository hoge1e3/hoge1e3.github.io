(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
//browserify -t workerify workerClient.js > asmWorker.js
window.asmWorker = new Worker((window.URL || window.webkitURL).createObjectURL(new Blob(['(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module \'"+i+"\'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\n/*\n * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").\n * This devtool is neither made for production nor for readable output files.\n * It uses "eval()" calls to create a separate source file in the browser devtools.\n * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)\n * or disable the default devtool with "devtool: false".\n * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).\n */\n/******/ (() => { // webpackBootstrap\n/******/ \t"use strict";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ "../packages/z80-asm/dist/Asm.js":\n/*!***************************************!*\\\n  !*** ../packages/z80-asm/dist/Asm.js ***!\n  \\***************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\neval("__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\"Asm\\": () => (/* binding */ Asm),\\n/* harmony export */   \\"AssembledLine\\": () => (/* binding */ AssembledLine),\\n/* harmony export */   \\"FileInfo\\": () => (/* binding */ FileInfo),\\n/* harmony export */   \\"SourceFile\\": () => (/* binding */ SourceFile),\\n/* harmony export */   \\"SymbolInfo\\": () => (/* binding */ SymbolInfo),\\n/* harmony export */   \\"SymbolReference\\": () => (/* binding */ SymbolReference),\\n/* harmony export */   \\"getAsmDirectiveDocs\\": () => (/* binding */ getAsmDirectiveDocs)\\n/* harmony export */ });\\n/* harmony import */ var z80_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! z80-base */ \\"../packages/z80-base/dist/index.js\\");\\n/* harmony import */ var _path_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./path.js */ \\"../packages/z80-asm/dist/path.js\\");\\n/* harmony import */ var z80_inst__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! z80-inst */ \\"../packages/z80-inst/dist/index.js\\");\\n\\r\\n\\r\\n\\r\\n\\r\\n/**\\r\\n * List of all flags that can be specified in an instruction.\\r\\n */\\r\\nconst FLAGS = new Set([\\"z\\", \\"nz\\", \\"c\\", \\"nc\\", \\"po\\", \\"pe\\", \\"p\\", \\"m\\"]);\\r\\n// Byte-defining pseudo instructions.\\r\\n// https://k1.spdns.de/Develop/Projects/zasm/Documentation/z54.htm\\r\\n// https://k1.spdns.de/Develop/Projects/zasm/Documentation/z51.htm\\r\\n// https://k1.spdns.de/Develop/Projects/zasm/Documentation/z59.htm\\r\\nconst PSEUDO_DEF_BYTES = new Set([\\"defb\\", \\"db\\", \\".db\\", \\".byte\\", \\"defm\\", \\"dm\\", \\".dm\\", \\".text\\", \\".ascii\\", \\".asciz\\"]);\\r\\n// Word-defining pseudo instructions.\\r\\n// https://k1.spdns.de/Develop/Projects/zasm/Documentation/z52.htm\\r\\nconst PSEUDO_DEF_WORDS = new Set([\\"defw\\", \\"dw\\", \\".dw\\", \\".word\\"]);\\r\\n// Long-defining pseudo instructions.\\r\\n// https://k1.spdns.de/Develop/Projects/zasm/Documentation/z53.htm\\r\\nconst PSEUDO_DEF_LONGS = new Set([\\".long\\"]);\\r\\n// Instruction to assign a value to a symbol. We don\'t support the \\"set\\" variant\\r\\n// because it clashes with the Z80 \\"set\\" instruction, and so requires extra\\r\\n// parsing logic.\\r\\n// https://k1.spdns.de/Develop/Projects/zasm/Documentation/z71.htm\\r\\n// https://k1.spdns.de/Develop/Projects/zasm/Documentation/z72.htm\\r\\nconst PSEUDO_EQU = new Set([\\"equ\\", \\".equ\\", \\"defl\\", \\"=\\"]);\\r\\n// Org-setting pseudo instructions.\\r\\n// https://k1.spdns.de/Develop/Projects/zasm/Documentation/z50.htm\\r\\nconst PSEUDO_ORG = new Set([\\"org\\", \\".org\\", \\".loc\\"]);\\r\\n// Alignment pseudo instructions.\\r\\n// https://k1.spdns.de/Develop/Projects/zasm/Documentation/z57.htm\\r\\nconst PSEUDO_ALIGN = new Set([\\"align\\", \\".align\\"]);\\r\\n// Fill pseudo instructions.\\r\\n// https://k1.spdns.de/Develop/Projects/zasm/Documentation/z56.htm\\r\\nconst PSEUDO_FILL = new Set([\\"defs\\", \\"ds\\", \\".ds\\", \\".block\\", \\".blkb\\", \\"data\\", \\"dc\\"]);\\r\\n// Pseudo instructions to start and end macro definitions.\\r\\n// https://k1.spdns.de/Develop/Projects/zasm/Documentation/z64.htm#A\\r\\nconst PSEUDO_MACRO = new Set([\\"macro\\", \\".macro\\"]);\\r\\nconst PSEUDO_ENDM = new Set([\\"endm\\", \\".endm\\"]);\\r\\n// Pseudo instructions for if/else/endif.\\r\\nconst PSEUDO_IF = new Set([\\"if\\", \\"cond\\", \\"#if\\"]);\\r\\nconst PSEUDO_ELSE = new Set([\\"else\\", \\"#else\\"]);\\r\\nconst PSEUDO_ENDIF = new Set([\\"endif\\", \\"endc\\", \\"#endif\\"]);\\r\\nconst PSEUDO_REPT = new Set([\\"rept\\", \\".rept\\"]);\\r\\n// End file instruction. Followed by optional entry address or label.\\r\\nconst PSEUDO_END = new Set([\\"end\\"]);\\r\\n// Valid extensions for files in library directories. Use the same list as zasm.\\r\\nconst LIBRARY_EXTS = new Set([\\".s\\", \\".ass\\", \\".asm\\"]);\\r\\n// Possible tags for macro parameters.\\r\\n// https://k1.spdns.de/Develop/Projects/zasm/Documentation/z65.htm#A\\r\\nconst MACRO_TAGS = [\\"!\\", \\"#\\", \\"$\\", \\"%\\", \\"&\\", \\".\\", \\":\\", \\"?\\", \\"@\\", \\"\\\\\\\\\\", \\"^\\", \\"_\\", \\"|\\", \\"~\\"];\\r\\n/**\\r\\n * Documentation about the assembly directives we support. This is\\r\\n * for interactive (IDE) auto-complete.\\r\\n */\\r\\nfunction getAsmDirectiveDocs() {\\r\\n    return [\\r\\n        {\\r\\n            directives: PSEUDO_DEF_BYTES,\\r\\n            description: \\"Define a sequence of bytes, text, or strings.\\",\\r\\n        },\\r\\n        {\\r\\n            directives: PSEUDO_DEF_WORDS,\\r\\n            description: \\"Define a sequence of 16-bit words.\\",\\r\\n        },\\r\\n        {\\r\\n            directives: PSEUDO_DEF_LONGS,\\r\\n            description: \\"Define a sequence of 32-bit longs.\\",\\r\\n        },\\r\\n        {\\r\\n            directives: PSEUDO_EQU,\\r\\n            description: \\"Assign a value to a symbol.\\",\\r\\n        },\\r\\n        {\\r\\n            directives: PSEUDO_ORG,\\r\\n            description: \\"Specify address of next instruction.\\",\\r\\n        },\\r\\n        {\\r\\n            directives: PSEUDO_ALIGN,\\r\\n            description: \\"Add fill bytes until address is multiple of specified value.\\",\\r\\n        },\\r\\n        {\\r\\n            directives: PSEUDO_FILL,\\r\\n            description: \\"Fill memory with repeated 0 bytes.\\",\\r\\n        },\\r\\n        {\\r\\n            directives: PSEUDO_MACRO,\\r\\n            description: \\"Start a macro definition.\\",\\r\\n        },\\r\\n        {\\r\\n            directives: PSEUDO_ENDM,\\r\\n            description: \\"End a macro definition.\\",\\r\\n        },\\r\\n        {\\r\\n            directives: PSEUDO_IF,\\r\\n            description: \\"If conditional.\\",\\r\\n        },\\r\\n        {\\r\\n            directives: PSEUDO_ELSE,\\r\\n            description: \\"Else conditional.\\",\\r\\n        },\\r\\n        {\\r\\n            directives: PSEUDO_ENDIF,\\r\\n            description: \\"End of if conditional.\\",\\r\\n        },\\r\\n        {\\r\\n            directives: PSEUDO_REPT,\\r\\n            description: \\"Repeat instructions by specified times.\\",\\r\\n        },\\r\\n        {\\r\\n            directives: PSEUDO_END,\\r\\n            description: \\"End of file, optionally followed by entry address or label.\\",\\r\\n        },\\r\\n    ];\\r\\n}\\r\\n/**\\r\\n * Parse a single digit in the given base, or undefined if the digit does not\\r\\n * belong to that base.\\r\\n */\\r\\nfunction parseDigit(ch, base) {\\r\\n    let value = ch >= \'0\' && ch <= \'9\' ? ch.charCodeAt(0) - 0x30\\r\\n        : ch >= \'A\' && ch <= \'F\' ? ch.charCodeAt(0) - 0x41 + 10\\r\\n            : ch >= \'a\' && ch <= \'f\' ? ch.charCodeAt(0) - 0x61 + 10\\r\\n                : undefined;\\r\\n    return value === undefined || value >= base ? undefined : value;\\r\\n}\\r\\nfunction isFlag(s) {\\r\\n    return FLAGS.has(s.toLowerCase());\\r\\n}\\r\\nfunction isLegalIdentifierCharacter(ch, isFirst) {\\r\\n    return (ch >= \'A\' && ch <= \'Z\') || (ch >= \'a\' && ch <= \'z\') || ch == \'.\' || ch == \'_\' ||\\r\\n        (!isFirst && (ch >= \'0\' && ch <= \'9\'));\\r\\n}\\r\\n// Whether the specified character counts as horizontal whitespace.\\r\\nfunction isWhitespace(c) {\\r\\n    return c === \\" \\" || c === \\"\\\\t\\";\\r\\n}\\r\\n/**\\r\\n * Get the fill byte for the specified target.\\r\\n */\\r\\nfunction fillForTarget(target) {\\r\\n    switch (target) {\\r\\n        case \\"bin\\":\\r\\n            return 0x00;\\r\\n        case \\"rom\\":\\r\\n            return 0xFF;\\r\\n    }\\r\\n}\\r\\n// A reference to a symbol.\\r\\nclass SymbolReference {\\r\\n    constructor(lineNumber, column) {\\r\\n        this.lineNumber = lineNumber;\\r\\n        this.column = column;\\r\\n    }\\r\\n}\\r\\n// Information about a symbol (label, constant).\\r\\nclass SymbolInfo {\\r\\n    constructor(name, value) {\\r\\n        this.definitions = [];\\r\\n        this.references = [];\\r\\n        // If it has multiple definitions with different values.\\r\\n        this.changesValue = false;\\r\\n        this.name = name;\\r\\n        this.value = value;\\r\\n    }\\r\\n    // Whether the specified point is in this reference.\\r\\n    matches(ref, lineNumber, column) {\\r\\n        return lineNumber === ref.lineNumber &&\\r\\n            column >= ref.column && column <= ref.column + this.name.length;\\r\\n    }\\r\\n    // Find SymbolReference at the specified position. \\r\\n    // list must be either this.definitions or this.references.\\r\\n    find(list, lineNumber, column) {\\r\\n        return list.find((ref) => this.matches(ref, lineNumber, column));\\r\\n    }\\r\\n}\\r\\n// Information about each file that was read. Note that we may have more than one of these\\r\\n// objects for one physical file if the file is included more than once.\\r\\nclass FileInfo {\\r\\n    constructor(pathname, parentFileInfo) {\\r\\n        // Line number in listing, inclusive.\\r\\n        this.beginLineNumber = 0;\\r\\n        // Line number in listing, exclusive.\\r\\n        this.endLineNumber = 0;\\r\\n        // Files included by this file.\\r\\n        this.childFiles = [];\\r\\n        // Lines in listing that correspond to this file.\\r\\n        this.lineNumbers = [];\\r\\n        this.pathname = pathname;\\r\\n        this.parentFileInfo = parentFileInfo;\\r\\n        this.depth = parentFileInfo === undefined ? 0 : parentFileInfo.depth + 1;\\r\\n        if (parentFileInfo !== undefined) {\\r\\n            parentFileInfo.childFiles.push(this);\\r\\n        }\\r\\n    }\\r\\n}\\r\\nclass AssembledLine {\\r\\n    constructor(fileInfo, lineNumber, line) {\\r\\n        // Line number in the listing.\\r\\n        this.listingLineNumber = 0;\\r\\n        // Address of this line.\\r\\n        this.address = 0;\\r\\n        // Decoded opcodes and parameters:\\r\\n        this.binary = [];\\r\\n        // List of symbols defined or referenced on this line.\\r\\n        this.symbols = [];\\r\\n        this.fileInfo = fileInfo;\\r\\n        this.lineNumber = lineNumber;\\r\\n        this.line = line;\\r\\n    }\\r\\n    set nextAddress(nextAddress) {\\r\\n        this.specifiedNextAddress = nextAddress;\\r\\n    }\\r\\n    get nextAddress() {\\r\\n        var _a;\\r\\n        // Return explicit if provided, otherwise compute.\\r\\n        return (_a = this.specifiedNextAddress) !== null && _a !== void 0 ? _a : (this.address + this.binary.length);\\r\\n    }\\r\\n    /**\\r\\n     * Whether this line holds data, e.g. from a \\".byte\\" directive.\\r\\n     */\\r\\n    isData() {\\r\\n        return this.binary.length > 0 && this.variant === undefined;\\r\\n    }\\r\\n}\\r\\nclass SourceFile {\\r\\n    constructor(fileInfo, assembledLines) {\\r\\n        this.fileInfo = fileInfo;\\r\\n        this.assembledLines = assembledLines;\\r\\n    }\\r\\n}\\r\\n/**\\r\\n * Macro definition.\\r\\n */\\r\\nclass Macro {\\r\\n    constructor(name, tag, params, macroListingLineNumber, endmListingLineNumber, lines) {\\r\\n        this.name = name;\\r\\n        this.tag = tag;\\r\\n        this.params = params;\\r\\n        this.macroListingLineNumber = macroListingLineNumber;\\r\\n        this.endmListingLineNumber = endmListingLineNumber;\\r\\n        this.lines = lines;\\r\\n    }\\r\\n}\\r\\n/**\\r\\n * Scope for symbols.\\r\\n */\\r\\nclass Scope {\\r\\n    constructor(parent) {\\r\\n        this.symbols = new Map();\\r\\n        this.parent = parent;\\r\\n    }\\r\\n    get(identifier, propagateUp) {\\r\\n        let symbolInfo = this.symbols.get(identifier);\\r\\n        if (symbolInfo === undefined && propagateUp && this.parent !== undefined) {\\r\\n            symbolInfo = this.parent.get(identifier, propagateUp);\\r\\n        }\\r\\n        return symbolInfo;\\r\\n    }\\r\\n    set(symbolInfo) {\\r\\n        this.symbols.set(symbolInfo.name, symbolInfo);\\r\\n    }\\r\\n    remove(identifier) {\\r\\n        this.symbols.delete(identifier);\\r\\n    }\\r\\n}\\r\\n/**\\r\\n * Assembler.\\r\\n */\\r\\nclass Asm {\\r\\n    constructor(fileSystem) {\\r\\n        // Index 0 is global scope, then one scope for each #local.\\r\\n        this.scopes = [new Scope(undefined)];\\r\\n        // All assembled lines.\\r\\n        this.assembledLines = [];\\r\\n        // Cache from full directory path to list of filenames in the directory.\\r\\n        this.dirCache = new Map();\\r\\n        // Map from macro name (lower case) to its definition.\\r\\n        this.macros = new Map();\\r\\n        // Entry point into program.\\r\\n        this.entryPoint = undefined;\\r\\n        this.fileSystem = fileSystem;\\r\\n    }\\r\\n    /**\\r\\n     * Add a global symbol outside the code, perhaps in the ROM or OS.\\r\\n     */\\r\\n    addKnownLabel({ name, address }) {\\r\\n        const symbolInfo = new SymbolInfo(name, address);\\r\\n        // TODO find a better way to represent \\"not in our source file\\":\\r\\n        symbolInfo.definitions.push(new SymbolReference(0, 0));\\r\\n        this.scopes[0].set(symbolInfo);\\r\\n    }\\r\\n    /**\\r\\n     * Add a global symbols outside the code, perhaps in the ROM or OS.\\r\\n     */\\r\\n    addKnownLabels(knownLabels) {\\r\\n        for (const knownLabel of knownLabels) {\\r\\n            this.addKnownLabel(knownLabel);\\r\\n        }\\r\\n    }\\r\\n    assembleFile(pathname) {\\r\\n        // Load the top-level file.\\r\\n        const sourceFile = this.loadSourceFile(pathname, undefined);\\r\\n        if (sourceFile === undefined) {\\r\\n            return undefined;\\r\\n        }\\r\\n        // This array will grow as we include files and expand macros.\\r\\n        this.assembledLines = sourceFile.assembledLines.slice();\\r\\n        // FIRST PASS. Expand include files and macros, assemble instructions so that each\\r\\n        // label knows where it\'ll be.\\r\\n        new Pass(this, 1).run();\\r\\n        // SECOND PASS. Patch up references and generate error messages for undefined symbols.\\r\\n        new Pass(this, 2).run();\\r\\n        // Fix up line numbers in FileInfo structures.\\r\\n        for (let lineNumber = 0; lineNumber < this.assembledLines.length; lineNumber++) {\\r\\n            const assembledLine = this.assembledLines[lineNumber];\\r\\n            assembledLine.fileInfo.lineNumbers.push(lineNumber);\\r\\n        }\\r\\n        // Fix up begin/end line numbers in FileInfo structures.\\r\\n        const computeBeginEndLineNumbers = (fileInfo) => {\\r\\n            if (fileInfo.lineNumbers.length === 0) {\\r\\n                throw new Error(\\"File info for \\\\\\"\\" + fileInfo.pathname + \\"\\\\\\" has no lines\\");\\r\\n            }\\r\\n            fileInfo.beginLineNumber = fileInfo.lineNumbers[0];\\r\\n            fileInfo.endLineNumber = fileInfo.lineNumbers[fileInfo.lineNumbers.length - 1] + 1;\\r\\n            for (const child of fileInfo.childFiles) {\\r\\n                // Process children first.\\r\\n                computeBeginEndLineNumbers(child);\\r\\n                fileInfo.beginLineNumber = Math.min(fileInfo.beginLineNumber, child.beginLineNumber);\\r\\n                fileInfo.endLineNumber = Math.max(fileInfo.endLineNumber, child.endLineNumber);\\r\\n            }\\r\\n        };\\r\\n        computeBeginEndLineNumbers(sourceFile.fileInfo);\\r\\n        // Fill in symbols of each line.\\r\\n        for (const scope of this.scopes) {\\r\\n            for (const symbol of scope.symbols.values()) {\\r\\n                for (const reference of symbol.definitions) {\\r\\n                    this.assembledLines[reference.lineNumber].symbols.push(symbol);\\r\\n                }\\r\\n                for (const reference of symbol.references) {\\r\\n                    this.assembledLines[reference.lineNumber].symbols.push(symbol);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return sourceFile;\\r\\n    }\\r\\n    /**\\r\\n     * Load a source file as an array of AssembledLine objects, or undefined if the\\r\\n     * file can\'t be loaded.\\r\\n     */\\r\\n    loadSourceFile(pathname, parentFileInfo) {\\r\\n        const lines = this.fileSystem.readTextFile(pathname);\\r\\n        if (lines === undefined) {\\r\\n            return undefined;\\r\\n        }\\r\\n        const fileInfo = new FileInfo(pathname, parentFileInfo);\\r\\n        // Converted to assembled lines.\\r\\n        const assembledLines = [];\\r\\n        for (let lineNumber = 0; lineNumber < lines.length; lineNumber++) {\\r\\n            assembledLines.push(new AssembledLine(fileInfo, lineNumber, lines[lineNumber]));\\r\\n        }\\r\\n        return new SourceFile(fileInfo, assembledLines);\\r\\n    }\\r\\n    /**\\r\\n     * Reads a directory, caching the results.\\r\\n     *\\r\\n     * @return a list of filenames in the directory, or undefined if an error occurs.\\r\\n     */\\r\\n    readDir(dir) {\\r\\n        let filenames = this.dirCache.get(dir);\\r\\n        if (filenames === undefined) {\\r\\n            filenames = this.fileSystem.readDirectory(dir);\\r\\n            if (filenames === undefined) {\\r\\n                // Can\'t read dir.\\r\\n                return undefined;\\r\\n            }\\r\\n            this.dirCache.set(dir, filenames);\\r\\n        }\\r\\n        return filenames;\\r\\n    }\\r\\n}\\r\\n/**\\r\\n * Represents a pass through all the files.\\r\\n */\\r\\nclass Pass {\\r\\n    constructor(asm, passNumber) {\\r\\n        // Number of scopes defined so far in this pass, including global (index 0).\\r\\n        this.scopeCount = 1;\\r\\n        // Target type (bin, rom).\\r\\n        this.target = \\"bin\\";\\r\\n        // Number (in listing) of line we\'re assembling.\\r\\n        this.listingLineNumber = 0;\\r\\n        // Number of library files we included.\\r\\n        this.libraryIncludeCount = 0;\\r\\n        // Whether we\'ve seen an \\"end\\" directive.\\r\\n        this.sawEnd = false;\\r\\n        this.asm = asm;\\r\\n        this.passNumber = passNumber;\\r\\n        this.currentScope = this.asm.scopes[0];\\r\\n    }\\r\\n    /**\\r\\n     * Assembles the lines of the file. Returns a FileInfo object for this tree, or undefined\\r\\n     * if the file couldn\'t be read.\\r\\n     *\\r\\n     * @return the number of errors.\\r\\n     */\\r\\n    run() {\\r\\n        const before = Date.now();\\r\\n        let errorCount = 0;\\r\\n        // Assemble every line.\\r\\n        this.listingLineNumber = 0;\\r\\n        while (true) {\\r\\n            const assembledLine = this.getNextLine();\\r\\n            if (assembledLine === undefined) {\\r\\n                break;\\r\\n            }\\r\\n            new LineParser(this, assembledLine).assemble();\\r\\n            if (assembledLine.error !== undefined) {\\r\\n                errorCount++;\\r\\n            }\\r\\n        }\\r\\n        // Make sure our #local and #endlocal are balanced.\\r\\n        if (this.currentScope !== this.asm.scopes[0]) {\\r\\n            const lines = this.asm.assembledLines;\\r\\n            if (lines.length > 0 && lines[lines.length - 1].error === undefined) {\\r\\n                lines[lines.length - 1].error = \\"missing #endlocal\\";\\r\\n            }\\r\\n        }\\r\\n        const after = Date.now();\\r\\n        /*\\r\\n        console.log(\\"Pass \\" + this.passNumber + \\" time: \\" + (after - before) +\\r\\n            \\", library includes: \\" + this.libraryIncludeCount +\\r\\n            \\", errors: \\" + errorCount);\\r\\n         */\\r\\n        return errorCount;\\r\\n    }\\r\\n    /**\\r\\n     * Return the next line of the listing file, or undefined if there are no more.\\r\\n     */\\r\\n    getNextLine() {\\r\\n        if (this.listingLineNumber < 0 || this.listingLineNumber >= this.asm.assembledLines.length) {\\r\\n            return undefined;\\r\\n        }\\r\\n        const listingLineNumber = this.listingLineNumber++;\\r\\n        const assembledLine = this.asm.assembledLines[listingLineNumber];\\r\\n        assembledLine.listingLineNumber = listingLineNumber;\\r\\n        assembledLine.address = listingLineNumber === 0 ? 0 : this.asm.assembledLines[listingLineNumber - 1].nextAddress;\\r\\n        return assembledLine;\\r\\n    }\\r\\n    /**\\r\\n     * Rewind or skip ahead to this location. This line will be parsed next.\\r\\n     */\\r\\n    setListingLineNumber(listingLineNumber) {\\r\\n        this.listingLineNumber = listingLineNumber;\\r\\n    }\\r\\n    /**\\r\\n     * Insert the specified lines immediately after the line currently being assembled.\\r\\n     * @param assembledLines\\r\\n     */\\r\\n    insertLines(assembledLines) {\\r\\n        this.asm.assembledLines.splice(this.listingLineNumber, 0, ...assembledLines);\\r\\n    }\\r\\n    /**\\r\\n     * Return the scope for global symbols.\\r\\n     */\\r\\n    globals() {\\r\\n        return this.asm.scopes[0];\\r\\n    }\\r\\n    /**\\r\\n     * Return the scope for the innermost #local, which could just be the global scope.\\r\\n     */\\r\\n    locals() {\\r\\n        return this.currentScope;\\r\\n    }\\r\\n    /**\\r\\n     * Create a new scope, when we hit #local.\\r\\n     */\\r\\n    enterScope() {\\r\\n        if (this.passNumber === 1) {\\r\\n            this.currentScope = new Scope(this.currentScope);\\r\\n            this.asm.scopes.push(this.currentScope);\\r\\n            this.scopeCount++;\\r\\n        }\\r\\n        else {\\r\\n            this.currentScope = this.asm.scopes[this.scopeCount++];\\r\\n        }\\r\\n        return this.currentScope;\\r\\n    }\\r\\n    /**\\r\\n     * Exit the current scope, when we hit #endlocal.\\r\\n     *\\r\\n     * @return whether successful. Might fail if we\'re already at the global scope.\\r\\n     */\\r\\n    leaveScope() {\\r\\n        const scope = this.currentScope.parent;\\r\\n        if (scope === undefined) {\\r\\n            return false;\\r\\n        }\\r\\n        this.currentScope = scope;\\r\\n        return true;\\r\\n    }\\r\\n}\\r\\n/**\\r\\n * Parser for one single line.\\r\\n */\\r\\nclass LineParser {\\r\\n    constructor(pass, assembledLine) {\\r\\n        // Parsing index into the line.\\r\\n        this.column = 0;\\r\\n        // Pointer to the token we just parsed.\\r\\n        this.previousToken = 0;\\r\\n        this.pass = pass;\\r\\n        this.assembledLine = assembledLine;\\r\\n        this.line = assembledLine.line;\\r\\n    }\\r\\n    assemble() {\\r\\n        var _a, _b;\\r\\n        // Convenience.\\r\\n        const thisAddress = this.assembledLine.address;\\r\\n        // Clear out anything we put in previous passes.\\r\\n        this.assembledLine.binary.length = 0;\\r\\n        if (this.pass.sawEnd) {\\r\\n            // Ignore all lines after \\"end\\".\\r\\n            return;\\r\\n        }\\r\\n        // What value to assign to the label we parse, if any.\\r\\n        let labelValue;\\r\\n        // Look for compiler directive.\\r\\n        if (this.line.trim().startsWith(\\"#\\")) {\\r\\n            this.parseDirective();\\r\\n            return;\\r\\n        }\\r\\n        // Look for label in column 1.\\r\\n        let symbolColumn = 0;\\r\\n        let label = this.readIdentifier(false, false);\\r\\n        let labelIsGlobal = false;\\r\\n        if (label !== undefined) {\\r\\n            if (this.foundChar(\':\')) {\\r\\n                if (this.foundChar(\':\')) {\\r\\n                    // Double colons indicate global symbols (not local to #local).\\r\\n                    labelIsGlobal = true;\\r\\n                }\\r\\n            }\\r\\n            // By default assign it to current address, but can be overwritten\\r\\n            // by .equ below.\\r\\n            labelValue = thisAddress;\\r\\n            symbolColumn = this.previousToken;\\r\\n        }\\r\\n        this.skipWhitespace();\\r\\n        let mnemonic = this.readIdentifier(false, true);\\r\\n        if (mnemonic === undefined) {\\r\\n            // Special check for \\"=\\", which is the same as \\"defl\\".\\r\\n            const column = this.column;\\r\\n            if (this.foundChar(\\"=\\")) {\\r\\n                mnemonic = \\"=\\";\\r\\n                this.previousToken = column;\\r\\n            }\\r\\n        }\\r\\n        if (mnemonic !== undefined && this.previousToken > 0) {\\r\\n            if (PSEUDO_IF.has(mnemonic)) {\\r\\n                const cond = this.readExpression(true);\\r\\n                const thenLines = [];\\r\\n                const elseLines = [];\\r\\n                let curLines = thenLines;\\r\\n                let ifDepth = 0; // Count nested ifs\\r\\n                while (true) {\\r\\n                    const assembledLine = this.pass.getNextLine();\\r\\n                    if (assembledLine === undefined) {\\r\\n                        this.assembledLine.error = \\"if has no endif\\";\\r\\n                        break;\\r\\n                    }\\r\\n                    const lineParser = new LineParser(this.pass, assembledLine);\\r\\n                    // TODO check to make sure macro doesn\'t contain a # directive, unless the tag is\\r\\n                    // # and the directive is one of the param names.\\r\\n                    lineParser.skipWhitespace();\\r\\n                    const token = lineParser.readIdentifier(false, true);\\r\\n                    if (token !== undefined && PSEUDO_IF.has(token)) {\\r\\n                        ifDepth++;\\r\\n                    }\\r\\n                    else if (token !== undefined && PSEUDO_ENDIF.has(token)) {\\r\\n                        ifDepth--;\\r\\n                        if (ifDepth < 0) {\\r\\n                            break;\\r\\n                        }\\r\\n                    }\\r\\n                    if (token !== undefined && PSEUDO_ELSE.has(token) && ifDepth == 0) {\\r\\n                        curLines = elseLines;\\r\\n                    }\\r\\n                    else {\\r\\n                        curLines.push(assembledLine.line);\\r\\n                    }\\r\\n                }\\r\\n                if (this.pass.passNumber == 1) {\\r\\n                    const clonedLines = (cond ? thenLines : elseLines).map((line) => new AssembledLine(this.assembledLine.fileInfo, undefined, line));\\r\\n                    this.pass.insertLines(clonedLines);\\r\\n                }\\r\\n            }\\r\\n            else if (PSEUDO_ELSE.has(mnemonic) || PSEUDO_ENDIF.has(mnemonic)) {\\r\\n                this.assembledLine.error = \\"else/endif outside of if directive\\";\\r\\n                return;\\r\\n            }\\r\\n            else if (PSEUDO_DEF_BYTES.has(mnemonic)) {\\r\\n                while (true) {\\r\\n                    const s = this.readString();\\r\\n                    if (s !== undefined) {\\r\\n                        const adjustOperator = this.foundOneOfChar([\\"+\\", \\"-\\", \\"&\\", \\"|\\", \\"^\\"]);\\r\\n                        let adjustValue;\\r\\n                        if (adjustOperator !== undefined) {\\r\\n                            adjustValue = this.readExpression(true);\\r\\n                            if (adjustValue === undefined) {\\r\\n                                if (this.assembledLine.error === undefined) {\\r\\n                                    this.assembledLine.error = \\"bad adjustment value\\";\\r\\n                                }\\r\\n                                return;\\r\\n                            }\\r\\n                        }\\r\\n                        for (let i = 0; i < s.length; i++) {\\r\\n                            let value = s.charCodeAt(i);\\r\\n                            if (i === s.length - 1 && adjustOperator !== undefined && adjustValue !== undefined) {\\r\\n                                switch (adjustOperator) {\\r\\n                                    case \\"+\\":\\r\\n                                        value += adjustValue;\\r\\n                                        break;\\r\\n                                    case \\"-\\":\\r\\n                                        value -= adjustValue;\\r\\n                                        break;\\r\\n                                    case \\"&\\":\\r\\n                                        value &= adjustValue;\\r\\n                                        break;\\r\\n                                    case \\"|\\":\\r\\n                                        value |= adjustValue;\\r\\n                                        break;\\r\\n                                    case \\"^\\":\\r\\n                                        value ^= adjustValue;\\r\\n                                        break;\\r\\n                                }\\r\\n                                value = (0,z80_base__WEBPACK_IMPORTED_MODULE_0__.lo)(value);\\r\\n                            }\\r\\n                            this.assembledLine.binary.push(value);\\r\\n                        }\\r\\n                    }\\r\\n                    else if (this.assembledLine.error !== undefined) {\\r\\n                        // Error parsing string.\\r\\n                        return;\\r\\n                    }\\r\\n                    else {\\r\\n                        // Try some pre-defined names. These are only valid here.\\r\\n                        const s = this.parsePredefinedName();\\r\\n                        if (s !== undefined) {\\r\\n                            for (let i = 0; i < s.length; i++) {\\r\\n                                this.assembledLine.binary.push(s.charCodeAt(i));\\r\\n                            }\\r\\n                        }\\r\\n                        else {\\r\\n                            // Try a normal expression.\\r\\n                            const value = this.readExpression(true);\\r\\n                            if (value === undefined) {\\r\\n                                if (this.assembledLine.error === undefined) {\\r\\n                                    this.assembledLine.error = \\"invalid \\" + mnemonic + \\" expression\\";\\r\\n                                }\\r\\n                                return;\\r\\n                            }\\r\\n                            this.assembledLine.binary.push((0,z80_base__WEBPACK_IMPORTED_MODULE_0__.lo)(value));\\r\\n                        }\\r\\n                    }\\r\\n                    if (!this.foundChar(\',\')) {\\r\\n                        break;\\r\\n                    }\\r\\n                }\\r\\n                if (mnemonic === \\".asciz\\") {\\r\\n                    // Terminating nul.\\r\\n                    this.assembledLine.binary.push(0);\\r\\n                }\\r\\n            }\\r\\n            else if (PSEUDO_DEF_WORDS.has(mnemonic)) {\\r\\n                while (true) {\\r\\n                    const value = this.readExpression(true);\\r\\n                    if (value === undefined) {\\r\\n                        if (this.assembledLine.error === undefined) {\\r\\n                            this.assembledLine.error = \\"invalid \\" + mnemonic + \\" expression\\";\\r\\n                        }\\r\\n                        return;\\r\\n                    }\\r\\n                    this.assembledLine.binary.push((0,z80_base__WEBPACK_IMPORTED_MODULE_0__.lo)(value));\\r\\n                    this.assembledLine.binary.push((0,z80_base__WEBPACK_IMPORTED_MODULE_0__.hi)(value));\\r\\n                    if (!this.foundChar(\',\')) {\\r\\n                        break;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else if (PSEUDO_DEF_LONGS.has(mnemonic)) {\\r\\n                while (true) {\\r\\n                    const value = this.readExpression(true);\\r\\n                    if (value === undefined) {\\r\\n                        if (this.assembledLine.error === undefined) {\\r\\n                            this.assembledLine.error = \\"invalid \\" + mnemonic + \\" expression\\";\\r\\n                        }\\r\\n                        return;\\r\\n                    }\\r\\n                    this.assembledLine.binary.push((0,z80_base__WEBPACK_IMPORTED_MODULE_0__.lo)(value));\\r\\n                    this.assembledLine.binary.push((0,z80_base__WEBPACK_IMPORTED_MODULE_0__.hi)(value));\\r\\n                    this.assembledLine.binary.push((0,z80_base__WEBPACK_IMPORTED_MODULE_0__.lo)(value >> 16));\\r\\n                    this.assembledLine.binary.push((0,z80_base__WEBPACK_IMPORTED_MODULE_0__.hi)(value >> 16));\\r\\n                    if (!this.foundChar(\',\')) {\\r\\n                        break;\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else if (PSEUDO_EQU.has(mnemonic)) {\\r\\n                const value = this.readExpression(true);\\r\\n                if (value === undefined) {\\r\\n                    this.assembledLine.error = \\"bad value for constant\\";\\r\\n                }\\r\\n                else if (label === undefined) {\\r\\n                    this.assembledLine.error = \\"must have label for constant\\";\\r\\n                }\\r\\n                else {\\r\\n                    // Remember constant.\\r\\n                    labelValue = value;\\r\\n                }\\r\\n            }\\r\\n            else if (PSEUDO_ORG.has(mnemonic)) {\\r\\n                const startAddress = this.readExpression(true);\\r\\n                if (startAddress === undefined) {\\r\\n                    this.assembledLine.error = \\"start address expected\\";\\r\\n                }\\r\\n                else {\\r\\n                    this.assembledLine.nextAddress = startAddress;\\r\\n                }\\r\\n            }\\r\\n            else if (PSEUDO_ALIGN.has(mnemonic)) {\\r\\n                const align = this.readExpression(true);\\r\\n                if (align === undefined || align <= 0) {\\r\\n                    this.assembledLine.error = \\"alignment value expected\\";\\r\\n                }\\r\\n                else {\\r\\n                    let fillChar;\\r\\n                    if (this.foundChar(\\",\\")) {\\r\\n                        const expr = this.readExpression(true);\\r\\n                        if (expr === undefined) {\\r\\n                            if (this.assembledLine.error === undefined) {\\r\\n                                this.assembledLine.error = \\"error in fill byte\\";\\r\\n                            }\\r\\n                            return;\\r\\n                        }\\r\\n                        fillChar = expr;\\r\\n                    }\\r\\n                    if (fillChar === undefined) {\\r\\n                        this.assembledLine.nextAddress = thisAddress + (align - thisAddress % align) % align;\\r\\n                    }\\r\\n                    else {\\r\\n                        fillChar = (0,z80_base__WEBPACK_IMPORTED_MODULE_0__.lo)(fillChar);\\r\\n                        let address = thisAddress;\\r\\n                        while ((address % align) !== 0) {\\r\\n                            this.assembledLine.binary.push(fillChar);\\r\\n                            address++;\\r\\n                        }\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else if (PSEUDO_FILL.has(mnemonic)) {\\r\\n                const length = this.readExpression(true);\\r\\n                if (length === undefined || length <= 0) {\\r\\n                    this.assembledLine.error = \\"length value expected\\";\\r\\n                }\\r\\n                else {\\r\\n                    let fillChar;\\r\\n                    if (this.foundChar(\\",\\")) {\\r\\n                        const expr = this.readExpression(true);\\r\\n                        if (expr === undefined) {\\r\\n                            if (this.assembledLine.error === undefined) {\\r\\n                                this.assembledLine.error = \\"error in fill byte\\";\\r\\n                            }\\r\\n                            return;\\r\\n                        }\\r\\n                        fillChar = expr;\\r\\n                    }\\r\\n                    if (fillChar === undefined) {\\r\\n                        this.assembledLine.nextAddress = thisAddress + length;\\r\\n                    }\\r\\n                    else {\\r\\n                        fillChar = (0,z80_base__WEBPACK_IMPORTED_MODULE_0__.lo)(fillChar);\\r\\n                        for (let i = 0; i < length; i++) {\\r\\n                            this.assembledLine.binary.push(fillChar);\\r\\n                        }\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            else if (PSEUDO_MACRO.has(mnemonic)) {\\r\\n                // Macro definition.\\r\\n                let name;\\r\\n                let tag;\\r\\n                if (label !== undefined) {\\r\\n                    name = label;\\r\\n                    label = undefined;\\r\\n                    tag = \\"&\\";\\r\\n                }\\r\\n                else {\\r\\n                    name = this.readIdentifier(true, false);\\r\\n                    if (name === undefined) {\\r\\n                        this.assembledLine.error = \\"must specify name of macro\\";\\r\\n                        return;\\r\\n                    }\\r\\n                    tag = \\"\\\\\\\\\\";\\r\\n                }\\r\\n                // Convert to lower case because all mnemonics are case-insensitive.\\r\\n                name = name.toLowerCase();\\r\\n                const macro = this.pass.asm.macros.get(name);\\r\\n                if (this.pass.passNumber > 1) {\\r\\n                    // Skip macro definition.\\r\\n                    if (macro === undefined) {\\r\\n                        throw new Error(\\"Macro \\\\\\"\\" + name + \\"\\\\\\" not found in pass \\" + this.pass.passNumber);\\r\\n                    }\\r\\n                    this.pass.setListingLineNumber(macro.endmListingLineNumber + 1);\\r\\n                    return;\\r\\n                }\\r\\n                else {\\r\\n                    // Can\'t redefine macro.\\r\\n                    if (macro !== undefined) {\\r\\n                        this.assembledLine.error = \\"macro \\\\\\"\\" + name + \\"\\\\\\" already defined\\";\\r\\n                        return;\\r\\n                    }\\r\\n                    // Parse parameters.\\r\\n                    const params = [];\\r\\n                    if (!this.isEndOfLine()) {\\r\\n                        // See if the first parameter specifies a tag. It\'s okay to not have one.\\r\\n                        tag = (_a = this.foundOneOfChar(MACRO_TAGS)) !== null && _a !== void 0 ? _a : tag;\\r\\n                        do {\\r\\n                            const thisTag = (_b = this.foundOneOfChar(MACRO_TAGS)) !== null && _b !== void 0 ? _b : tag;\\r\\n                            if (thisTag !== tag) {\\r\\n                                this.assembledLine.error = \\"Inconsistent tags in macro: \\" + tag + \\" and \\" + thisTag;\\r\\n                                return;\\r\\n                            }\\r\\n                            const param = this.readIdentifier(true, false);\\r\\n                            if (param === undefined) {\\r\\n                                this.assembledLine.error = \\"expected macro parameter name\\";\\r\\n                                return;\\r\\n                            }\\r\\n                            params.push(param);\\r\\n                        } while (this.foundChar(\\",\\"));\\r\\n                        // Make sure there\'s no extra junk.\\r\\n                        this.ensureEndOfLine();\\r\\n                    }\\r\\n                    // Eat rest of macro.\\r\\n                    const macroListingLineNumber = this.assembledLine.listingLineNumber;\\r\\n                    let endmListingLineNumber = undefined;\\r\\n                    const lines = [];\\r\\n                    let macroDepth = 0; // Count \\"rept\\"s inside macro.\\r\\n                    while (true) {\\r\\n                        const assembledLine = this.pass.getNextLine();\\r\\n                        if (assembledLine === undefined) {\\r\\n                            this.assembledLine.error = \\"macro has no endm\\";\\r\\n                            break;\\r\\n                        }\\r\\n                        const lineParser = new LineParser(this.pass, assembledLine);\\r\\n                        // TODO check to make sure macro doesn\'t contain a # directive, unless the tag is\\r\\n                        // # and the directive is one of the param names.\\r\\n                        lineParser.skipWhitespace();\\r\\n                        const token = lineParser.readIdentifier(false, true);\\r\\n                        if (token !== undefined && PSEUDO_REPT.has(token)) {\\r\\n                            macroDepth++;\\r\\n                        }\\r\\n                        else if (token !== undefined && PSEUDO_ENDM.has(token)) {\\r\\n                            macroDepth--;\\r\\n                            if (macroDepth < 0) {\\r\\n                                endmListingLineNumber = assembledLine.listingLineNumber;\\r\\n                                break;\\r\\n                            }\\r\\n                        }\\r\\n                        lines.push(assembledLine.line);\\r\\n                    }\\r\\n                    if (endmListingLineNumber === undefined) {\\r\\n                        // Error in macro. Try to recover.\\r\\n                        endmListingLineNumber = macroListingLineNumber;\\r\\n                        lines.splice(0, lines.length);\\r\\n                        this.pass.setListingLineNumber(macroListingLineNumber + 1);\\r\\n                    }\\r\\n                    this.pass.asm.macros.set(name, new Macro(name, tag, params, macroListingLineNumber, endmListingLineNumber, lines));\\r\\n                    // Don\'t want to parse any more of the original macro line.\\r\\n                    return;\\r\\n                }\\r\\n            }\\r\\n            else if (PSEUDO_REPT.has(mnemonic)) {\\r\\n                // rept\\r\\n                const times = this.readExpression(true);\\r\\n                if (times === undefined) {\\r\\n                    this.assembledLine.error = \\"rept must specify repeat times\\";\\r\\n                    return;\\r\\n                }\\r\\n                // As macro definition...\\r\\n                let endmListingLineNumber;\\r\\n                const lines = [];\\r\\n                let macroDepth = 0; // Count \\"rept\\"s inside macro.\\r\\n                while (true) {\\r\\n                    const assembledLine = this.pass.getNextLine();\\r\\n                    if (assembledLine === undefined) {\\r\\n                        this.assembledLine.error = \\"rept macro has no endm\\";\\r\\n                        break;\\r\\n                    }\\r\\n                    const lineParser = new LineParser(this.pass, assembledLine);\\r\\n                    // TODO check to make sure macro doesn\'t contain a # directive, unless the tag is\\r\\n                    // # and the directive is one of the param names.\\r\\n                    lineParser.skipWhitespace();\\r\\n                    const token = lineParser.readIdentifier(false, true);\\r\\n                    if (token !== undefined && PSEUDO_REPT.has(token)) {\\r\\n                        macroDepth++;\\r\\n                    }\\r\\n                    else if (token !== undefined && PSEUDO_ENDM.has(token)) {\\r\\n                        macroDepth--;\\r\\n                        if (macroDepth < 0) {\\r\\n                            endmListingLineNumber = assembledLine.listingLineNumber;\\r\\n                            break;\\r\\n                        }\\r\\n                    }\\r\\n                    lines.push(assembledLine.line);\\r\\n                }\\r\\n                if (this.pass.passNumber == 1) {\\r\\n                    // insert lines by times\\r\\n                    for (let i = 0; i < times; i++) {\\r\\n                        const clonedLines = lines.map((line) => new AssembledLine(this.assembledLine.fileInfo, undefined, line));\\r\\n                        this.pass.insertLines(clonedLines);\\r\\n                    }\\r\\n                }\\r\\n                // Don\'t want to parse any more of the original rept line.\\r\\n                return;\\r\\n            }\\r\\n            else if (PSEUDO_ENDM.has(mnemonic)) {\\r\\n                this.assembledLine.error = \\"endm outside of macro definition\\";\\r\\n                return;\\r\\n            }\\r\\n            else if (PSEUDO_END.has(mnemonic)) {\\r\\n                // End of source file. See if there\'s an optional entry address or label.\\r\\n                this.skipWhitespace();\\r\\n                if (!this.isEndOfLine()) {\\r\\n                    const value = this.readExpression(true);\\r\\n                    if (value === undefined) {\\r\\n                        if (this.assembledLine.error === undefined) {\\r\\n                            this.assembledLine.error = \\"invalid expression for entry point\\";\\r\\n                        }\\r\\n                        return;\\r\\n                    }\\r\\n                    // See if it\'s changed.\\r\\n                    if (this.pass.asm.entryPoint !== undefined && this.pass.asm.entryPoint !== value) {\\r\\n                        if (this.assembledLine.error === undefined) {\\r\\n                            this.assembledLine.error = \\"changing entry point from 0x\\" +\\r\\n                                (0,z80_base__WEBPACK_IMPORTED_MODULE_0__.toHexWord)(this.pass.asm.entryPoint) + \\" to 0x\\" +\\r\\n                                (0,z80_base__WEBPACK_IMPORTED_MODULE_0__.toHexWord)(value);\\r\\n                        }\\r\\n                        return;\\r\\n                    }\\r\\n                    this.pass.asm.entryPoint = value;\\r\\n                }\\r\\n                this.pass.sawEnd = true;\\r\\n            }\\r\\n            else {\\r\\n                this.processOpCode(mnemonic);\\r\\n            }\\r\\n        }\\r\\n        // Make sure there\'s no extra junk.\\r\\n        this.ensureEndOfLine();\\r\\n        // If we\'re defining a new symbol, record it.\\r\\n        if (label !== undefined && labelValue !== undefined) {\\r\\n            const scope = labelIsGlobal ? this.pass.globals() : this.pass.locals();\\r\\n            let symbolInfo = scope.get(label);\\r\\n            if (symbolInfo !== undefined) {\\r\\n                // Check if value is changing.\\r\\n                if (symbolInfo.definitions.length > 0 && symbolInfo.value !== labelValue) {\\r\\n                    symbolInfo.changesValue = true;\\r\\n                }\\r\\n                symbolInfo.value = labelValue;\\r\\n            }\\r\\n            else {\\r\\n                symbolInfo = new SymbolInfo(label, labelValue);\\r\\n                scope.set(symbolInfo);\\r\\n            }\\r\\n            if (this.pass.passNumber === 1) {\\r\\n                symbolInfo.definitions.push(new SymbolReference(this.assembledLine.listingLineNumber, symbolColumn));\\r\\n            }\\r\\n            else {\\r\\n                const symRef = symbolInfo.find(symbolInfo.definitions, this.assembledLine.listingLineNumber, symbolColumn);\\r\\n                if (symRef)\\r\\n                    symRef.value = labelValue;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    // Parse a pre-defined name, returning its value.\\r\\n    parsePredefinedName() {\\r\\n        var _a;\\r\\n        const name = this.readIdentifier(false, true);\\r\\n        if (name === undefined) {\\r\\n            return undefined;\\r\\n        }\\r\\n        let value;\\r\\n        // https://k1.spdns.de/Develop/Projects/zasm/Documentation/z54.htm\\r\\n        switch (name) {\\r\\n            case \\"__date__\\": {\\r\\n                const date = new Date();\\r\\n                value = date.getFullYear() + \\"-\\" + (date.getMonth() + 1).toString().padStart(2, \\"0\\") + \\"-\\" +\\r\\n                    date.getDate().toString().padStart(2, \\"0\\");\\r\\n                break;\\r\\n            }\\r\\n            case \\"__time__\\": {\\r\\n                const date = new Date();\\r\\n                value = date.getHours().toString().padStart(2, \\"0\\") + \\":\\" +\\r\\n                    date.getMinutes().toString().padStart(2, \\"0\\") + \\":\\" +\\r\\n                    date.getSeconds().toString().padStart(2, \\"0\\");\\r\\n                break;\\r\\n            }\\r\\n            case \\"__file__\\":\\r\\n                value = this.assembledLine.fileInfo.pathname;\\r\\n                break;\\r\\n            case \\"__line__\\":\\r\\n                // Zero-based.\\r\\n                // The line number might be undefined if the line is synthetic.\\r\\n                value = ((_a = this.assembledLine.lineNumber) !== null && _a !== void 0 ? _a : 0).toString();\\r\\n                break;\\r\\n        }\\r\\n        if (value === undefined) {\\r\\n            // Back up, it wasn\'t for us.\\r\\n            this.column = this.previousToken;\\r\\n        }\\r\\n        return value;\\r\\n    }\\r\\n    // Advance the parser to the end of the line.\\r\\n    skipToEndOfLine() {\\r\\n        this.column = this.line.length;\\r\\n    }\\r\\n    // Whether we\'re at the end of the line. Assumes we\'ve already skipped whitespace.\\r\\n    isEndOfLine() {\\r\\n        return this.isChar(\\";\\") || this.column === this.line.length;\\r\\n    }\\r\\n    // Make sure there\'s no junk at the end of the line.\\r\\n    ensureEndOfLine() {\\r\\n        // Check for comment.\\r\\n        if (this.isChar(\';\')) {\\r\\n            // Skip rest of line.\\r\\n            this.column = this.line.length;\\r\\n        }\\r\\n        if (this.column != this.line.length && this.assembledLine.error === undefined) {\\r\\n            this.assembledLine.error = \\"syntax error\\";\\r\\n        }\\r\\n    }\\r\\n    parseDirective() {\\r\\n        this.skipWhitespace();\\r\\n        if (!this.foundChar(\'#\')) {\\r\\n            // Logic error.\\r\\n            throw new Error(\\"did not find # for directive\\");\\r\\n        }\\r\\n        const directive = this.readIdentifier(true, true);\\r\\n        if (directive === undefined || directive === \\"\\") {\\r\\n            this.assembledLine.error = \\"must specify directive after #\\";\\r\\n            return;\\r\\n        }\\r\\n        switch (directive) {\\r\\n            case \\"target\\":\\r\\n                const target = this.readIdentifier(false, true);\\r\\n                if (target === \\"bin\\" || target === \\"rom\\") {\\r\\n                    this.pass.target = target;\\r\\n                }\\r\\n                else {\\r\\n                    if (target === undefined) {\\r\\n                        this.assembledLine.error = \\"must specify target\\";\\r\\n                    }\\r\\n                    else {\\r\\n                        this.assembledLine.error = \\"unknown target \\" + target;\\r\\n                    }\\r\\n                    return;\\r\\n                }\\r\\n                break;\\r\\n            case \\"code\\":\\r\\n                const segmentName = this.readIdentifier(true, false);\\r\\n                if (segmentName === undefined) {\\r\\n                    this.assembledLine.error = \\"segment name expected\\";\\r\\n                }\\r\\n                else if (this.foundChar(\',\')) {\\r\\n                    if (this.foundChar(\\"*\\")) {\\r\\n                        // Keep start address unchanged.\\r\\n                    }\\r\\n                    else {\\r\\n                        const startAddress = this.readExpression(true);\\r\\n                        if (startAddress === undefined) {\\r\\n                            this.assembledLine.error = \\"start address expected\\";\\r\\n                        }\\r\\n                        else {\\r\\n                            this.assembledLine.nextAddress = startAddress;\\r\\n                        }\\r\\n                    }\\r\\n                    if (this.foundChar(\',\')) {\\r\\n                        const length = this.readExpression(true);\\r\\n                        if (length === undefined) {\\r\\n                            this.assembledLine.error = \\"length expected\\";\\r\\n                        }\\r\\n                    }\\r\\n                }\\r\\n                break;\\r\\n            case \\"include\\": {\\r\\n                const previousColumn = this.column;\\r\\n                const token = this.readIdentifier(false, true);\\r\\n                if (token === \\"library\\") {\\r\\n                    const dir = this.readString();\\r\\n                    if (dir === undefined) {\\r\\n                        this.assembledLine.error = \\"missing library directory\\";\\r\\n                    }\\r\\n                    else if (this.pass.passNumber === 1) {\\r\\n                        const libraryDir = (0,_path_js__WEBPACK_IMPORTED_MODULE_1__.resolve)((0,_path_js__WEBPACK_IMPORTED_MODULE_1__.dirname)(this.assembledLine.fileInfo.pathname), dir);\\r\\n                        const filenames = this.pass.asm.readDir(libraryDir);\\r\\n                        if (filenames === undefined) {\\r\\n                            this.assembledLine.error = \\"can\'t read directory \\\\\\"\\" + libraryDir + \\"\\\\\\"\\";\\r\\n                            return;\\r\\n                        }\\r\\n                        const includeLines = [];\\r\\n                        for (const filename of filenames) {\\r\\n                            let parsedPath = (0,_path_js__WEBPACK_IMPORTED_MODULE_1__.parse)(filename);\\r\\n                            if (LIBRARY_EXTS.has(parsedPath.ext)) {\\r\\n                                const symbol = this.pass.globals().get(parsedPath.name);\\r\\n                                if (symbol !== undefined && symbol.definitions.length === 0) {\\r\\n                                    // Found used but undefined symbol that matches a file in the library.\\r\\n                                    const includePathname = (0,_path_js__WEBPACK_IMPORTED_MODULE_1__.resolve)(dir, filename);\\r\\n                                    includeLines.push(new AssembledLine(this.assembledLine.fileInfo, undefined, \\"#include \\\\\\"\\" + includePathname + \\"\\\\\\"\\"));\\r\\n                                    this.pass.libraryIncludeCount++;\\r\\n                                }\\r\\n                            }\\r\\n                        }\\r\\n                        this.pass.insertLines(includeLines);\\r\\n                    }\\r\\n                }\\r\\n                else if (token !== undefined) {\\r\\n                    this.assembledLine.error = \\"unknown identifier \\" + token;\\r\\n                }\\r\\n                else {\\r\\n                    this.column = previousColumn;\\r\\n                    const filename = this.readString();\\r\\n                    if (filename === undefined) {\\r\\n                        this.assembledLine.error = \\"missing included filename\\";\\r\\n                    }\\r\\n                    else if (this.pass.passNumber === 1) {\\r\\n                        const includePathname = (0,_path_js__WEBPACK_IMPORTED_MODULE_1__.resolve)((0,_path_js__WEBPACK_IMPORTED_MODULE_1__.dirname)(this.assembledLine.fileInfo.pathname), filename);\\r\\n                        const sourceFile = this.pass.asm.loadSourceFile(includePathname, this.assembledLine.fileInfo);\\r\\n                        if (sourceFile === undefined) {\\r\\n                            this.assembledLine.error = \\"cannot read file \\" + includePathname;\\r\\n                        }\\r\\n                        else {\\r\\n                            // Insert the included lines right in our listing.\\r\\n                            this.pass.insertLines(sourceFile.assembledLines);\\r\\n                        }\\r\\n                    }\\r\\n                }\\r\\n                break;\\r\\n            }\\r\\n            case \\"local\\":\\r\\n                this.pass.enterScope();\\r\\n                break;\\r\\n            case \\"endlocal\\":\\r\\n                // When we leave a scope, we must push symbols that are both references and undefined out\\r\\n                // to the outer scope, since that\'s where they might be defined.\\r\\n                const scope = this.pass.locals();\\r\\n                if (scope.parent === undefined) {\\r\\n                    this.assembledLine.error = \\"#endlocal without #local\\";\\r\\n                }\\r\\n                else {\\r\\n                    for (const [identifier, symbol] of scope.symbols) {\\r\\n                        if (symbol.references.length > 0 && symbol.definitions.length === 0) {\\r\\n                            scope.remove(identifier);\\r\\n                            // Merge with this symbol in the parent, if any.\\r\\n                            const parentSymbol = scope.parent.get(identifier);\\r\\n                            if (parentSymbol === undefined) {\\r\\n                                scope.parent.set(symbol);\\r\\n                            }\\r\\n                            else {\\r\\n                                parentSymbol.references.splice(parentSymbol.references.length, 0, ...symbol.references);\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                    this.pass.leaveScope();\\r\\n                }\\r\\n                break;\\r\\n            case \\"insert\\": {\\r\\n                // Must specify pathname as string.\\r\\n                const pathname = this.readString();\\r\\n                if (pathname === undefined) {\\r\\n                    if (this.assembledLine.error === undefined) {\\r\\n                        this.assembledLine.error = \\"must specify pathname of file to insert\\";\\r\\n                    }\\r\\n                    return;\\r\\n                }\\r\\n                // Pathname is relative to including file.\\r\\n                const resolvedPathname = (0,_path_js__WEBPACK_IMPORTED_MODULE_1__.resolve)((0,_path_js__WEBPACK_IMPORTED_MODULE_1__.dirname)(this.assembledLine.fileInfo.pathname), pathname);\\r\\n                // Load the file.\\r\\n                const binary = this.pass.asm.fileSystem.readBinaryFile(resolvedPathname);\\r\\n                if (binary === undefined) {\\r\\n                    this.assembledLine.error = \\"file \\\\\\"\\" + resolvedPathname + \\"\\\\\\" not found\\";\\r\\n                    return;\\r\\n                }\\r\\n                this.assembledLine.binary.push(...binary);\\r\\n                break;\\r\\n            }\\r\\n            default:\\r\\n                this.assembledLine.error = \\"unknown directive #\\" + directive;\\r\\n                break;\\r\\n        }\\r\\n        // Make sure there\'s no extra junk.\\r\\n        this.ensureEndOfLine();\\r\\n    }\\r\\n    processOpCode(mnemonic) {\\r\\n        // See if we should expand a macro.\\r\\n        const macro = this.pass.asm.macros.get(mnemonic);\\r\\n        if (macro !== undefined) {\\r\\n            if (this.pass.passNumber > 1) {\\r\\n                if (this.assembledLine.listingLineNumber > macro.endmListingLineNumber) {\\r\\n                    // Valid, used after definition. Skip macro call.\\r\\n                    this.skipToEndOfLine();\\r\\n                    return;\\r\\n                }\\r\\n                else {\\r\\n                    // Ignore, will probably be an error below.\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                // Pass 1, expand macro.\\r\\n                // Parse arguments.\\r\\n                const args = [];\\r\\n                if (!this.isEndOfLine()) {\\r\\n                    do {\\r\\n                        const begin = this.column;\\r\\n                        while (this.column < this.line.length && !this.isChar(\\",\\") && !this.isChar(\\";\\")) {\\r\\n                            if (this.isChar(\\"\\\\\\"\\") || this.isChar(\\"\'\\")) {\\r\\n                                const str = this.readString();\\r\\n                                if (str === undefined) {\\r\\n                                    // Error is already set.\\r\\n                                    return;\\r\\n                                }\\r\\n                            }\\r\\n                            else {\\r\\n                                this.column++;\\r\\n                            }\\r\\n                        }\\r\\n                        // Back up over trailing spaces.\\r\\n                        while (this.column > begin && isWhitespace(this.line.charAt(this.column - 1))) {\\r\\n                            this.column--;\\r\\n                        }\\r\\n                        const arg = this.line.substring(begin, this.column);\\r\\n                        args.push(arg);\\r\\n                        this.skipWhitespace();\\r\\n                    } while (this.foundChar(\\",\\"));\\r\\n                }\\r\\n                // Make sure we got the right number.\\r\\n                if (args.length < macro.params.length) {\\r\\n                    // Give name of argument as hint to what to type next.\\r\\n                    this.assembledLine.error = \\"macro missing \\\\\\"\\" + macro.params[args.length] + \\"\\\\\\" argument\\";\\r\\n                    return;\\r\\n                }\\r\\n                if (args.length > macro.params.length) {\\r\\n                    this.assembledLine.error = \\"macro got too many arguments (\\" + args.length +\\r\\n                        \\" instead of \\" + macro.params.length + \\")\\";\\r\\n                    return;\\r\\n                }\\r\\n                const assembledLines = macro.lines.map((line) => new AssembledLine(this.assembledLine.fileInfo, undefined, this.performMacroSubstitutions(line, macro, args)));\\r\\n                this.pass.insertLines(assembledLines);\\r\\n                return;\\r\\n            }\\r\\n        }\\r\\n        // See if it\'s a Z80 mnemonic.\\r\\n        const mnemonicInfo = z80_inst__WEBPACK_IMPORTED_MODULE_2__.mnemonicMap.get(mnemonic);\\r\\n        if (mnemonicInfo !== undefined) {\\r\\n            const argStart = this.column;\\r\\n            let match = false;\\r\\n            let ddValue = undefined; // for parse +dd or -dd\\r\\n            for (const variant of mnemonicInfo) {\\r\\n                // Map from something like \\"nn\\" to its value.\\r\\n                const args = new Map();\\r\\n                match = true;\\r\\n                for (let i = 0; i < variant.tokens.length; i++) {\\r\\n                    const token = variant.tokens[i];\\r\\n                    // Some instructions like \\"LD A,(IX+dd)\\" should also allow \\"LD A,(IX)\\". Perhaps\\r\\n                    // we should have this in the official list of variants, but instead let\'s just\\r\\n                    // hack it here.\\r\\n                    const nextToken = variant.tokens[i + 1];\\r\\n                    if (token === \\"+\\" &&\\r\\n                        (0,z80_inst__WEBPACK_IMPORTED_MODULE_2__.isOpcodeTemplateOperand)(nextToken) &&\\r\\n                        variant.tokens[i + 2] === \\")\\" &&\\r\\n                        this.foundChar(\\")\\")) {\\r\\n                        // Pretend missing arg is zero\\r\\n                        args.set(nextToken, 0);\\r\\n                        i += 2;\\r\\n                        continue;\\r\\n                    }\\r\\n                    if (token === \\",\\" || token === \\"(\\" || token === \\")\\") {\\r\\n                        if (!this.foundChar(token)) {\\r\\n                            match = false;\\r\\n                        }\\r\\n                    }\\r\\n                    else if (token === \\"+\\") {\\r\\n                        // For LD A,(IX-dd) or LD A,(IX+dd), preread \'-dd\' or \'+dd\' part\\r\\n                        ddValue = this.readExpression(false);\\r\\n                    }\\r\\n                    else if ((0,z80_inst__WEBPACK_IMPORTED_MODULE_2__.isOpcodeTemplateOperand)(token)) {\\r\\n                        // Parse. \\r\\n                        // If +dd, -dd is preread, do not parse and use the value. \\r\\n                        const value = ddValue !== undefined ? ddValue : this.readExpression(false);\\r\\n                        ddValue = undefined;\\r\\n                        if (value === undefined) {\\r\\n                            match = false;\\r\\n                        }\\r\\n                        else {\\r\\n                            // Add value to binary.\\r\\n                            if (args.has(token)) {\\r\\n                                throw new Error(\\"duplicate arg: \\" + this.line);\\r\\n                            }\\r\\n                            args.set(token, value);\\r\\n                        }\\r\\n                    }\\r\\n                    else if (parseDigit(token[0], 10) !== undefined) {\\r\\n                        // If the token is a number, then we must parse an expression and\\r\\n                        // compare the values. This is used for BIT, SET, RES, RST, IM, and one\\r\\n                        // variant of OUT (OUT (C), 0).\\r\\n                        const expectedValue = parseInt(token, 10);\\r\\n                        const actualValue = this.readExpression(false);\\r\\n                        if (expectedValue !== actualValue) {\\r\\n                            match = false;\\r\\n                        }\\r\\n                    }\\r\\n                    else {\\r\\n                        // Register or flag.\\r\\n                        const identifier = this.readIdentifier(true, true);\\r\\n                        if (identifier !== token) {\\r\\n                            match = false;\\r\\n                        }\\r\\n                    }\\r\\n                    if (!match) {\\r\\n                        break;\\r\\n                    }\\r\\n                }\\r\\n                if (match) {\\r\\n                    // Make sure they\'re no extra garbage.\\r\\n                    if (!this.isEndOfLine()) {\\r\\n                        match = false;\\r\\n                    }\\r\\n                }\\r\\n                if (match) {\\r\\n                    this.assembledLine.binary = [];\\r\\n                    for (const op of variant.opcodes) {\\r\\n                        if (typeof (op) === \\"string\\") {\\r\\n                            const value = args.get(op);\\r\\n                            if (value === undefined) {\\r\\n                                throw new Error(\\"arg \\" + op + \\" not found for \\" + this.line);\\r\\n                            }\\r\\n                            switch (op) {\\r\\n                                case \\"nnnn\\":\\r\\n                                    this.assembledLine.binary.push((0,z80_base__WEBPACK_IMPORTED_MODULE_0__.lo)(value));\\r\\n                                    this.assembledLine.binary.push((0,z80_base__WEBPACK_IMPORTED_MODULE_0__.hi)(value));\\r\\n                                    break;\\r\\n                                case \\"nn\\":\\r\\n                                case \\"dd\\":\\r\\n                                    this.assembledLine.binary.push((0,z80_base__WEBPACK_IMPORTED_MODULE_0__.lo)(value));\\r\\n                                    break;\\r\\n                                case \\"offset\\":\\r\\n                                    this.assembledLine.binary.push((0,z80_base__WEBPACK_IMPORTED_MODULE_0__.lo)(value - this.assembledLine.address - this.assembledLine.binary.length - 1));\\r\\n                                    break;\\r\\n                                default:\\r\\n                                    throw new Error(\\"Unknown arg type \\" + op);\\r\\n                            }\\r\\n                        }\\r\\n                        else {\\r\\n                            this.assembledLine.binary.push(op);\\r\\n                        }\\r\\n                    }\\r\\n                    this.assembledLine.variant = variant;\\r\\n                    break;\\r\\n                }\\r\\n                else {\\r\\n                    // Reset reader.\\r\\n                    this.column = argStart;\\r\\n                }\\r\\n            }\\r\\n            if (!match && this.assembledLine.error === undefined) {\\r\\n                this.assembledLine.error = \\"no variant found for \\" + mnemonic;\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            this.assembledLine.error = \\"unknown mnemonic: \\" + mnemonic;\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * Substitute macro parameters and expand {} expressions.\\r\\n     */\\r\\n    performMacroSubstitutions(line, macro, args) {\\r\\n        const parts = [];\\r\\n        let i = 0;\\r\\n        while (i < line.length) {\\r\\n            const ch = line.charAt(i);\\r\\n            if (ch === macro.tag) {\\r\\n                const beginName = i + 1;\\r\\n                let endName = beginName;\\r\\n                let maxArgIndex = -1, maxEndName = -1;\\r\\n                while (endName < line.length && isLegalIdentifierCharacter(line.charAt(endName), endName === beginName)) {\\r\\n                    endName++;\\r\\n                    const name = line.substring(beginName, endName);\\r\\n                    const argIndex = macro.params.indexOf(name);\\r\\n                    if (argIndex >= 0) {\\r\\n                        maxArgIndex = argIndex;\\r\\n                        maxEndName = endName;\\r\\n                    }\\r\\n                }\\r\\n                if (maxArgIndex >= 0) {\\r\\n                    parts.push(args[maxArgIndex]);\\r\\n                    i = maxEndName;\\r\\n                }\\r\\n                else {\\r\\n                    parts.push(ch);\\r\\n                    i++;\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                parts.push(ch);\\r\\n                i++;\\r\\n            }\\r\\n        }\\r\\n        return parts.join(\\"\\");\\r\\n    }\\r\\n    /**\\r\\n     * Reads a string like \\"abc\\", or undefined if didn\'t find a string.\\r\\n     * If found the beginning of a string but not the end, sets this.assembledLine.error\\r\\n     * and returns undefined.\\r\\n     */\\r\\n    readString() {\\r\\n        // Find beginning of string.\\r\\n        if (this.column === this.line.length || (this.line[this.column] !== \'\\"\' && this.line[this.column] !== \\"\'\\")) {\\r\\n            return undefined;\\r\\n        }\\r\\n        const quoteChar = this.line[this.column];\\r\\n        this.column++;\\r\\n        // Find end of string.\\r\\n        const startIndex = this.column;\\r\\n        while (this.column < this.line.length && this.line[this.column] !== quoteChar) {\\r\\n            this.column++;\\r\\n        }\\r\\n        if (this.column === this.line.length) {\\r\\n            // No end quote.\\r\\n            this.assembledLine.error = \\"no end quote in string\\";\\r\\n            return undefined;\\r\\n        }\\r\\n        // Clip out string contents.\\r\\n        const value = this.line.substring(startIndex, this.column);\\r\\n        this.column++;\\r\\n        this.skipWhitespace();\\r\\n        return value;\\r\\n    }\\r\\n    /**\\r\\n     * Read an expression.\\r\\n     *\\r\\n     * @param canStartWithOpenParens whether to allow the expression to start with an open parenthesis.\\r\\n     *\\r\\n     * @return the value of the expression, or undefined if there was an error reading it.\\r\\n     */\\r\\n    readExpression(canStartWithOpenParens) {\\r\\n        if (!canStartWithOpenParens && this.line[this.column] === \'(\') {\\r\\n            // Expressions can\'t start with an open parenthesis because that\'s ambiguous\\r\\n            // with dereferencing.\\r\\n            return undefined;\\r\\n        }\\r\\n        return this.readComparison();\\r\\n    }\\r\\n    /**\\r\\n     * Read a comparison(x>0 etc.), or undefined if there was an error reading it.\\r\\n     */\\r\\n    readComparison() {\\r\\n        let value = 0;\\r\\n        const leftValue = this.readSum();\\r\\n        if (leftValue === undefined) {\\r\\n            return undefined;\\r\\n        }\\r\\n        const ops = {\\r\\n            \\">\\": \\"gt\\", \\"<\\": \\"lt\\",\\r\\n            \\">=\\": \\"ge\\", \\"<=\\": \\"le\\",\\r\\n            \\"!=\\": \\"ne\\", \\"==\\": \\"eq\\",\\r\\n            \\"gt\\": \\"gt\\", \\"lt\\": \\"lt\\",\\r\\n            \\"ge\\": \\"ge\\", \\"le\\": \\"le\\",\\r\\n            \\"ne\\": \\"ne\\", \\"eq\\": \\"eq\\",\\r\\n        };\\r\\n        const op = this.foundOneOfToken(Object.keys(ops));\\r\\n        if (!op)\\r\\n            return leftValue;\\r\\n        const rightValue = this.readSum();\\r\\n        if (rightValue === undefined) {\\r\\n            return undefined;\\r\\n        }\\r\\n        switch (ops[op]) {\\r\\n            case \\"gt\\":\\r\\n                return leftValue > rightValue ? 1 : 0;\\r\\n            case \\"lt\\":\\r\\n                return leftValue < rightValue ? 1 : 0;\\r\\n            case \\"ge\\":\\r\\n                return leftValue >= rightValue ? 1 : 0;\\r\\n            case \\"le\\":\\r\\n                return leftValue <= rightValue ? 1 : 0;\\r\\n            case \\"eq\\":\\r\\n                return leftValue == rightValue ? 1 : 0;\\r\\n            case \\"ne\\":\\r\\n                return leftValue != rightValue ? 1 : 0;\\r\\n        }\\r\\n        return undefined;\\r\\n    }\\r\\n    /**\\r\\n     * Read a sum, or undefined if there was an error reading it.\\r\\n     */\\r\\n    readSum() {\\r\\n        let value = 0;\\r\\n        let sign = 1;\\r\\n        while (true) {\\r\\n            const subValue = this.readProduct();\\r\\n            if (subValue === undefined) {\\r\\n                return undefined;\\r\\n            }\\r\\n            value += sign * subValue;\\r\\n            if (this.foundChar(\'+\')) {\\r\\n                sign = 1;\\r\\n            }\\r\\n            else if (this.foundChar(\'-\')) {\\r\\n                sign = -1;\\r\\n            }\\r\\n            else {\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n        return value;\\r\\n    }\\r\\n    /**\\r\\n     * Read a product, or undefined if there was an error reading it.\\r\\n     */\\r\\n    readProduct() {\\r\\n        let value = 1;\\r\\n        let isMultiply = true;\\r\\n        while (true) {\\r\\n            const subValue = this.readLogic();\\r\\n            if (subValue === undefined) {\\r\\n                return undefined;\\r\\n            }\\r\\n            if (isMultiply) {\\r\\n                value *= subValue;\\r\\n            }\\r\\n            else {\\r\\n                value /= subValue;\\r\\n            }\\r\\n            if (this.foundChar(\'*\')) {\\r\\n                isMultiply = true;\\r\\n            }\\r\\n            else if (this.foundChar(\'/\')) {\\r\\n                isMultiply = false;\\r\\n            }\\r\\n            else {\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n        return value;\\r\\n    }\\r\\n    /**\\r\\n     * Read a logic (&, |, and ^) expression, or undefined if there was an error reading it.\\r\\n     */\\r\\n    readLogic() {\\r\\n        let value = 0;\\r\\n        let op = \\"\\";\\r\\n        while (true) {\\r\\n            const subValue = this.readShift();\\r\\n            if (subValue === undefined) {\\r\\n                return undefined;\\r\\n            }\\r\\n            if (op === \\"&\\") {\\r\\n                value &= subValue;\\r\\n            }\\r\\n            else if (op === \\"|\\") {\\r\\n                value |= subValue;\\r\\n            }\\r\\n            else if (op === \\"^\\") {\\r\\n                value ^= subValue;\\r\\n            }\\r\\n            else {\\r\\n                value = subValue;\\r\\n            }\\r\\n            const ch = this.foundOneOfChar([\\"&\\", \\"|\\", \\"^\\"]);\\r\\n            if (ch !== undefined) {\\r\\n                op = ch;\\r\\n            }\\r\\n            else {\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n        return value;\\r\\n    }\\r\\n    /**\\r\\n     * Read a shift (<< and >>) expression, or undefined if there was an error reading it.\\r\\n     */\\r\\n    readShift() {\\r\\n        let value = 0;\\r\\n        let op = \\"\\";\\r\\n        while (true) {\\r\\n            const subValue = this.readMonadic();\\r\\n            if (subValue === undefined) {\\r\\n                return undefined;\\r\\n            }\\r\\n            if (op === \\"<<\\") {\\r\\n                value <<= subValue;\\r\\n            }\\r\\n            else if (op === \\">>\\") {\\r\\n                value >>= subValue;\\r\\n            }\\r\\n            else {\\r\\n                value = subValue;\\r\\n            }\\r\\n            op = this.line.substr(this.column, 2);\\r\\n            if (op === \\"<<\\" || op === \\">>\\") {\\r\\n                this.column += 2;\\r\\n                this.skipWhitespace();\\r\\n            }\\r\\n            else {\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n        return value;\\r\\n    }\\r\\n    /**\\r\\n     * Read a monadic (unary prefix operator) expression, or undefined if there was an error reading it.\\r\\n     */\\r\\n    readMonadic() {\\r\\n        const ch = this.foundOneOfChar([\\"+\\", \\"-\\", \\"~\\", \\"!\\"]);\\r\\n        if (ch !== undefined) {\\r\\n            const value = this.readMonadic();\\r\\n            if (value === undefined) {\\r\\n                return undefined;\\r\\n            }\\r\\n            switch (ch) {\\r\\n                case \\"+\\":\\r\\n                default:\\r\\n                    return value;\\r\\n                case \\"-\\":\\r\\n                    return -value;\\r\\n                case \\"~\\":\\r\\n                    return ~value;\\r\\n                case \\"!\\":\\r\\n                    return !value ? 1 : 0;\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            return this.readAtom();\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * Read an atom (number constant, identifier) expression, or undefined if there was an error reading it.\\r\\n     */\\r\\n    readAtom() {\\r\\n        const startIndex = this.column;\\r\\n        // Parenthesized expression.\\r\\n        if (this.foundChar(\'(\')) {\\r\\n            const value = this.readExpression(true);\\r\\n            if (value === undefined || !this.foundChar(\')\')) {\\r\\n                return undefined;\\r\\n            }\\r\\n            return value;\\r\\n        }\\r\\n        // Try identifier.\\r\\n        const identifier = this.readIdentifier(false, false);\\r\\n        if (identifier !== undefined) {\\r\\n            // See if it\'s a built-in function.\\r\\n            if (this.foundChar(\\"(\\")) {\\r\\n                const value = this.readExpression(true);\\r\\n                if (value === undefined) {\\r\\n                    if (this.assembledLine.error === undefined) {\\r\\n                        this.assembledLine.error = \\"missing expression for function call\\";\\r\\n                    }\\r\\n                    return undefined;\\r\\n                }\\r\\n                if (!this.foundChar(\\")\\")) {\\r\\n                    if (this.assembledLine.error === undefined) {\\r\\n                        this.assembledLine.error = \\"missing end parenthesis for function call\\";\\r\\n                    }\\r\\n                    return undefined;\\r\\n                }\\r\\n                switch (identifier) {\\r\\n                    case \\"lo\\":\\r\\n                        return (0,z80_base__WEBPACK_IMPORTED_MODULE_0__.lo)(value);\\r\\n                    case \\"hi\\":\\r\\n                        return (0,z80_base__WEBPACK_IMPORTED_MODULE_0__.hi)(value);\\r\\n                    default:\\r\\n                        this.assembledLine.error = \\"unknown function \\\\\\"\\" + identifier + \\"\\\\\\"\\";\\r\\n                        return undefined;\\r\\n                }\\r\\n            }\\r\\n            // Must be symbol reference. Get address of identifier or value of constant.\\r\\n            // Local symbols can shadow global ones, and might not be defined yet, so only check\\r\\n            // the local scope in pass 1. In pass 2 the identifier must have been defined somewhere.\\r\\n            let symbolInfo = this.pass.locals().get(identifier, this.pass.passNumber !== 1);\\r\\n            if (symbolInfo === undefined) {\\r\\n                if (this.pass.passNumber === 1) {\\r\\n                    // For if directive, defined value is needed;\\r\\n                    const definedSymbolInfo = this.pass.locals().get(identifier, true);\\r\\n                    const value = definedSymbolInfo ? definedSymbolInfo.value : 0;\\r\\n                    // Record that this identifier was used so that we can include its file with\\r\\n                    // library includes. We don\'t know whether it\'s a local or global symbol.\\r\\n                    // Assume local and push it out in #endlocal.\\r\\n                    symbolInfo = new SymbolInfo(identifier, value);\\r\\n                    this.pass.locals().set(symbolInfo);\\r\\n                }\\r\\n                else {\\r\\n                    throw new Error(\\"Identifier \\" + identifier + \\" was not defined in pass 1\\");\\r\\n                }\\r\\n            }\\r\\n            if (this.pass.passNumber === 1) {\\r\\n                // TODO I don\'t like this, given that evaluating this expression might be speculative.\\r\\n                symbolInfo.references.push(new SymbolReference(this.assembledLine.listingLineNumber, startIndex));\\r\\n            }\\r\\n            else if (symbolInfo.definitions.length === 0) {\\r\\n                this.assembledLine.error = \\"unknown identifier \\\\\\"\\" + identifier + \\"\\\\\\"\\";\\r\\n                return 0;\\r\\n            }\\r\\n            else if (symbolInfo.definitions.length > 1 &&\\r\\n                symbolInfo.changesValue &&\\r\\n                symbolInfo.definitions[0].lineNumber >= this.assembledLine.listingLineNumber) {\\r\\n                this.assembledLine.error = \\"label \\\\\\"\\" + identifier + \\"\\\\\\" not yet defined here\\";\\r\\n                return 0;\\r\\n            }\\r\\n            if (this.pass.passNumber > 1) {\\r\\n                const symRef = symbolInfo.find(symbolInfo.references, this.assembledLine.listingLineNumber, startIndex);\\r\\n                if (symRef)\\r\\n                    symRef.value = symbolInfo.value;\\r\\n            }\\r\\n            return symbolInfo.value;\\r\\n        }\\r\\n        // Try literal character, like \'a\'.\\r\\n        if (this.isChar(\\"\'\\")) {\\r\\n            if (this.column > this.line.length - 3 || this.line[this.column + 2] !== \\"\'\\") {\\r\\n                // TODO invalid character constant, show error.\\r\\n                return undefined;\\r\\n            }\\r\\n            const value = this.line.charCodeAt(this.column + 1);\\r\\n            this.column += 3;\\r\\n            this.skipWhitespace();\\r\\n            return value;\\r\\n        }\\r\\n        // Try numeric literal.\\r\\n        let base = 10;\\r\\n        let sign = 1;\\r\\n        let gotDigit = false;\\r\\n        if (this.foundChar(\'-\')) {\\r\\n            sign = -1;\\r\\n        }\\r\\n        // Hex numbers can start with $, like $FF.\\r\\n        if (this.foundChar(\'$\')) {\\r\\n            if (this.column === this.line.length || parseDigit(this.line[this.column], 16) === undefined) {\\r\\n                // It\'s a reference to the current address, not a hex prefix.\\r\\n                return sign * this.assembledLine.address;\\r\\n            }\\r\\n            base = 16;\\r\\n        }\\r\\n        else if (this.foundChar(\'%\')) {\\r\\n            base = 2;\\r\\n        }\\r\\n        // Before we parse the number, we need to look ahead to see\\r\\n        // if it ends with H, like 0FFH.\\r\\n        if (base === 10) {\\r\\n            const beforeIndex = this.column;\\r\\n            while (this.column < this.line.length && parseDigit(this.line[this.column], 16) !== undefined) {\\r\\n                this.column++;\\r\\n            }\\r\\n            if (this.column < this.line.length && this.line[this.column].toUpperCase() === \\"H\\") {\\r\\n                base = 16;\\r\\n            }\\r\\n            this.column = beforeIndex;\\r\\n        }\\r\\n        // And again we need to look for B, like 010010101B. We can\'t fold this into the\\r\\n        // above look since a \\"B\\" is a legal hex number!\\r\\n        if (base === 10) {\\r\\n            const beforeIndex = this.column;\\r\\n            while (this.column < this.line.length && parseDigit(this.line[this.column], 2) !== undefined) {\\r\\n                this.column++;\\r\\n            }\\r\\n            if (this.column < this.line.length && this.line[this.column].toUpperCase() === \\"B\\" &&\\r\\n                // \\"B\\" can\'t be followed by hex digit, or it\'s not the final character.\\r\\n                (this.column === this.line.length || parseDigit(this.line[this.column + 1], 16) === undefined)) {\\r\\n                base = 2;\\r\\n            }\\r\\n            this.column = beforeIndex;\\r\\n        }\\r\\n        // Look for 0x or 0b prefix. Must do this after above checks so that we correctly\\r\\n        // mark \\"0B1H\\" as hex and not binary.\\r\\n        if (base === 10 && this.column + 2 < this.line.length && this.line[this.column] === \'0\') {\\r\\n            if (this.line[this.column + 1].toLowerCase() == \'x\') {\\r\\n                base = 16;\\r\\n                this.column += 2;\\r\\n            }\\r\\n            else if (this.line[this.column + 1].toLowerCase() == \'b\' &&\\r\\n                // Must check next digit to distinguish from just \\"0B\\".\\r\\n                parseDigit(this.line[this.column + 2], 2) !== undefined) {\\r\\n                base = 2;\\r\\n                this.column += 2;\\r\\n            }\\r\\n        }\\r\\n        // Parse number.\\r\\n        let value = 0;\\r\\n        while (true) {\\r\\n            if (this.column == this.line.length) {\\r\\n                break;\\r\\n            }\\r\\n            const ch = this.line[this.column];\\r\\n            let chValue = parseDigit(ch, base);\\r\\n            if (chValue === undefined) {\\r\\n                break;\\r\\n            }\\r\\n            value = value * base + chValue;\\r\\n            gotDigit = true;\\r\\n            this.column++;\\r\\n        }\\r\\n        if (!gotDigit) {\\r\\n            // Didn\'t parse anything.\\r\\n            return undefined;\\r\\n        }\\r\\n        // Check for base suffix.\\r\\n        if (this.column < this.line.length) {\\r\\n            const baseChar = this.line[this.column].toUpperCase();\\r\\n            if (baseChar === \\"H\\") {\\r\\n                // Check for programmer errors.\\r\\n                if (base !== 16) {\\r\\n                    if (this.assembledLine.error === undefined) {\\r\\n                        this.assembledLine.error = \\"found H at end of non-hex number: \\" + this.line.substring(startIndex, this.column + 1);\\r\\n                    }\\r\\n                    return undefined;\\r\\n                }\\r\\n                this.column++;\\r\\n            }\\r\\n            else if (baseChar === \\"B\\") {\\r\\n                // Check for programmer errors.\\r\\n                if (base !== 2) {\\r\\n                    if (this.assembledLine.error === undefined) {\\r\\n                        this.assembledLine.error = \\"found B at end of non-binary number: \\" + this.line.substring(startIndex, this.column + 1);\\r\\n                    }\\r\\n                    return undefined;\\r\\n                }\\r\\n                this.column++;\\r\\n            }\\r\\n        }\\r\\n        this.skipWhitespace();\\r\\n        return sign * value;\\r\\n    }\\r\\n    skipWhitespace() {\\r\\n        while (this.column < this.line.length && isWhitespace(this.line[this.column])) {\\r\\n            this.column++;\\r\\n        }\\r\\n    }\\r\\n    readIdentifier(allowRegister, toLowerCase) {\\r\\n        const startIndex = this.column;\\r\\n        // Skip through the identifier.\\r\\n        while (this.column < this.line.length && isLegalIdentifierCharacter(this.line[this.column], this.column == startIndex)) {\\r\\n            this.column++;\\r\\n        }\\r\\n        if (this.column > startIndex) {\\r\\n            let identifier = this.line.substring(startIndex, this.column);\\r\\n            if (toLowerCase) {\\r\\n                identifier = identifier.toLowerCase();\\r\\n            }\\r\\n            // Special case to parse AF\'.\\r\\n            if (allowRegister && identifier.toLowerCase() === \\"af\\" && this.foundChar(\\"\'\\")) {\\r\\n                identifier += \\"\'\\";\\r\\n            }\\r\\n            if (!allowRegister && ((0,z80_base__WEBPACK_IMPORTED_MODULE_0__.isWordReg)(identifier) || (0,z80_base__WEBPACK_IMPORTED_MODULE_0__.isByteReg)(identifier) || isFlag(identifier))) {\\r\\n                // Register names can\'t be identifiers.\\r\\n                this.column = startIndex;\\r\\n                return undefined;\\r\\n            }\\r\\n            this.skipWhitespace();\\r\\n            this.previousToken = startIndex;\\r\\n            return identifier;\\r\\n        }\\r\\n        else {\\r\\n            return undefined;\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * If the next character matches the parameter, skips it and subsequent whitespace and return true.\\r\\n     * Else returns false.\\r\\n     */\\r\\n    foundChar(ch) {\\r\\n        if (this.isChar(ch)) {\\r\\n            this.column++;\\r\\n            this.skipWhitespace();\\r\\n            return true;\\r\\n        }\\r\\n        else {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * If any of the specified characters is next, it is skipped (and subsequent whitespace) and returned.\\r\\n     * Else undefined is returned.\\r\\n     */\\r\\n    foundOneOfChar(chars) {\\r\\n        for (const ch of chars) {\\r\\n            if (this.foundChar(ch)) {\\r\\n                return ch;\\r\\n            }\\r\\n        }\\r\\n        return undefined;\\r\\n    }\\r\\n    /**\\r\\n     * If the next token(string with length>=1) matches the parameter, skips it and subsequent whitespace and return true.\\r\\n     * Else returns false.\\r\\n     */\\r\\n    foundToken(token) {\\r\\n        const looking = this.line.substring(this.column, this.column + token.length);\\r\\n        if (looking === token) {\\r\\n            this.column += token.length;\\r\\n            this.skipWhitespace();\\r\\n            return true;\\r\\n        }\\r\\n        else {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n    /**\\r\\n     * If any of the specified tokens is next, it is skipped (and subsequent whitespace) and returned.\\r\\n     * Else undefined is returned.\\r\\n     */\\r\\n    foundOneOfToken(tokens) {\\r\\n        for (const token of tokens) {\\r\\n            if (this.foundToken(token)) {\\r\\n                return token;\\r\\n            }\\r\\n        }\\r\\n        return undefined;\\r\\n    }\\r\\n    // Whether the next character matches the parameter. Does not advance.\\r\\n    isChar(ch) {\\r\\n        return this.column < this.line.length && this.line[this.column] === ch;\\r\\n    }\\r\\n}\\r\\n//# sourceMappingURL=Asm.js.map\\n\\n//# sourceURL=webpack://wptest/../packages/z80-asm/dist/Asm.js?");\n\n/***/ }),\n\n/***/ "../packages/z80-asm/dist/index.js":\n/*!*****************************************!*\\\n  !*** ../packages/z80-asm/dist/index.js ***!\n  \\*****************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\neval("__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\"Asm\\": () => (/* reexport safe */ _Asm_js__WEBPACK_IMPORTED_MODULE_0__.Asm),\\n/* harmony export */   \\"AssembledLine\\": () => (/* reexport safe */ _Asm_js__WEBPACK_IMPORTED_MODULE_0__.AssembledLine),\\n/* harmony export */   \\"FileInfo\\": () => (/* reexport safe */ _Asm_js__WEBPACK_IMPORTED_MODULE_0__.FileInfo),\\n/* harmony export */   \\"SourceFile\\": () => (/* reexport safe */ _Asm_js__WEBPACK_IMPORTED_MODULE_0__.SourceFile),\\n/* harmony export */   \\"SymbolInfo\\": () => (/* reexport safe */ _Asm_js__WEBPACK_IMPORTED_MODULE_0__.SymbolInfo),\\n/* harmony export */   \\"SymbolReference\\": () => (/* reexport safe */ _Asm_js__WEBPACK_IMPORTED_MODULE_0__.SymbolReference),\\n/* harmony export */   \\"getAsmDirectiveDocs\\": () => (/* reexport safe */ _Asm_js__WEBPACK_IMPORTED_MODULE_0__.getAsmDirectiveDocs)\\n/* harmony export */ });\\n/* harmony import */ var _Asm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Asm.js */ \\"../packages/z80-asm/dist/Asm.js\\");\\n\\r\\n//# sourceMappingURL=index.js.map\\n\\n//# sourceURL=webpack://wptest/../packages/z80-asm/dist/index.js?");\n\n/***/ }),\n\n/***/ "../packages/z80-asm/dist/path.js":\n/*!****************************************!*\\\n  !*** ../packages/z80-asm/dist/path.js ***!\n  \\****************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\neval("__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\"dirname\\": () => (/* binding */ dirname),\\n/* harmony export */   \\"parse\\": () => (/* binding */ parse),\\n/* harmony export */   \\"resolve\\": () => (/* binding */ resolve)\\n/* harmony export */ });\\n/**\\r\\n * Replacements for the node \\"path\\" module, so we can run these in the browser.\\r\\n */\\r\\nconst SLASH = 47;\\r\\n// Replace the Node \\"path.dirname()\\" function.\\r\\nfunction dirname(path) {\\r\\n    if (path.length === 0) {\\r\\n        return \\".\\";\\r\\n    }\\r\\n    const hasRoot = path.charCodeAt(0) === SLASH;\\r\\n    let end = -1;\\r\\n    // Skip trailing slashes.\\r\\n    let matchedSlash = true;\\r\\n    for (let i = path.length - 1; i > 0; --i) {\\r\\n        if (path.charCodeAt(i) === SLASH) {\\r\\n            if (!matchedSlash) {\\r\\n                end = i;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n        else {\\r\\n            matchedSlash = false;\\r\\n        }\\r\\n    }\\r\\n    if (end === -1) {\\r\\n        return hasRoot ? \\"/\\" : \\".\\";\\r\\n    }\\r\\n    if (hasRoot && end === 1) {\\r\\n        return \\"//\\";\\r\\n    }\\r\\n    return path.slice(0, end);\\r\\n}\\r\\n// Replace the Node \\"path.resolve()\\" function.\\r\\nfunction resolve(...paths) {\\r\\n    let resolvedPath = \\"\\";\\r\\n    for (const path of paths) {\\r\\n        if (path === \\"\\") {\\r\\n            // Skip it.\\r\\n        }\\r\\n        else if (path.startsWith(\\"/\\")) {\\r\\n            // Absolute path starts over.\\r\\n            resolvedPath = path;\\r\\n        }\\r\\n        else {\\r\\n            if (resolvedPath !== \\"\\" && !resolvedPath.endsWith(\\"/\\")) {\\r\\n                resolvedPath += \\"/\\";\\r\\n            }\\r\\n            resolvedPath += path;\\r\\n        }\\r\\n    }\\r\\n    return resolvedPath;\\r\\n}\\r\\n// Replace the Node \\"path.parse()\\" function, but only the \\"name\\" and \\"ext\\".\\r\\nfunction parse(path) {\\r\\n    // Find filename.\\r\\n    let i = path.lastIndexOf(\\"/\\");\\r\\n    if (i >= 0) {\\r\\n        path = path.substring(i + 1);\\r\\n    }\\r\\n    // Find extension.\\r\\n    i = path.lastIndexOf(\\".\\");\\r\\n    if (i > 0) {\\r\\n        return {\\r\\n            name: path.substring(0, i),\\r\\n            ext: path.substring(i),\\r\\n        };\\r\\n    }\\r\\n    else {\\r\\n        return {\\r\\n            name: path,\\r\\n            ext: \\"\\",\\r\\n        };\\r\\n    }\\r\\n}\\r\\n//# sourceMappingURL=path.js.map\\n\\n//# sourceURL=webpack://wptest/../packages/z80-asm/dist/path.js?");\n\n/***/ }),\n\n/***/ "../packages/z80-base/dist/Flag.js":\n/*!*****************************************!*\\\n  !*** ../packages/z80-base/dist/Flag.js ***!\n  \\*****************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\neval("__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\"Flag\\": () => (/* binding */ Flag)\\n/* harmony export */ });\\n/**\\r\\n * The flag bits in the F register.\\r\\n */\\r\\nvar Flag;\\r\\n(function (Flag) {\\r\\n    /**\\r\\n     * Carry and borrow. Indicates that the addition or subtraction did not\\r\\n     * fit in the register.\\r\\n     */\\r\\n    Flag[Flag[\\"C\\"] = 1] = \\"C\\";\\r\\n    /**\\r\\n     * Set if the last operation was a subtraction.\\r\\n     */\\r\\n    Flag[Flag[\\"N\\"] = 2] = \\"N\\";\\r\\n    /**\\r\\n     * Parity: Indicates that the result has an even number of bits set.\\r\\n     */\\r\\n    Flag[Flag[\\"P\\"] = 4] = \\"P\\";\\r\\n    /**\\r\\n     * Overflow: Indicates that two\'s complement does not fit in register.\\r\\n     */\\r\\n    Flag[Flag[\\"V\\"] = 4] = \\"V\\";\\r\\n    /**\\r\\n     * Undocumented bit, but internal state can leak into it.\\r\\n     */\\r\\n    Flag[Flag[\\"X3\\"] = 8] = \\"X3\\";\\r\\n    /**\\r\\n     * Half carry: Carry from bit 3 to bit 4 during BCD operations.\\r\\n     */\\r\\n    Flag[Flag[\\"H\\"] = 16] = \\"H\\";\\r\\n    /**\\r\\n     * Undocumented bit, but internal state can leak into it.\\r\\n     */\\r\\n    Flag[Flag[\\"X5\\"] = 32] = \\"X5\\";\\r\\n    /**\\r\\n     * Set if value is zero.\\r\\n     */\\r\\n    Flag[Flag[\\"Z\\"] = 64] = \\"Z\\";\\r\\n    /**\\r\\n     * Set if value is negative.\\r\\n     */\\r\\n    Flag[Flag[\\"S\\"] = 128] = \\"S\\";\\r\\n})(Flag || (Flag = {}));\\r\\n//# sourceMappingURL=Flag.js.map\\n\\n//# sourceURL=webpack://wptest/../packages/z80-base/dist/Flag.js?");\n\n/***/ }),\n\n/***/ "../packages/z80-base/dist/KnownLabels.js":\n/*!************************************************!*\\\n  !*** ../packages/z80-base/dist/KnownLabels.js ***!\n  \\************************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\neval("__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\"Z80_KNOWN_LABELS\\": () => (/* binding */ Z80_KNOWN_LABELS)\\n/* harmony export */ });\\n/**\\r\\n * Important addresses to the CPU.\\r\\n */\\r\\nconst Z80_KNOWN_LABELS = [\\r\\n    { name: \\"rst00\\", address: 0x0000 },\\r\\n    { name: \\"rst08\\", address: 0x0008 },\\r\\n    { name: \\"rst10\\", address: 0x0010 },\\r\\n    { name: \\"rst18\\", address: 0x0018 },\\r\\n    { name: \\"rst20\\", address: 0x0020 },\\r\\n    { name: \\"rst28\\", address: 0x0028 },\\r\\n    { name: \\"rst30\\", address: 0x0030 },\\r\\n    { name: \\"rst38\\", address: 0x0038 },\\r\\n];\\r\\n//# sourceMappingURL=KnownLabels.js.map\\n\\n//# sourceURL=webpack://wptest/../packages/z80-base/dist/KnownLabels.js?");\n\n/***/ }),\n\n/***/ "../packages/z80-base/dist/Register.js":\n/*!*********************************************!*\\\n  !*** ../packages/z80-base/dist/Register.js ***!\n  \\*********************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\neval("__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\"isByteReg\\": () => (/* binding */ isByteReg),\\n/* harmony export */   \\"isRegisterSetField\\": () => (/* binding */ isRegisterSetField),\\n/* harmony export */   \\"isWordReg\\": () => (/* binding */ isWordReg)\\n/* harmony export */ });\\n/**\\r\\n * All byte registers.\\r\\n */\\r\\nconst BYTE_REG_ARRAY = [\\"a\\", \\"f\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\", \\"h\\", \\"l\\", \\"ixh\\", \\"ixl\\", \\"iyh\\", \\"iyl\\", \\"i\\", \\"r\\"];\\r\\nconst BYTE_REG_SET = new Set(BYTE_REG_ARRAY);\\r\\n/**\\r\\n * All word registers. Uses the \\"Prime\\" suffix instead of an apostrophe so that\\r\\n * this can be used as a field name for the RegisterSet class.\\r\\n */\\r\\nconst WORD_REG_ARRAY = [\\"af\\", \\"bc\\", \\"de\\", \\"hl\\", \\"afPrime\\", \\"bcPrime\\", \\"dePrime\\", \\"hlPrime\\",\\r\\n    \\"ix\\", \\"iy\\", \\"sp\\", \\"pc\\"];\\r\\nconst WORD_REG_SET = new Set(WORD_REG_ARRAY);\\r\\n/**\\r\\n * Parallel array with apostrophe, for dealing with registers as they appear in assembly language.\\r\\n */\\r\\nconst WORD_REG_PRIME_ARRAY = WORD_REG_ARRAY.map((reg) => reg.replace(\\"Prime\\", \\"\'\\"));\\r\\nconst WORD_REG_PRIME_SET = new Set(WORD_REG_PRIME_ARRAY);\\r\\n/**\\r\\n * All internal registers.\\r\\n */\\r\\nconst INTERNAL_REG_ARRAY = [\\"memptr\\", \\"i\\", \\"r\\", \\"iff1\\", \\"iff2\\", \\"im\\", \\"halted\\"];\\r\\nconst INTERNAL_REG_SET = new Set(INTERNAL_REG_ARRAY);\\r\\n/**\\r\\n * Determine whether a register stores a word. The prime version should use an apostrophe, like hl\'.\\r\\n */\\r\\nfunction isWordReg(s) {\\r\\n    return WORD_REG_PRIME_SET.has(s.toLowerCase());\\r\\n}\\r\\n/**\\r\\n * Determine whether a register stores a byte.\\r\\n */\\r\\nfunction isByteReg(s) {\\r\\n    return BYTE_REG_SET.has(s.toLowerCase());\\r\\n}\\r\\n/**\\r\\n * Whether the string can be used as a field of the RegisterSet structure, in its getValue() method.\\r\\n */\\r\\nfunction isRegisterSetField(s) {\\r\\n    return BYTE_REG_SET.has(s) || WORD_REG_SET.has(s) || INTERNAL_REG_SET.has(s);\\r\\n}\\r\\n//# sourceMappingURL=Register.js.map\\n\\n//# sourceURL=webpack://wptest/../packages/z80-base/dist/Register.js?");\n\n/***/ }),\n\n/***/ "../packages/z80-base/dist/RegisterSet.js":\n/*!************************************************!*\\\n  !*** ../packages/z80-base/dist/RegisterSet.js ***!\n  \\************************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\neval("__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\"RegisterSet\\": () => (/* binding */ RegisterSet),\\n/* harmony export */   \\"registerSetFields\\": () => (/* binding */ registerSetFields)\\n/* harmony export */ });\\n/* harmony import */ var _Utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Utils.js */ \\"../packages/z80-base/dist/Utils.js\\");\\n\\r\\n/**\\r\\n * All registers in a Z80.\\r\\n */\\r\\nclass RegisterSet {\\r\\n    constructor() {\\r\\n        // External state:\\r\\n        this.af = 0;\\r\\n        this.bc = 0;\\r\\n        this.de = 0;\\r\\n        this.hl = 0;\\r\\n        this.afPrime = 0;\\r\\n        this.bcPrime = 0;\\r\\n        this.dePrime = 0;\\r\\n        this.hlPrime = 0;\\r\\n        this.ix = 0;\\r\\n        this.iy = 0;\\r\\n        this.sp = 0;\\r\\n        this.pc = 0;\\r\\n        // Internal state:\\r\\n        this.memptr = 0;\\r\\n        this.i = 0;\\r\\n        this.r = 0; // Low 7 bits of R.\\r\\n        this.r7 = 0; // Bit 7 of R.\\r\\n        this.iff1 = 0;\\r\\n        this.iff2 = 0;\\r\\n        this.im = 0;\\r\\n        this.halted = 0;\\r\\n    }\\r\\n    get a() {\\r\\n        return (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.hi)(this.af);\\r\\n    }\\r\\n    set a(value) {\\r\\n        this.af = (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.word)(value, this.f);\\r\\n    }\\r\\n    get f() {\\r\\n        return (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.lo)(this.af);\\r\\n    }\\r\\n    set f(value) {\\r\\n        this.af = (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.word)(this.a, value);\\r\\n    }\\r\\n    get b() {\\r\\n        return (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.hi)(this.bc);\\r\\n    }\\r\\n    set b(value) {\\r\\n        this.bc = (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.word)(value, this.c);\\r\\n    }\\r\\n    get c() {\\r\\n        return (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.lo)(this.bc);\\r\\n    }\\r\\n    set c(value) {\\r\\n        this.bc = (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.word)(this.b, value);\\r\\n    }\\r\\n    get d() {\\r\\n        return (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.hi)(this.de);\\r\\n    }\\r\\n    set d(value) {\\r\\n        this.de = (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.word)(value, this.e);\\r\\n    }\\r\\n    get e() {\\r\\n        return (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.lo)(this.de);\\r\\n    }\\r\\n    set e(value) {\\r\\n        this.de = (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.word)(this.d, value);\\r\\n    }\\r\\n    get h() {\\r\\n        return (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.hi)(this.hl);\\r\\n    }\\r\\n    set h(value) {\\r\\n        this.hl = (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.word)(value, this.l);\\r\\n    }\\r\\n    get l() {\\r\\n        return (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.lo)(this.hl);\\r\\n    }\\r\\n    set l(value) {\\r\\n        this.hl = (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.word)(this.h, value);\\r\\n    }\\r\\n    get ixh() {\\r\\n        return (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.hi)(this.ix);\\r\\n    }\\r\\n    set ixh(value) {\\r\\n        this.ix = (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.word)(value, this.ixl);\\r\\n    }\\r\\n    get ixl() {\\r\\n        return (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.lo)(this.ix);\\r\\n    }\\r\\n    set ixl(value) {\\r\\n        this.ix = (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.word)(this.ixh, value);\\r\\n    }\\r\\n    get iyh() {\\r\\n        return (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.hi)(this.iy);\\r\\n    }\\r\\n    set iyh(value) {\\r\\n        this.iy = (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.word)(value, this.iyl);\\r\\n    }\\r\\n    get iyl() {\\r\\n        return (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.lo)(this.iy);\\r\\n    }\\r\\n    set iyl(value) {\\r\\n        this.iy = (0,_Utils_js__WEBPACK_IMPORTED_MODULE_0__.word)(this.iyh, value);\\r\\n    }\\r\\n    /**\\r\\n     * Combine the two R parts together.\\r\\n     */\\r\\n    get rCombined() {\\r\\n        return (this.r7 & 0x80) | (this.r & 0xF7);\\r\\n    }\\r\\n    /**\\r\\n     * Get a register by name.\\r\\n     */\\r\\n    getValue(registerName) {\\r\\n        return this[registerName];\\r\\n    }\\r\\n    /**\\r\\n     * Create a clone of this object, with copies of the contents.\\r\\n     */\\r\\n    clone() {\\r\\n        const regs = new RegisterSet();\\r\\n        regs.bc = this.bc;\\r\\n        regs.de = this.de;\\r\\n        regs.hl = this.hl;\\r\\n        regs.af = this.af;\\r\\n        regs.afPrime = this.afPrime;\\r\\n        regs.bcPrime = this.bcPrime;\\r\\n        regs.dePrime = this.dePrime;\\r\\n        regs.hlPrime = this.hlPrime;\\r\\n        regs.ix = this.ix;\\r\\n        regs.iy = this.iy;\\r\\n        regs.sp = this.sp;\\r\\n        regs.pc = this.pc;\\r\\n        regs.memptr = this.memptr;\\r\\n        regs.i = this.i;\\r\\n        regs.r = this.r;\\r\\n        regs.r7 = this.r7;\\r\\n        regs.iff1 = this.iff1;\\r\\n        regs.iff2 = this.iff2;\\r\\n        regs.im = this.im;\\r\\n        regs.halted = this.halted;\\r\\n        return regs;\\r\\n    }\\r\\n}\\r\\n/**\\r\\n * All real fields of RegisterSet, for enumeration.\\r\\n */\\r\\nconst registerSetFields = [\\r\\n    \\"af\\", \\"bc\\", \\"de\\", \\"hl\\",\\r\\n    \\"afPrime\\", \\"bcPrime\\", \\"dePrime\\", \\"hlPrime\\",\\r\\n    \\"ix\\", \\"iy\\", \\"sp\\", \\"pc\\",\\r\\n    \\"memptr\\", \\"i\\", \\"r\\", \\"iff1\\", \\"iff2\\", \\"im\\", \\"halted\\"\\r\\n];\\r\\n//# sourceMappingURL=RegisterSet.js.map\\n\\n//# sourceURL=webpack://wptest/../packages/z80-base/dist/RegisterSet.js?");\n\n/***/ }),\n\n/***/ "../packages/z80-base/dist/Utils.js":\n/*!******************************************!*\\\n  !*** ../packages/z80-base/dist/Utils.js ***!\n  \\******************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\neval("__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\"add16\\": () => (/* binding */ add16),\\n/* harmony export */   \\"add8\\": () => (/* binding */ add8),\\n/* harmony export */   \\"dec16\\": () => (/* binding */ dec16),\\n/* harmony export */   \\"dec8\\": () => (/* binding */ dec8),\\n/* harmony export */   \\"hi\\": () => (/* binding */ hi),\\n/* harmony export */   \\"inc16\\": () => (/* binding */ inc16),\\n/* harmony export */   \\"inc8\\": () => (/* binding */ inc8),\\n/* harmony export */   \\"lo\\": () => (/* binding */ lo),\\n/* harmony export */   \\"signedByte\\": () => (/* binding */ signedByte),\\n/* harmony export */   \\"sub16\\": () => (/* binding */ sub16),\\n/* harmony export */   \\"sub8\\": () => (/* binding */ sub8),\\n/* harmony export */   \\"toHex\\": () => (/* binding */ toHex),\\n/* harmony export */   \\"toHexByte\\": () => (/* binding */ toHexByte),\\n/* harmony export */   \\"toHexLong\\": () => (/* binding */ toHexLong),\\n/* harmony export */   \\"toHexWord\\": () => (/* binding */ toHexWord),\\n/* harmony export */   \\"word\\": () => (/* binding */ word)\\n/* harmony export */ });\\n// Various utility functions.\\r\\n/**\\r\\n * Convert a number to hex and zero-pad to the specified number of hex digits.\\r\\n */\\r\\nfunction toHex(value, digits) {\\r\\n    return value.toString(16).toUpperCase().padStart(digits, \\"0\\");\\r\\n}\\r\\n/**\\r\\n * Convert a byte to hex.\\r\\n */\\r\\nfunction toHexByte(value) {\\r\\n    return toHex(value, 2);\\r\\n}\\r\\n/**\\r\\n * Convert a word to hex.\\r\\n */\\r\\nfunction toHexWord(value) {\\r\\n    return toHex(value, 4);\\r\\n}\\r\\n/**\\r\\n * Convert a long (32-bit value) to hex.\\r\\n */\\r\\nfunction toHexLong(value) {\\r\\n    value &= 0xFFFFFFFF;\\r\\n    // Convert two\'s complement negative numbers to positive numbers.\\r\\n    if (value < 0) {\\r\\n        value += 0x100000000;\\r\\n    }\\r\\n    return value.toString(16).toUpperCase().padStart(8, \\"0\\");\\r\\n}\\r\\n/**\\r\\n * Return the high byte of a word.\\r\\n */\\r\\nfunction hi(value) {\\r\\n    return (value >> 8) & 0xFF;\\r\\n}\\r\\n/**\\r\\n * Return the low byte of a word.\\r\\n */\\r\\nfunction lo(value) {\\r\\n    return value & 0xFF;\\r\\n}\\r\\n/**\\r\\n * Create a word from a high and low byte.\\r\\n */\\r\\nfunction word(highByte, lowByte) {\\r\\n    return ((highByte & 0xFF) << 8) | (lowByte & 0xFF);\\r\\n}\\r\\n/**\\r\\n * Increment a byte.\\r\\n */\\r\\nfunction inc8(value) {\\r\\n    return add8(value, 1);\\r\\n}\\r\\n/**\\r\\n * Increment a word.\\r\\n */\\r\\nfunction inc16(value) {\\r\\n    return add16(value, 1);\\r\\n}\\r\\n/**\\r\\n * Decrement a byte.\\r\\n */\\r\\nfunction dec8(value) {\\r\\n    return sub8(value, 1);\\r\\n}\\r\\n/**\\r\\n * Decrement a word.\\r\\n */\\r\\nfunction dec16(value) {\\r\\n    return sub16(value, 1);\\r\\n}\\r\\n/**\\r\\n * Add two bytes together.\\r\\n */\\r\\nfunction add8(a, b) {\\r\\n    return (a + b) & 0xFF;\\r\\n}\\r\\n/**\\r\\n * Add two words together.\\r\\n */\\r\\nfunction add16(a, b) {\\r\\n    return (a + b) & 0xFFFF;\\r\\n}\\r\\n/**\\r\\n * Subtract two bytes.\\r\\n */\\r\\nfunction sub8(a, b) {\\r\\n    return (a - b) & 0xFF;\\r\\n}\\r\\n/**\\r\\n * Subtract two words.\\r\\n */\\r\\nfunction sub16(a, b) {\\r\\n    return (a - b) & 0xFFFF;\\r\\n}\\r\\n/**\\r\\n * Convert a byte to a signed number (e.g., 0xff to -1).\\r\\n */\\r\\nfunction signedByte(value) {\\r\\n    return value >= 128 ? value - 256 : value;\\r\\n}\\r\\n//# sourceMappingURL=Utils.js.map\\n\\n//# sourceURL=webpack://wptest/../packages/z80-base/dist/Utils.js?");\n\n/***/ }),\n\n/***/ "../packages/z80-base/dist/index.js":\n/*!******************************************!*\\\n  !*** ../packages/z80-base/dist/index.js ***!\n  \\******************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\neval("__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\"Flag\\": () => (/* reexport safe */ _Flag_js__WEBPACK_IMPORTED_MODULE_3__.Flag),\\n/* harmony export */   \\"RegisterSet\\": () => (/* reexport safe */ _RegisterSet_js__WEBPACK_IMPORTED_MODULE_1__.RegisterSet),\\n/* harmony export */   \\"Z80_KNOWN_LABELS\\": () => (/* reexport safe */ _KnownLabels_js__WEBPACK_IMPORTED_MODULE_4__.Z80_KNOWN_LABELS),\\n/* harmony export */   \\"add16\\": () => (/* reexport safe */ _Utils_js__WEBPACK_IMPORTED_MODULE_2__.add16),\\n/* harmony export */   \\"add8\\": () => (/* reexport safe */ _Utils_js__WEBPACK_IMPORTED_MODULE_2__.add8),\\n/* harmony export */   \\"dec16\\": () => (/* reexport safe */ _Utils_js__WEBPACK_IMPORTED_MODULE_2__.dec16),\\n/* harmony export */   \\"dec8\\": () => (/* reexport safe */ _Utils_js__WEBPACK_IMPORTED_MODULE_2__.dec8),\\n/* harmony export */   \\"hi\\": () => (/* reexport safe */ _Utils_js__WEBPACK_IMPORTED_MODULE_2__.hi),\\n/* harmony export */   \\"inc16\\": () => (/* reexport safe */ _Utils_js__WEBPACK_IMPORTED_MODULE_2__.inc16),\\n/* harmony export */   \\"inc8\\": () => (/* reexport safe */ _Utils_js__WEBPACK_IMPORTED_MODULE_2__.inc8),\\n/* harmony export */   \\"isByteReg\\": () => (/* reexport safe */ _Register_js__WEBPACK_IMPORTED_MODULE_0__.isByteReg),\\n/* harmony export */   \\"isRegisterSetField\\": () => (/* reexport safe */ _Register_js__WEBPACK_IMPORTED_MODULE_0__.isRegisterSetField),\\n/* harmony export */   \\"isWordReg\\": () => (/* reexport safe */ _Register_js__WEBPACK_IMPORTED_MODULE_0__.isWordReg),\\n/* harmony export */   \\"lo\\": () => (/* reexport safe */ _Utils_js__WEBPACK_IMPORTED_MODULE_2__.lo),\\n/* harmony export */   \\"registerSetFields\\": () => (/* reexport safe */ _RegisterSet_js__WEBPACK_IMPORTED_MODULE_1__.registerSetFields),\\n/* harmony export */   \\"signedByte\\": () => (/* reexport safe */ _Utils_js__WEBPACK_IMPORTED_MODULE_2__.signedByte),\\n/* harmony export */   \\"sub16\\": () => (/* reexport safe */ _Utils_js__WEBPACK_IMPORTED_MODULE_2__.sub16),\\n/* harmony export */   \\"sub8\\": () => (/* reexport safe */ _Utils_js__WEBPACK_IMPORTED_MODULE_2__.sub8),\\n/* harmony export */   \\"toHex\\": () => (/* reexport safe */ _Utils_js__WEBPACK_IMPORTED_MODULE_2__.toHex),\\n/* harmony export */   \\"toHexByte\\": () => (/* reexport safe */ _Utils_js__WEBPACK_IMPORTED_MODULE_2__.toHexByte),\\n/* harmony export */   \\"toHexLong\\": () => (/* reexport safe */ _Utils_js__WEBPACK_IMPORTED_MODULE_2__.toHexLong),\\n/* harmony export */   \\"toHexWord\\": () => (/* reexport safe */ _Utils_js__WEBPACK_IMPORTED_MODULE_2__.toHexWord),\\n/* harmony export */   \\"word\\": () => (/* reexport safe */ _Utils_js__WEBPACK_IMPORTED_MODULE_2__.word)\\n/* harmony export */ });\\n/* harmony import */ var _Register_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Register.js */ \\"../packages/z80-base/dist/Register.js\\");\\n/* harmony import */ var _RegisterSet_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RegisterSet.js */ \\"../packages/z80-base/dist/RegisterSet.js\\");\\n/* harmony import */ var _Utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Utils.js */ \\"../packages/z80-base/dist/Utils.js\\");\\n/* harmony import */ var _Flag_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Flag.js */ \\"../packages/z80-base/dist/Flag.js\\");\\n/* harmony import */ var _KnownLabels_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./KnownLabels.js */ \\"../packages/z80-base/dist/KnownLabels.js\\");\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n//# sourceMappingURL=index.js.map\\n\\n//# sourceURL=webpack://wptest/../packages/z80-base/dist/index.js?");\n\n/***/ }),\n\n/***/ "../packages/z80-inst/dist/Opcodes.js":\n/*!********************************************!*\\\n  !*** ../packages/z80-inst/dist/Opcodes.js ***!\n  \\********************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\neval("__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\"mnemonicMap\\": () => (/* binding */ mnemonicMap),\\n/* harmony export */   \\"opcodeMap\\": () => (/* binding */ opcodeMap)\\n/* harmony export */ });\\n// Generated by GenerateJson.ts. Do not modify.\\r\\n// nop\\r\\nconst variant_00 = {\\r\\n    \\"mnemonic\\": \\"nop\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        0\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"00\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"No operation is performed.\\",\\r\\n        \\"instruction\\": \\"nop\\"\\r\\n    }\\r\\n};\\r\\n// ld bc,nnnn\\r\\nconst variant_01_nnnn = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"bc\\",\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"bc\\",\\r\\n        \\",\\",\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        1,\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"01\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 10,\\r\\n        \\"without_jump_clock_count\\": 10,\\r\\n        \\"description\\": \\"Loads ** into BC.\\",\\r\\n        \\"instruction\\": \\"ld bc,**\\"\\r\\n    }\\r\\n};\\r\\n// ld (bc),a\\r\\nconst variant_02 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"(bc)\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"bc\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        2\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"02\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"Stores A into the memory location pointed to by BC.\\",\\r\\n        \\"instruction\\": \\"ld (bc),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,nn\\r\\nconst variant_06_nn = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        6,\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"06\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"Loads * into B.\\",\\r\\n        \\"instruction\\": \\"ld b,*\\"\\r\\n    }\\r\\n};\\r\\n// ld a,(bc)\\r\\nconst variant_0A = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"(bc)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"bc\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        10\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"0A\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"Loads the value pointed to by BC into A.\\",\\r\\n        \\"instruction\\": \\"ld a,(bc)\\"\\r\\n    }\\r\\n};\\r\\n// ld (bc)\\r\\nconst variant_0A_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"(bc)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"bc\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        10\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"0A\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"Loads the value pointed to by BC into A.\\",\\r\\n        \\"instruction\\": \\"ld a,(bc)\\"\\r\\n    }\\r\\n};\\r\\n// ld c,nn\\r\\nconst variant_0E_nn = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        14,\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"0E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"Loads * into C.\\",\\r\\n        \\"instruction\\": \\"ld c,*\\"\\r\\n    }\\r\\n};\\r\\n// ld de,nnnn\\r\\nconst variant_11_nnnn = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"de\\",\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"de\\",\\r\\n        \\",\\",\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        17,\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"11\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 10,\\r\\n        \\"without_jump_clock_count\\": 10,\\r\\n        \\"description\\": \\"Loads ** into DE.\\",\\r\\n        \\"instruction\\": \\"ld de,**\\"\\r\\n    }\\r\\n};\\r\\n// ld (de),a\\r\\nconst variant_12 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"(de)\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"de\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        18\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"12\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"Stores A into the memory location pointed to by DE.\\",\\r\\n        \\"instruction\\": \\"ld (de),a\\"\\r\\n    }\\r\\n};\\r\\n// ld d,nn\\r\\nconst variant_16_nn = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        22,\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"16\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"Loads * into D.\\",\\r\\n        \\"instruction\\": \\"ld d,*\\"\\r\\n    }\\r\\n};\\r\\n// ld a,(de)\\r\\nconst variant_1A = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"(de)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"de\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        26\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"1A\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"Loads the value pointed to by DE into A.\\",\\r\\n        \\"instruction\\": \\"ld a,(de)\\"\\r\\n    }\\r\\n};\\r\\n// ld (de)\\r\\nconst variant_1A_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"(de)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"de\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        26\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"1A\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"Loads the value pointed to by DE into A.\\",\\r\\n        \\"instruction\\": \\"ld a,(de)\\"\\r\\n    }\\r\\n};\\r\\n// ld e,nn\\r\\nconst variant_1E_nn = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        30,\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"1E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"Loads * into E.\\",\\r\\n        \\"instruction\\": \\"ld e,*\\"\\r\\n    }\\r\\n};\\r\\n// ld hl,nnnn\\r\\nconst variant_21_nnnn = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"hl\\",\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"hl\\",\\r\\n        \\",\\",\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        33,\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"21\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 10,\\r\\n        \\"without_jump_clock_count\\": 10,\\r\\n        \\"description\\": \\"Loads ** into HL.\\",\\r\\n        \\"instruction\\": \\"ld hl,**\\"\\r\\n    }\\r\\n};\\r\\n// ld (nnnn),hl\\r\\nconst variant_22_nnnn = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"(nnnn)\\",\\r\\n        \\"hl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"nnnn\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"hl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        34,\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"22\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 16,\\r\\n        \\"without_jump_clock_count\\": 16,\\r\\n        \\"description\\": \\"Stores HL into the memory location pointed to by **.\\",\\r\\n        \\"instruction\\": \\"ld (**),hl\\"\\r\\n    }\\r\\n};\\r\\n// ld h,nn\\r\\nconst variant_26_nn = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        38,\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"26\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"Loads * into H.\\",\\r\\n        \\"instruction\\": \\"ld h,*\\"\\r\\n    }\\r\\n};\\r\\n// ld hl,(nnnn)\\r\\nconst variant_2A_nnnn = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"hl\\",\\r\\n        \\"(nnnn)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"hl\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"nnnn\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        42,\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"2A\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 16,\\r\\n        \\"without_jump_clock_count\\": 16,\\r\\n        \\"description\\": \\"Loads the value pointed to by ** into HL.\\",\\r\\n        \\"instruction\\": \\"ld hl,(**)\\"\\r\\n    }\\r\\n};\\r\\n// ld l,nn\\r\\nconst variant_2E_nn = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        46,\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"2E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"Loads * into L.\\",\\r\\n        \\"instruction\\": \\"ld l,*\\"\\r\\n    }\\r\\n};\\r\\n// ld sp,nnnn\\r\\nconst variant_31_nnnn = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"sp\\",\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"sp\\",\\r\\n        \\",\\",\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        49,\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"31\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 10,\\r\\n        \\"without_jump_clock_count\\": 10,\\r\\n        \\"description\\": \\"Loads ** into SP.\\",\\r\\n        \\"instruction\\": \\"ld sp,**\\"\\r\\n    }\\r\\n};\\r\\n// ld (nnnn),a\\r\\nconst variant_32_nnnn = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"(nnnn)\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"nnnn\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        50,\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"32\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 13,\\r\\n        \\"without_jump_clock_count\\": 13,\\r\\n        \\"description\\": \\"Stores A into the memory location pointed to by **.\\",\\r\\n        \\"instruction\\": \\"ld (**),a\\"\\r\\n    }\\r\\n};\\r\\n// ld (hl),nn\\r\\nconst variant_36_nn = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"(hl)\\",\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        54,\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"36\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 10,\\r\\n        \\"without_jump_clock_count\\": 10,\\r\\n        \\"description\\": \\"Loads * into (HL).\\",\\r\\n        \\"instruction\\": \\"ld (hl),*\\"\\r\\n    }\\r\\n};\\r\\n// ld a,(nnnn)\\r\\nconst variant_3A_nnnn = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"(nnnn)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"nnnn\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        58,\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"3A\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 13,\\r\\n        \\"without_jump_clock_count\\": 13,\\r\\n        \\"description\\": \\"Loads the value pointed to by ** into A.\\",\\r\\n        \\"instruction\\": \\"ld a,(**)\\"\\r\\n    }\\r\\n};\\r\\n// ld (nnnn)\\r\\nconst variant_3A_nnnn_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"(nnnn)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"nnnn\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        58,\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"3A\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 13,\\r\\n        \\"without_jump_clock_count\\": 13,\\r\\n        \\"description\\": \\"Loads the value pointed to by ** into A.\\",\\r\\n        \\"instruction\\": \\"ld a,(**)\\"\\r\\n    }\\r\\n};\\r\\n// ld a,nn\\r\\nconst variant_3E_nn = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        62,\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"3E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"Loads * into A.\\",\\r\\n        \\"instruction\\": \\"ld a,*\\"\\r\\n    }\\r\\n};\\r\\n// ld nn\\r\\nconst variant_3E_nn_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        62,\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"3E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"Loads * into A.\\",\\r\\n        \\"instruction\\": \\"ld a,*\\"\\r\\n    }\\r\\n};\\r\\n// ld b,b\\r\\nconst variant_40 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        64\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"40\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of B are loaded into B.\\",\\r\\n        \\"instruction\\": \\"ld b,b\\"\\r\\n    }\\r\\n};\\r\\n// ld b,c\\r\\nconst variant_41 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        65\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"41\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of C are loaded into B.\\",\\r\\n        \\"instruction\\": \\"ld b,c\\"\\r\\n    }\\r\\n};\\r\\n// ld b,d\\r\\nconst variant_42 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        66\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"42\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of D are loaded into B.\\",\\r\\n        \\"instruction\\": \\"ld b,d\\"\\r\\n    }\\r\\n};\\r\\n// ld b,e\\r\\nconst variant_43 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        67\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"43\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of E are loaded into B.\\",\\r\\n        \\"instruction\\": \\"ld b,e\\"\\r\\n    }\\r\\n};\\r\\n// ld b,h\\r\\nconst variant_44 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        68\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"44\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of H are loaded into B.\\",\\r\\n        \\"instruction\\": \\"ld b,h\\"\\r\\n    }\\r\\n};\\r\\n// ld b,l\\r\\nconst variant_45 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        69\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"45\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of L are loaded into B.\\",\\r\\n        \\"instruction\\": \\"ld b,l\\"\\r\\n    }\\r\\n};\\r\\n// ld b,(hl)\\r\\nconst variant_46 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        70\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"46\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"The contents of (HL) are loaded into B.\\",\\r\\n        \\"instruction\\": \\"ld b,(hl)\\"\\r\\n    }\\r\\n};\\r\\n// ld b,a\\r\\nconst variant_47 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        71\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"47\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of A are loaded into B.\\",\\r\\n        \\"instruction\\": \\"ld b,a\\"\\r\\n    }\\r\\n};\\r\\n// ld c,b\\r\\nconst variant_48 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        72\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"48\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of B are loaded into C.\\",\\r\\n        \\"instruction\\": \\"ld c,b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,c\\r\\nconst variant_49 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        73\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"49\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of C are loaded into C.\\",\\r\\n        \\"instruction\\": \\"ld c,c\\"\\r\\n    }\\r\\n};\\r\\n// ld c,d\\r\\nconst variant_4A = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        74\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"4A\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of D are loaded into C.\\",\\r\\n        \\"instruction\\": \\"ld c,d\\"\\r\\n    }\\r\\n};\\r\\n// ld c,e\\r\\nconst variant_4B = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        75\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"4B\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of E are loaded into C.\\",\\r\\n        \\"instruction\\": \\"ld c,e\\"\\r\\n    }\\r\\n};\\r\\n// ld c,h\\r\\nconst variant_4C = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        76\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"4C\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of H are loaded into C.\\",\\r\\n        \\"instruction\\": \\"ld c,h\\"\\r\\n    }\\r\\n};\\r\\n// ld c,l\\r\\nconst variant_4D = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        77\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"4D\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of L are loaded into C.\\",\\r\\n        \\"instruction\\": \\"ld c,l\\"\\r\\n    }\\r\\n};\\r\\n// ld c,(hl)\\r\\nconst variant_4E = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        78\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"4E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"The contents of (HL) are loaded into C.\\",\\r\\n        \\"instruction\\": \\"ld c,(hl)\\"\\r\\n    }\\r\\n};\\r\\n// ld c,a\\r\\nconst variant_4F = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        79\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"4F\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of A are loaded into C.\\",\\r\\n        \\"instruction\\": \\"ld c,a\\"\\r\\n    }\\r\\n};\\r\\n// ld d,b\\r\\nconst variant_50 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        80\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"50\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of B are loaded into D.\\",\\r\\n        \\"instruction\\": \\"ld d,b\\"\\r\\n    }\\r\\n};\\r\\n// ld d,c\\r\\nconst variant_51 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        81\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"51\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of C are loaded into D.\\",\\r\\n        \\"instruction\\": \\"ld d,c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,d\\r\\nconst variant_52 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        82\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"52\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of D are loaded into D.\\",\\r\\n        \\"instruction\\": \\"ld d,d\\"\\r\\n    }\\r\\n};\\r\\n// ld d,e\\r\\nconst variant_53 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        83\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"53\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of E are loaded into D.\\",\\r\\n        \\"instruction\\": \\"ld d,e\\"\\r\\n    }\\r\\n};\\r\\n// ld d,h\\r\\nconst variant_54 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        84\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"54\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of H are loaded into D.\\",\\r\\n        \\"instruction\\": \\"ld d,h\\"\\r\\n    }\\r\\n};\\r\\n// ld d,l\\r\\nconst variant_55 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        85\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"55\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of L are loaded into D.\\",\\r\\n        \\"instruction\\": \\"ld d,l\\"\\r\\n    }\\r\\n};\\r\\n// ld d,(hl)\\r\\nconst variant_56 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        86\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"56\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"The contents of (HL) are loaded into D.\\",\\r\\n        \\"instruction\\": \\"ld d,(hl)\\"\\r\\n    }\\r\\n};\\r\\n// ld d,a\\r\\nconst variant_57 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        87\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"57\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of A are loaded into D.\\",\\r\\n        \\"instruction\\": \\"ld d,a\\"\\r\\n    }\\r\\n};\\r\\n// ld e,b\\r\\nconst variant_58 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        88\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"58\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of B are loaded into E.\\",\\r\\n        \\"instruction\\": \\"ld e,b\\"\\r\\n    }\\r\\n};\\r\\n// ld e,c\\r\\nconst variant_59 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        89\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"59\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of C are loaded into E.\\",\\r\\n        \\"instruction\\": \\"ld e,c\\"\\r\\n    }\\r\\n};\\r\\n// ld e,d\\r\\nconst variant_5A = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        90\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"5A\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of D are loaded into E.\\",\\r\\n        \\"instruction\\": \\"ld e,d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,e\\r\\nconst variant_5B = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        91\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"5B\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of E are loaded into E.\\",\\r\\n        \\"instruction\\": \\"ld e,e\\"\\r\\n    }\\r\\n};\\r\\n// ld e,h\\r\\nconst variant_5C = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        92\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"5C\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of H are loaded into E.\\",\\r\\n        \\"instruction\\": \\"ld e,h\\"\\r\\n    }\\r\\n};\\r\\n// ld e,l\\r\\nconst variant_5D = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        93\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"5D\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of L are loaded into E.\\",\\r\\n        \\"instruction\\": \\"ld e,l\\"\\r\\n    }\\r\\n};\\r\\n// ld e,(hl)\\r\\nconst variant_5E = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        94\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"5E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"The contents of (HL) are loaded into E.\\",\\r\\n        \\"instruction\\": \\"ld e,(hl)\\"\\r\\n    }\\r\\n};\\r\\n// ld e,a\\r\\nconst variant_5F = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        95\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"5F\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of A are loaded into E.\\",\\r\\n        \\"instruction\\": \\"ld e,a\\"\\r\\n    }\\r\\n};\\r\\n// ld h,b\\r\\nconst variant_60 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        96\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"60\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of B are loaded into H.\\",\\r\\n        \\"instruction\\": \\"ld h,b\\"\\r\\n    }\\r\\n};\\r\\n// ld h,c\\r\\nconst variant_61 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        97\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"61\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of C are loaded into H.\\",\\r\\n        \\"instruction\\": \\"ld h,c\\"\\r\\n    }\\r\\n};\\r\\n// ld h,d\\r\\nconst variant_62 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        98\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"62\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of D are loaded into H.\\",\\r\\n        \\"instruction\\": \\"ld h,d\\"\\r\\n    }\\r\\n};\\r\\n// ld h,e\\r\\nconst variant_63 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        99\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"63\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of E are loaded into H.\\",\\r\\n        \\"instruction\\": \\"ld h,e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,h\\r\\nconst variant_64 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        100\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"64\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of H are loaded into H.\\",\\r\\n        \\"instruction\\": \\"ld h,h\\"\\r\\n    }\\r\\n};\\r\\n// ld h,l\\r\\nconst variant_65 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        101\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"65\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of L are loaded into H.\\",\\r\\n        \\"instruction\\": \\"ld h,l\\"\\r\\n    }\\r\\n};\\r\\n// ld h,(hl)\\r\\nconst variant_66 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        102\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"66\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"The contents of (HL) are loaded into H.\\",\\r\\n        \\"instruction\\": \\"ld h,(hl)\\"\\r\\n    }\\r\\n};\\r\\n// ld h,a\\r\\nconst variant_67 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        103\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"67\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of A are loaded into H.\\",\\r\\n        \\"instruction\\": \\"ld h,a\\"\\r\\n    }\\r\\n};\\r\\n// ld l,b\\r\\nconst variant_68 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        104\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"68\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of B are loaded into L.\\",\\r\\n        \\"instruction\\": \\"ld l,b\\"\\r\\n    }\\r\\n};\\r\\n// ld l,c\\r\\nconst variant_69 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        105\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"69\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of C are loaded into L.\\",\\r\\n        \\"instruction\\": \\"ld l,c\\"\\r\\n    }\\r\\n};\\r\\n// ld l,d\\r\\nconst variant_6A = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        106\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"6A\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of D are loaded into L.\\",\\r\\n        \\"instruction\\": \\"ld l,d\\"\\r\\n    }\\r\\n};\\r\\n// ld l,e\\r\\nconst variant_6B = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        107\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"6B\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of E are loaded into L.\\",\\r\\n        \\"instruction\\": \\"ld l,e\\"\\r\\n    }\\r\\n};\\r\\n// ld l,h\\r\\nconst variant_6C = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        108\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"6C\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of H are loaded into L.\\",\\r\\n        \\"instruction\\": \\"ld l,h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,l\\r\\nconst variant_6D = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        109\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"6D\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of L are loaded into L.\\",\\r\\n        \\"instruction\\": \\"ld l,l\\"\\r\\n    }\\r\\n};\\r\\n// ld l,(hl)\\r\\nconst variant_6E = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        110\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"6E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"The contents of (HL) are loaded into L.\\",\\r\\n        \\"instruction\\": \\"ld l,(hl)\\"\\r\\n    }\\r\\n};\\r\\n// ld l,a\\r\\nconst variant_6F = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        111\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"6F\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of A are loaded into L.\\",\\r\\n        \\"instruction\\": \\"ld l,a\\"\\r\\n    }\\r\\n};\\r\\n// ld (hl),b\\r\\nconst variant_70 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"(hl)\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        112\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"70\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"The contents of B are loaded into (HL).\\",\\r\\n        \\"instruction\\": \\"ld (hl),b\\"\\r\\n    }\\r\\n};\\r\\n// ld (hl),c\\r\\nconst variant_71 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"(hl)\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        113\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"71\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"The contents of C are loaded into (HL).\\",\\r\\n        \\"instruction\\": \\"ld (hl),c\\"\\r\\n    }\\r\\n};\\r\\n// ld (hl),d\\r\\nconst variant_72 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"(hl)\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        114\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"72\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"The contents of D are loaded into (HL).\\",\\r\\n        \\"instruction\\": \\"ld (hl),d\\"\\r\\n    }\\r\\n};\\r\\n// ld (hl),e\\r\\nconst variant_73 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"(hl)\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        115\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"73\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"The contents of E are loaded into (HL).\\",\\r\\n        \\"instruction\\": \\"ld (hl),e\\"\\r\\n    }\\r\\n};\\r\\n// ld (hl),h\\r\\nconst variant_74 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"(hl)\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        116\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"74\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"The contents of H are loaded into (HL).\\",\\r\\n        \\"instruction\\": \\"ld (hl),h\\"\\r\\n    }\\r\\n};\\r\\n// ld (hl),l\\r\\nconst variant_75 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"(hl)\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        117\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"75\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"The contents of L are loaded into (HL).\\",\\r\\n        \\"instruction\\": \\"ld (hl),l\\"\\r\\n    }\\r\\n};\\r\\n// ld (hl),a\\r\\nconst variant_77 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"(hl)\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        119\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"77\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"The contents of A are loaded into (HL).\\",\\r\\n        \\"instruction\\": \\"ld (hl),a\\"\\r\\n    }\\r\\n};\\r\\n// ld a,b\\r\\nconst variant_78 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        120\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"78\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of B are loaded into A.\\",\\r\\n        \\"instruction\\": \\"ld a,b\\"\\r\\n    }\\r\\n};\\r\\n// ld b\\r\\nconst variant_78_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        120\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"78\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of B are loaded into A.\\",\\r\\n        \\"instruction\\": \\"ld a,b\\"\\r\\n    }\\r\\n};\\r\\n// ld a,c\\r\\nconst variant_79 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        121\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"79\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of C are loaded into A.\\",\\r\\n        \\"instruction\\": \\"ld a,c\\"\\r\\n    }\\r\\n};\\r\\n// ld c\\r\\nconst variant_79_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        121\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"79\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of C are loaded into A.\\",\\r\\n        \\"instruction\\": \\"ld a,c\\"\\r\\n    }\\r\\n};\\r\\n// ld a,d\\r\\nconst variant_7A = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        122\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"7A\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of D are loaded into A.\\",\\r\\n        \\"instruction\\": \\"ld a,d\\"\\r\\n    }\\r\\n};\\r\\n// ld d\\r\\nconst variant_7A_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        122\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"7A\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of D are loaded into A.\\",\\r\\n        \\"instruction\\": \\"ld a,d\\"\\r\\n    }\\r\\n};\\r\\n// ld a,e\\r\\nconst variant_7B = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        123\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"7B\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of E are loaded into A.\\",\\r\\n        \\"instruction\\": \\"ld a,e\\"\\r\\n    }\\r\\n};\\r\\n// ld e\\r\\nconst variant_7B_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        123\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"7B\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of E are loaded into A.\\",\\r\\n        \\"instruction\\": \\"ld a,e\\"\\r\\n    }\\r\\n};\\r\\n// ld a,h\\r\\nconst variant_7C = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        124\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"7C\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of H are loaded into A.\\",\\r\\n        \\"instruction\\": \\"ld a,h\\"\\r\\n    }\\r\\n};\\r\\n// ld h\\r\\nconst variant_7C_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        124\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"7C\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of H are loaded into A.\\",\\r\\n        \\"instruction\\": \\"ld a,h\\"\\r\\n    }\\r\\n};\\r\\n// ld a,l\\r\\nconst variant_7D = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        125\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"7D\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of L are loaded into A.\\",\\r\\n        \\"instruction\\": \\"ld a,l\\"\\r\\n    }\\r\\n};\\r\\n// ld l\\r\\nconst variant_7D_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        125\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"7D\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of L are loaded into A.\\",\\r\\n        \\"instruction\\": \\"ld a,l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,(hl)\\r\\nconst variant_7E = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        126\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"7E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"The contents of (HL) are loaded into A.\\",\\r\\n        \\"instruction\\": \\"ld a,(hl)\\"\\r\\n    }\\r\\n};\\r\\n// ld (hl)\\r\\nconst variant_7E_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        126\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"7E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"The contents of (HL) are loaded into A.\\",\\r\\n        \\"instruction\\": \\"ld a,(hl)\\"\\r\\n    }\\r\\n};\\r\\n// ld a,a\\r\\nconst variant_7F = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        127\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"7F\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of A are loaded into A.\\",\\r\\n        \\"instruction\\": \\"ld a,a\\"\\r\\n    }\\r\\n};\\r\\n// ld a\\r\\nconst variant_7F_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        127\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"7F\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of A are loaded into A.\\",\\r\\n        \\"instruction\\": \\"ld a,a\\"\\r\\n    }\\r\\n};\\r\\n// ld ix,nnnn\\r\\nconst variant_DD_21_nnnn = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"ix\\",\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ix\\",\\r\\n        \\",\\",\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        33,\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD21\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 14,\\r\\n        \\"without_jump_clock_count\\": 14,\\r\\n        \\"description\\": \\"Loads ** into register IX.\\",\\r\\n        \\"instruction\\": \\"ld ix,**\\"\\r\\n    }\\r\\n};\\r\\n// ld (nnnn),ix\\r\\nconst variant_DD_22_nnnn = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"(nnnn)\\",\\r\\n        \\"ix\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"nnnn\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"ix\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        34,\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD22\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Stores IX into the memory location pointed to by **.\\",\\r\\n        \\"instruction\\": \\"ld (**),ix\\"\\r\\n    }\\r\\n};\\r\\n// ld ixh,nn\\r\\nconst variant_DD_26_nn = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"ixh\\",\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ixh\\",\\r\\n        \\",\\",\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        38,\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD26\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 11,\\r\\n        \\"without_jump_clock_count\\": 11,\\r\\n        \\"description\\": \\"Loads * into IXH.\\",\\r\\n        \\"instruction\\": \\"ld ixh,*\\"\\r\\n    }\\r\\n};\\r\\n// ld ix,(nnnn)\\r\\nconst variant_DD_2A_nnnn = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"ix\\",\\r\\n        \\"(nnnn)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ix\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"nnnn\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        42,\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD2A\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Loads the value pointed to by ** into IX.\\",\\r\\n        \\"instruction\\": \\"ld ix,(**)\\"\\r\\n    }\\r\\n};\\r\\n// ld ixl,nn\\r\\nconst variant_DD_2E_nn = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"ixl\\",\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ixl\\",\\r\\n        \\",\\",\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        46,\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD2E\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 11,\\r\\n        \\"without_jump_clock_count\\": 11,\\r\\n        \\"description\\": \\"Loads * into IXL.\\",\\r\\n        \\"instruction\\": \\"ld ixl,*\\"\\r\\n    }\\r\\n};\\r\\n// ld (ix+dd),nn\\r\\nconst variant_DD_36_dd_nn = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"(ix+dd)\\",\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        54,\\r\\n        \\"dd\\",\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD36\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Stores * to the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"ld (ix+*),*\\"\\r\\n    }\\r\\n};\\r\\n// ld b,ixh\\r\\nconst variant_DD_44 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        68\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD44\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of IXH are loaded into B.\\",\\r\\n        \\"instruction\\": \\"ld b,ixh\\"\\r\\n    }\\r\\n};\\r\\n// ld b,ixl\\r\\nconst variant_DD_45 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        69\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD45\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of IXL are loaded into B.\\",\\r\\n        \\"instruction\\": \\"ld b,ixl\\"\\r\\n    }\\r\\n};\\r\\n// ld b,(ix+dd)\\r\\nconst variant_DD_46_dd = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        70,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD46\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Loads the value pointed to by IX plus * into B.\\",\\r\\n        \\"instruction\\": \\"ld b,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// ld c,ixh\\r\\nconst variant_DD_4C = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        76\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD4C\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of IXH are loaded into C.\\",\\r\\n        \\"instruction\\": \\"ld c,ixh\\"\\r\\n    }\\r\\n};\\r\\n// ld c,ixl\\r\\nconst variant_DD_4D = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        77\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD4D\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of IXL are loaded into C.\\",\\r\\n        \\"instruction\\": \\"ld c,ixl\\"\\r\\n    }\\r\\n};\\r\\n// ld c,(ix+dd)\\r\\nconst variant_DD_4E_dd = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        78,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD4E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Loads the value pointed to by IX plus * into C.\\",\\r\\n        \\"instruction\\": \\"ld c,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// ld d,ixh\\r\\nconst variant_DD_54 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        84\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD54\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of IXH are loaded into D.\\",\\r\\n        \\"instruction\\": \\"ld d,ixh\\"\\r\\n    }\\r\\n};\\r\\n// ld d,ixl\\r\\nconst variant_DD_55 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        85\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD55\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of IXL are loaded into D.\\",\\r\\n        \\"instruction\\": \\"ld d,ixl\\"\\r\\n    }\\r\\n};\\r\\n// ld d,(ix+dd)\\r\\nconst variant_DD_56_dd = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        86,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD56\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Loads the value pointed to by IX plus * into D.\\",\\r\\n        \\"instruction\\": \\"ld d,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// ld e,ixh\\r\\nconst variant_DD_5C = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        92\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD5C\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of IXH are loaded into E.\\",\\r\\n        \\"instruction\\": \\"ld e,ixh\\"\\r\\n    }\\r\\n};\\r\\n// ld e,ixl\\r\\nconst variant_DD_5D = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        93\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD5D\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of IXL are loaded into E.\\",\\r\\n        \\"instruction\\": \\"ld e,ixl\\"\\r\\n    }\\r\\n};\\r\\n// ld e,(ix+dd)\\r\\nconst variant_DD_5E_dd = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        94,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD5E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Loads the value pointed to by IX plus * into E.\\",\\r\\n        \\"instruction\\": \\"ld e,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// ld ixh,b\\r\\nconst variant_DD_60 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"ixh\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ixh\\",\\r\\n        \\",\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        96\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD60\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of B are loaded into IXH.\\",\\r\\n        \\"instruction\\": \\"ld ixh,b\\"\\r\\n    }\\r\\n};\\r\\n// ld ixh,c\\r\\nconst variant_DD_61 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"ixh\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ixh\\",\\r\\n        \\",\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        97\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD61\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of C are loaded into IXH.\\",\\r\\n        \\"instruction\\": \\"ld ixh,c\\"\\r\\n    }\\r\\n};\\r\\n// ld ixh,d\\r\\nconst variant_DD_62 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"ixh\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ixh\\",\\r\\n        \\",\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        98\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD62\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of D are loaded into IXH.\\",\\r\\n        \\"instruction\\": \\"ld ixh,d\\"\\r\\n    }\\r\\n};\\r\\n// ld ixh,e\\r\\nconst variant_DD_63 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"ixh\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ixh\\",\\r\\n        \\",\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        99\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD63\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of E are loaded into IXH.\\",\\r\\n        \\"instruction\\": \\"ld ixh,e\\"\\r\\n    }\\r\\n};\\r\\n// ld ixh,ixh\\r\\nconst variant_DD_64 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"ixh\\",\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ixh\\",\\r\\n        \\",\\",\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        100\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD64\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of IXH are loaded into IXH.\\",\\r\\n        \\"instruction\\": \\"ld ixh,ixh\\"\\r\\n    }\\r\\n};\\r\\n// ld ixh,ixl\\r\\nconst variant_DD_65 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"ixh\\",\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ixh\\",\\r\\n        \\",\\",\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        101\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD65\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of IXL are loaded into IXH.\\",\\r\\n        \\"instruction\\": \\"ld ixh,ixl\\"\\r\\n    }\\r\\n};\\r\\n// ld h,(ix+dd)\\r\\nconst variant_DD_66_dd = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        102,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD66\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Loads the value pointed to by IX plus * into H.\\",\\r\\n        \\"instruction\\": \\"ld h,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// ld ixh,a\\r\\nconst variant_DD_67 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"ixh\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ixh\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        103\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD67\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of A are loaded into IXH.\\",\\r\\n        \\"instruction\\": \\"ld ixh,a\\"\\r\\n    }\\r\\n};\\r\\n// ld ixl,b\\r\\nconst variant_DD_68 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"ixl\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ixl\\",\\r\\n        \\",\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        104\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD68\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of B are loaded into IXL.\\",\\r\\n        \\"instruction\\": \\"ld ixl,b\\"\\r\\n    }\\r\\n};\\r\\n// ld ixl,c\\r\\nconst variant_DD_69 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"ixl\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ixl\\",\\r\\n        \\",\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        105\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD69\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of C are loaded into IXL.\\",\\r\\n        \\"instruction\\": \\"ld ixl,c\\"\\r\\n    }\\r\\n};\\r\\n// ld ixl,d\\r\\nconst variant_DD_6A = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"ixl\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ixl\\",\\r\\n        \\",\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        106\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD6A\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of D are loaded into IXL.\\",\\r\\n        \\"instruction\\": \\"ld ixl,d\\"\\r\\n    }\\r\\n};\\r\\n// ld ixl,e\\r\\nconst variant_DD_6B = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"ixl\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ixl\\",\\r\\n        \\",\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        107\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD6B\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of E are loaded into IXL.\\",\\r\\n        \\"instruction\\": \\"ld ixl,e\\"\\r\\n    }\\r\\n};\\r\\n// ld ixl,ixh\\r\\nconst variant_DD_6C = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"ixl\\",\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ixl\\",\\r\\n        \\",\\",\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        108\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD6C\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of IXH are loaded into IXL.\\",\\r\\n        \\"instruction\\": \\"ld ixl,ixh\\"\\r\\n    }\\r\\n};\\r\\n// ld ixl,ixl\\r\\nconst variant_DD_6D = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"ixl\\",\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ixl\\",\\r\\n        \\",\\",\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        109\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD6D\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of IXL are loaded into IXL.\\",\\r\\n        \\"instruction\\": \\"ld ixl,ixl\\"\\r\\n    }\\r\\n};\\r\\n// ld l,(ix+dd)\\r\\nconst variant_DD_6E_dd = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        110,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD6E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Loads the value pointed to by IX plus * into L.\\",\\r\\n        \\"instruction\\": \\"ld l,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// ld ixl,a\\r\\nconst variant_DD_6F = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"ixl\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ixl\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        111\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD6F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of A are loaded into IXL.\\",\\r\\n        \\"instruction\\": \\"ld ixl,a\\"\\r\\n    }\\r\\n};\\r\\n// ld (ix+dd),b\\r\\nconst variant_DD_70_dd = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"(ix+dd)\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        112,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD70\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Stores B to the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"ld (ix+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld (ix+dd),c\\r\\nconst variant_DD_71_dd = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"(ix+dd)\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        113,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD71\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Stores C to the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"ld (ix+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld (ix+dd),d\\r\\nconst variant_DD_72_dd = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"(ix+dd)\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        114,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD72\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Stores D to the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"ld (ix+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld (ix+dd),e\\r\\nconst variant_DD_73_dd = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"(ix+dd)\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        115,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD73\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Stores E to the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"ld (ix+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld (ix+dd),h\\r\\nconst variant_DD_74_dd = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"(ix+dd)\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        116,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD74\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Stores H to the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"ld (ix+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld (ix+dd),l\\r\\nconst variant_DD_75_dd = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"(ix+dd)\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        117,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD75\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Stores L to the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"ld (ix+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld (ix+dd),a\\r\\nconst variant_DD_77_dd = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"(ix+dd)\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        119,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD77\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Stores A to the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"ld (ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld a,ixh\\r\\nconst variant_DD_7C = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        124\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD7C\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of IXH are loaded into A.\\",\\r\\n        \\"instruction\\": \\"ld a,ixh\\"\\r\\n    }\\r\\n};\\r\\n// ld ixh\\r\\nconst variant_DD_7C_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        124\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD7C\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of IXH are loaded into A.\\",\\r\\n        \\"instruction\\": \\"ld a,ixh\\"\\r\\n    }\\r\\n};\\r\\n// ld a,ixl\\r\\nconst variant_DD_7D = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        125\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD7D\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of IXL are loaded into A.\\",\\r\\n        \\"instruction\\": \\"ld a,ixl\\"\\r\\n    }\\r\\n};\\r\\n// ld ixl\\r\\nconst variant_DD_7D_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        125\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD7D\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of IXL are loaded into A.\\",\\r\\n        \\"instruction\\": \\"ld a,ixl\\"\\r\\n    }\\r\\n};\\r\\n// ld a,(ix+dd)\\r\\nconst variant_DD_7E_dd = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        126,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD7E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Loads the value pointed to by IX plus * into A.\\",\\r\\n        \\"instruction\\": \\"ld a,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// ld (ix+dd)\\r\\nconst variant_DD_7E_dd_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        126,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD7E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Loads the value pointed to by IX plus * into A.\\",\\r\\n        \\"instruction\\": \\"ld a,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// ld b,rlc (ix+dd)\\r\\nconst variant_DD_CB_dd_00 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"rlc (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"rlc\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        0\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**00\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0. The result is then stored in B.\\",\\r\\n        \\"instruction\\": \\"rlc (ix+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,rlc (ix+dd)\\r\\nconst variant_DD_CB_dd_01 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"rlc (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"rlc\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        1\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**01\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0. The result is then stored in C.\\",\\r\\n        \\"instruction\\": \\"rlc (ix+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,rlc (ix+dd)\\r\\nconst variant_DD_CB_dd_02 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"rlc (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"rlc\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        2\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**02\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0. The result is then stored in D.\\",\\r\\n        \\"instruction\\": \\"rlc (ix+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,rlc (ix+dd)\\r\\nconst variant_DD_CB_dd_03 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"rlc (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"rlc\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        3\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**03\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0. The result is then stored in E.\\",\\r\\n        \\"instruction\\": \\"rlc (ix+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,rlc (ix+dd)\\r\\nconst variant_DD_CB_dd_04 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"rlc (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"rlc\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        4\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**04\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0. The result is then stored in H.\\",\\r\\n        \\"instruction\\": \\"rlc (ix+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,rlc (ix+dd)\\r\\nconst variant_DD_CB_dd_05 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"rlc (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"rlc\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        5\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**05\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0. The result is then stored in L.\\",\\r\\n        \\"instruction\\": \\"rlc (ix+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,rlc (ix+dd)\\r\\nconst variant_DD_CB_dd_07 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"rlc (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"rlc\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        7\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**07\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0. The result is then stored in A.\\",\\r\\n        \\"instruction\\": \\"rlc (ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld rlc (ix+dd)\\r\\nconst variant_DD_CB_dd_07_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"rlc (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"rlc\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        7\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**07\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0. The result is then stored in A.\\",\\r\\n        \\"instruction\\": \\"rlc (ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,rrc (ix+dd)\\r\\nconst variant_DD_CB_dd_08 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"rrc (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"rrc\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        8\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**08\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7. The result is then stored in B.\\",\\r\\n        \\"instruction\\": \\"rrc (ix+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,rrc (ix+dd)\\r\\nconst variant_DD_CB_dd_09 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"rrc (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"rrc\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        9\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**09\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7. The result is then stored in C.\\",\\r\\n        \\"instruction\\": \\"rrc (ix+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,rrc (ix+dd)\\r\\nconst variant_DD_CB_dd_0A = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"rrc (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"rrc\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        10\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**0A\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7. The result is then stored in D.\\",\\r\\n        \\"instruction\\": \\"rrc (ix+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,rrc (ix+dd)\\r\\nconst variant_DD_CB_dd_0B = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"rrc (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"rrc\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        11\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**0B\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7. The result is then stored in E.\\",\\r\\n        \\"instruction\\": \\"rrc (ix+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,rrc (ix+dd)\\r\\nconst variant_DD_CB_dd_0C = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"rrc (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"rrc\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        12\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**0C\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7. The result is then stored in H.\\",\\r\\n        \\"instruction\\": \\"rrc (ix+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,rrc (ix+dd)\\r\\nconst variant_DD_CB_dd_0D = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"rrc (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"rrc\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        13\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**0D\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7. The result is then stored in L.\\",\\r\\n        \\"instruction\\": \\"rrc (ix+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,rrc (ix+dd)\\r\\nconst variant_DD_CB_dd_0F = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"rrc (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"rrc\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        15\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**0F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7. The result is then stored in A.\\",\\r\\n        \\"instruction\\": \\"rrc (ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld rrc (ix+dd)\\r\\nconst variant_DD_CB_dd_0F_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"rrc (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"rrc\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        15\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**0F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7. The result is then stored in A.\\",\\r\\n        \\"instruction\\": \\"rrc (ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,rl (ix+dd)\\r\\nconst variant_DD_CB_dd_10 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"rl (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"rl\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        16\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**10\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0. The result is then stored in B.\\",\\r\\n        \\"instruction\\": \\"rl (ix+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,rl (ix+dd)\\r\\nconst variant_DD_CB_dd_11 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"rl (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"rl\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        17\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**11\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0. The result is then stored in C.\\",\\r\\n        \\"instruction\\": \\"rl (ix+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,rl (ix+dd)\\r\\nconst variant_DD_CB_dd_12 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"rl (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"rl\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        18\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**12\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0. The result is then stored in D.\\",\\r\\n        \\"instruction\\": \\"rl (ix+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,rl (ix+dd)\\r\\nconst variant_DD_CB_dd_13 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"rl (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"rl\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        19\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**13\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0. The result is then stored in E.\\",\\r\\n        \\"instruction\\": \\"rl (ix+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,rl (ix+dd)\\r\\nconst variant_DD_CB_dd_14 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"rl (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"rl\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        20\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**14\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0. The result is then stored in H.\\",\\r\\n        \\"instruction\\": \\"rl (ix+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,rl (ix+dd)\\r\\nconst variant_DD_CB_dd_15 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"rl (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"rl\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        21\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**15\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0. The result is then stored in L.\\",\\r\\n        \\"instruction\\": \\"rl (ix+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,rl (ix+dd)\\r\\nconst variant_DD_CB_dd_17 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"rl (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"rl\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        23\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**17\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0. The result is then stored in A.\\",\\r\\n        \\"instruction\\": \\"rl (ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld rl (ix+dd)\\r\\nconst variant_DD_CB_dd_17_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"rl (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"rl\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        23\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**17\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0. The result is then stored in A.\\",\\r\\n        \\"instruction\\": \\"rl (ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,rr (ix+dd)\\r\\nconst variant_DD_CB_dd_18 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"rr (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"rr\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        24\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**18\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7. The result is then stored in B.\\",\\r\\n        \\"instruction\\": \\"rr (ix+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,rr (ix+dd)\\r\\nconst variant_DD_CB_dd_19 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"rr (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"rr\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        25\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**19\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7. The result is then stored in C.\\",\\r\\n        \\"instruction\\": \\"rr (ix+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,rr (ix+dd)\\r\\nconst variant_DD_CB_dd_1A = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"rr (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"rr\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        26\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**1A\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7. The result is then stored in D.\\",\\r\\n        \\"instruction\\": \\"rr (ix+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,rr (ix+dd)\\r\\nconst variant_DD_CB_dd_1B = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"rr (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"rr\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        27\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**1B\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7. The result is then stored in E.\\",\\r\\n        \\"instruction\\": \\"rr (ix+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,rr (ix+dd)\\r\\nconst variant_DD_CB_dd_1C = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"rr (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"rr\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        28\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**1C\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7. The result is then stored in H.\\",\\r\\n        \\"instruction\\": \\"rr (ix+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,rr (ix+dd)\\r\\nconst variant_DD_CB_dd_1D = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"rr (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"rr\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        29\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**1D\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7. The result is then stored in L.\\",\\r\\n        \\"instruction\\": \\"rr (ix+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,rr (ix+dd)\\r\\nconst variant_DD_CB_dd_1F = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"rr (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"rr\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        31\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**1F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7. The result is then stored in A.\\",\\r\\n        \\"instruction\\": \\"rr (ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld rr (ix+dd)\\r\\nconst variant_DD_CB_dd_1F_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"rr (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"rr\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        31\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**1F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7. The result is then stored in A.\\",\\r\\n        \\"instruction\\": \\"rr (ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,sla (ix+dd)\\r\\nconst variant_DD_CB_dd_20 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"sla (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"sla\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        32\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**20\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are shifted left one bit position. The contents of bit 7 are copied to the carry flag and a zero is put into bit 0. The result is then stored in B.\\",\\r\\n        \\"instruction\\": \\"sla (ix+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,sla (ix+dd)\\r\\nconst variant_DD_CB_dd_21 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"sla (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"sla\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        33\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**21\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are shifted left one bit position. The contents of bit 7 are copied to the carry flag and a zero is put into bit 0. The result is then stored in C.\\",\\r\\n        \\"instruction\\": \\"sla (ix+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,sla (ix+dd)\\r\\nconst variant_DD_CB_dd_22 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"sla (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"sla\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        34\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**22\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are shifted left one bit position. The contents of bit 7 are copied to the carry flag and a zero is put into bit 0. The result is then stored in D.\\",\\r\\n        \\"instruction\\": \\"sla (ix+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,sla (ix+dd)\\r\\nconst variant_DD_CB_dd_23 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"sla (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"sla\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        35\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**23\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are shifted left one bit position. The contents of bit 7 are copied to the carry flag and a zero is put into bit 0. The result is then stored in E.\\",\\r\\n        \\"instruction\\": \\"sla (ix+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,sla (ix+dd)\\r\\nconst variant_DD_CB_dd_24 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"sla (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"sla\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        36\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**24\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are shifted left one bit position. The contents of bit 7 are copied to the carry flag and a zero is put into bit 0. The result is then stored in H.\\",\\r\\n        \\"instruction\\": \\"sla (ix+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,sla (ix+dd)\\r\\nconst variant_DD_CB_dd_25 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"sla (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"sla\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        37\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**25\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are shifted left one bit position. The contents of bit 7 are copied to the carry flag and a zero is put into bit 0. The result is then stored in L.\\",\\r\\n        \\"instruction\\": \\"sla (ix+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,sla (ix+dd)\\r\\nconst variant_DD_CB_dd_27 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"sla (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"sla\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        39\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**27\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are shifted left one bit position. The contents of bit 7 are copied to the carry flag and a zero is put into bit 0. The result is then stored in A.\\",\\r\\n        \\"instruction\\": \\"sla (ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld sla (ix+dd)\\r\\nconst variant_DD_CB_dd_27_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"sla (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"sla\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        39\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**27\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are shifted left one bit position. The contents of bit 7 are copied to the carry flag and a zero is put into bit 0. The result is then stored in A.\\",\\r\\n        \\"instruction\\": \\"sla (ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,sra (ix+dd)\\r\\nconst variant_DD_CB_dd_28 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"sra (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"sra\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        40\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**28\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are shifted right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of bit 7 are unchanged. The result is then stored in B.\\",\\r\\n        \\"instruction\\": \\"sra (ix+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,sra (ix+dd)\\r\\nconst variant_DD_CB_dd_29 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"sra (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"sra\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        41\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**29\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are shifted right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of bit 7 are unchanged. The result is then stored in C.\\",\\r\\n        \\"instruction\\": \\"sra (ix+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,sra (ix+dd)\\r\\nconst variant_DD_CB_dd_2A = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"sra (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"sra\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        42\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**2A\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are shifted right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of bit 7 are unchanged. The result is then stored in D.\\",\\r\\n        \\"instruction\\": \\"sra (ix+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,sra (ix+dd)\\r\\nconst variant_DD_CB_dd_2B = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"sra (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"sra\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        43\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**2B\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are shifted right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of bit 7 are unchanged. The result is then stored in E.\\",\\r\\n        \\"instruction\\": \\"sra (ix+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,sra (ix+dd)\\r\\nconst variant_DD_CB_dd_2C = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"sra (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"sra\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        44\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**2C\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are shifted right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of bit 7 are unchanged. The result is then stored in H.\\",\\r\\n        \\"instruction\\": \\"sra (ix+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,sra (ix+dd)\\r\\nconst variant_DD_CB_dd_2D = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"sra (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"sra\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        45\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**2D\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are shifted right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of bit 7 are unchanged. The result is then stored in L.\\",\\r\\n        \\"instruction\\": \\"sra (ix+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,sra (ix+dd)\\r\\nconst variant_DD_CB_dd_2F = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"sra (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"sra\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        47\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**2F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are shifted right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of bit 7 are unchanged. The result is then stored in A.\\",\\r\\n        \\"instruction\\": \\"sra (ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld sra (ix+dd)\\r\\nconst variant_DD_CB_dd_2F_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"sra (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"sra\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        47\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**2F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are shifted right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of bit 7 are unchanged. The result is then stored in A.\\",\\r\\n        \\"instruction\\": \\"sra (ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,sll (ix+dd)\\r\\nconst variant_DD_CB_dd_30 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"sll (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"sll\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        48\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**30\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are shifted left one bit position. The contents of bit 7 are put into the carry flag and a one is put into bit 0. The result is then stored in B.\\",\\r\\n        \\"instruction\\": \\"sll (ix+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,sll (ix+dd)\\r\\nconst variant_DD_CB_dd_31 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"sll (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"sll\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        49\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**31\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are shifted left one bit position. The contents of bit 7 are put into the carry flag and a one is put into bit 0. The result is then stored in C.\\",\\r\\n        \\"instruction\\": \\"sll (ix+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,sll (ix+dd)\\r\\nconst variant_DD_CB_dd_32 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"sll (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"sll\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        50\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**32\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are shifted left one bit position. The contents of bit 7 are put into the carry flag and a one is put into bit 0. The result is then stored in D.\\",\\r\\n        \\"instruction\\": \\"sll (ix+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,sll (ix+dd)\\r\\nconst variant_DD_CB_dd_33 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"sll (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"sll\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        51\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**33\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are shifted left one bit position. The contents of bit 7 are put into the carry flag and a one is put into bit 0. The result is then stored in E.\\",\\r\\n        \\"instruction\\": \\"sll (ix+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,sll (ix+dd)\\r\\nconst variant_DD_CB_dd_34 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"sll (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"sll\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        52\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**34\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are shifted left one bit position. The contents of bit 7 are put into the carry flag and a one is put into bit 0. The result is then stored in H.\\",\\r\\n        \\"instruction\\": \\"sll (ix+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,sll (ix+dd)\\r\\nconst variant_DD_CB_dd_35 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"sll (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"sll\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        53\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**35\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are shifted left one bit position. The contents of bit 7 are put into the carry flag and a one is put into bit 0. The result is then stored in L.\\",\\r\\n        \\"instruction\\": \\"sll (ix+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,sll (ix+dd)\\r\\nconst variant_DD_CB_dd_37 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"sll (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"sll\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        55\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**37\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are shifted left one bit position. The contents of bit 7 are put into the carry flag and a one is put into bit 0. The result is then stored in A.\\",\\r\\n        \\"instruction\\": \\"sll (ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld sll (ix+dd)\\r\\nconst variant_DD_CB_dd_37_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"sll (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"sll\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        55\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**37\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are shifted left one bit position. The contents of bit 7 are put into the carry flag and a one is put into bit 0. The result is then stored in A.\\",\\r\\n        \\"instruction\\": \\"sll (ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,srl (ix+dd)\\r\\nconst variant_DD_CB_dd_38 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"srl (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"srl\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        56\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**38\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are shifted right one bit position. The contents of bit 0 are copied to the carry flag and a zero is put into bit 7. The result is then stored in B.\\",\\r\\n        \\"instruction\\": \\"srl (ix+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,srl (ix+dd)\\r\\nconst variant_DD_CB_dd_39 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"srl (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"srl\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        57\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**39\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are shifted right one bit position. The contents of bit 0 are copied to the carry flag and a zero is put into bit 7. The result is then stored in C.\\",\\r\\n        \\"instruction\\": \\"srl (ix+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,srl (ix+dd)\\r\\nconst variant_DD_CB_dd_3A = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"srl (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"srl\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        58\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**3A\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are shifted right one bit position. The contents of bit 0 are copied to the carry flag and a zero is put into bit 7. The result is then stored in D.\\",\\r\\n        \\"instruction\\": \\"srl (ix+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,srl (ix+dd)\\r\\nconst variant_DD_CB_dd_3B = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"srl (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"srl\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        59\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**3B\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are shifted right one bit position. The contents of bit 0 are copied to the carry flag and a zero is put into bit 7. The result is then stored in E.\\",\\r\\n        \\"instruction\\": \\"srl (ix+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,srl (ix+dd)\\r\\nconst variant_DD_CB_dd_3C = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"srl (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"srl\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        60\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**3C\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are shifted right one bit position. The contents of bit 0 are copied to the carry flag and a zero is put into bit 7. The result is then stored in H.\\",\\r\\n        \\"instruction\\": \\"srl (ix+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,srl (ix+dd)\\r\\nconst variant_DD_CB_dd_3D = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"srl (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"srl\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        61\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**3D\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are shifted right one bit position. The contents of bit 0 are copied to the carry flag and a zero is put into bit 7. The result is then stored in L.\\",\\r\\n        \\"instruction\\": \\"srl (ix+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,srl (ix+dd)\\r\\nconst variant_DD_CB_dd_3F = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"srl (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"srl\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        63\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**3F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are shifted right one bit position. The contents of bit 0 are copied to the carry flag and a zero is put into bit 7. The result is then stored in A.\\",\\r\\n        \\"instruction\\": \\"srl (ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld srl (ix+dd)\\r\\nconst variant_DD_CB_dd_3F_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"srl (ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"srl\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        63\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**3F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are shifted right one bit position. The contents of bit 0 are copied to the carry flag and a zero is put into bit 7. The result is then stored in A.\\",\\r\\n        \\"instruction\\": \\"srl (ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,res 0,(ix+dd)\\r\\nconst variant_DD_CB_dd_80 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"res 0\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        128\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**80\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 0 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 0,(ix+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,res 0,(ix+dd)\\r\\nconst variant_DD_CB_dd_81 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"res 0\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        129\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**81\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 0 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 0,(ix+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,res 0,(ix+dd)\\r\\nconst variant_DD_CB_dd_82 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"res 0\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        130\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**82\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 0 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 0,(ix+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,res 0,(ix+dd)\\r\\nconst variant_DD_CB_dd_83 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"res 0\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        131\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**83\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 0 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 0,(ix+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,res 0,(ix+dd)\\r\\nconst variant_DD_CB_dd_84 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"res 0\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        132\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**84\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 0 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 0,(ix+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,res 0,(ix+dd)\\r\\nconst variant_DD_CB_dd_85 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"res 0\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        133\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**85\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 0 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 0,(ix+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,res 0,(ix+dd)\\r\\nconst variant_DD_CB_dd_87 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"res 0\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        135\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**87\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 0 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 0,(ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld res 0,(ix+dd)\\r\\nconst variant_DD_CB_dd_87_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"res 0\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"res\\",\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        135\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**87\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 0 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 0,(ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,res 1,(ix+dd)\\r\\nconst variant_DD_CB_dd_88 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"res 1\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        136\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**88\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 1 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 1,(ix+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,res 1,(ix+dd)\\r\\nconst variant_DD_CB_dd_89 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"res 1\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        137\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**89\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 1 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 1,(ix+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,res 1,(ix+dd)\\r\\nconst variant_DD_CB_dd_8A = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"res 1\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        138\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**8A\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 1 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 1,(ix+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,res 1,(ix+dd)\\r\\nconst variant_DD_CB_dd_8B = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"res 1\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        139\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**8B\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 1 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 1,(ix+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,res 1,(ix+dd)\\r\\nconst variant_DD_CB_dd_8C = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"res 1\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        140\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**8C\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 1 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 1,(ix+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,res 1,(ix+dd)\\r\\nconst variant_DD_CB_dd_8D = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"res 1\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        141\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**8D\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 1 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 1,(ix+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,res 1,(ix+dd)\\r\\nconst variant_DD_CB_dd_8F = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"res 1\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        143\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**8F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 1 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 1,(ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld res 1,(ix+dd)\\r\\nconst variant_DD_CB_dd_8F_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"res 1\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"res\\",\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        143\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**8F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 1 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 1,(ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,res 2,(ix+dd)\\r\\nconst variant_DD_CB_dd_90 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"res 2\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        144\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**90\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 2 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 2,(ix+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,res 2,(ix+dd)\\r\\nconst variant_DD_CB_dd_91 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"res 2\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        145\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**91\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 2 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 2,(ix+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,res 2,(ix+dd)\\r\\nconst variant_DD_CB_dd_92 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"res 2\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        146\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**92\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 2 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 2,(ix+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,res 2,(ix+dd)\\r\\nconst variant_DD_CB_dd_93 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"res 2\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        147\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**93\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 2 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 2,(ix+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,res 2,(ix+dd)\\r\\nconst variant_DD_CB_dd_94 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"res 2\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        148\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**94\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 2 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 2,(ix+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,res 2,(ix+dd)\\r\\nconst variant_DD_CB_dd_95 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"res 2\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        149\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**95\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 2 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 2,(ix+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,res 2,(ix+dd)\\r\\nconst variant_DD_CB_dd_97 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"res 2\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        151\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**97\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 2 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 2,(ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld res 2,(ix+dd)\\r\\nconst variant_DD_CB_dd_97_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"res 2\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"res\\",\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        151\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**97\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 2 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 2,(ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,res 3,(ix+dd)\\r\\nconst variant_DD_CB_dd_98 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"res 3\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        152\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**98\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 3 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 3,(ix+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,res 3,(ix+dd)\\r\\nconst variant_DD_CB_dd_99 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"res 3\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        153\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**99\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 3 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 3,(ix+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,res 3,(ix+dd)\\r\\nconst variant_DD_CB_dd_9A = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"res 3\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        154\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**9A\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 3 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 3,(ix+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,res 3,(ix+dd)\\r\\nconst variant_DD_CB_dd_9B = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"res 3\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        155\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**9B\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 3 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 3,(ix+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,res 3,(ix+dd)\\r\\nconst variant_DD_CB_dd_9C = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"res 3\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        156\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**9C\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 3 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 3,(ix+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,res 3,(ix+dd)\\r\\nconst variant_DD_CB_dd_9D = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"res 3\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        157\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**9D\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 3 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 3,(ix+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,res 3,(ix+dd)\\r\\nconst variant_DD_CB_dd_9F = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"res 3\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        159\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**9F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 3 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 3,(ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld res 3,(ix+dd)\\r\\nconst variant_DD_CB_dd_9F_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"res 3\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"res\\",\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        159\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**9F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 3 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 3,(ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,res 4,(ix+dd)\\r\\nconst variant_DD_CB_dd_A0 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"res 4\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        160\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**A0\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 4 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 4,(ix+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,res 4,(ix+dd)\\r\\nconst variant_DD_CB_dd_A1 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"res 4\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        161\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**A1\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 4 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 4,(ix+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,res 4,(ix+dd)\\r\\nconst variant_DD_CB_dd_A2 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"res 4\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        162\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**A2\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 4 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 4,(ix+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,res 4,(ix+dd)\\r\\nconst variant_DD_CB_dd_A3 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"res 4\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        163\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**A3\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 4 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 4,(ix+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,res 4,(ix+dd)\\r\\nconst variant_DD_CB_dd_A4 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"res 4\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        164\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**A4\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 4 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 4,(ix+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,res 4,(ix+dd)\\r\\nconst variant_DD_CB_dd_A5 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"res 4\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        165\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**A5\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 4 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 4,(ix+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,res 4,(ix+dd)\\r\\nconst variant_DD_CB_dd_A7 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"res 4\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        167\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**A7\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 4 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 4,(ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld res 4,(ix+dd)\\r\\nconst variant_DD_CB_dd_A7_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"res 4\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"res\\",\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        167\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**A7\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 4 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 4,(ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,res 5,(ix+dd)\\r\\nconst variant_DD_CB_dd_A8 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"res 5\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        168\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**A8\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 5 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 5,(ix+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,res 5,(ix+dd)\\r\\nconst variant_DD_CB_dd_A9 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"res 5\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        169\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**A9\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 5 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 5,(ix+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,res 5,(ix+dd)\\r\\nconst variant_DD_CB_dd_AA = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"res 5\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        170\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**AA\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 5 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 5,(ix+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,res 5,(ix+dd)\\r\\nconst variant_DD_CB_dd_AB = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"res 5\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        171\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**AB\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 5 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 5,(ix+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,res 5,(ix+dd)\\r\\nconst variant_DD_CB_dd_AC = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"res 5\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        172\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**AC\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 5 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 5,(ix+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,res 5,(ix+dd)\\r\\nconst variant_DD_CB_dd_AD = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"res 5\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        173\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**AD\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 5 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 5,(ix+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,res 5,(ix+dd)\\r\\nconst variant_DD_CB_dd_AF = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"res 5\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        175\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**AF\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 5 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 5,(ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld res 5,(ix+dd)\\r\\nconst variant_DD_CB_dd_AF_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"res 5\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"res\\",\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        175\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**AF\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 5 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 5,(ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,res 6,(ix+dd)\\r\\nconst variant_DD_CB_dd_B0 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"res 6\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        176\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**B0\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 6 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 6,(ix+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,res 6,(ix+dd)\\r\\nconst variant_DD_CB_dd_B1 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"res 6\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        177\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**B1\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 6 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 6,(ix+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,res 6,(ix+dd)\\r\\nconst variant_DD_CB_dd_B2 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"res 6\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        178\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**B2\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 6 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 6,(ix+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,res 6,(ix+dd)\\r\\nconst variant_DD_CB_dd_B3 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"res 6\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        179\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**B3\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 6 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 6,(ix+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,res 6,(ix+dd)\\r\\nconst variant_DD_CB_dd_B4 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"res 6\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        180\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**B4\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 6 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 6,(ix+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,res 6,(ix+dd)\\r\\nconst variant_DD_CB_dd_B5 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"res 6\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        181\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**B5\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 6 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 6,(ix+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,res 6,(ix+dd)\\r\\nconst variant_DD_CB_dd_B7 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"res 6\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        183\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**B7\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 6 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 6,(ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld res 6,(ix+dd)\\r\\nconst variant_DD_CB_dd_B7_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"res 6\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"res\\",\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        183\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**B7\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 6 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 6,(ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,res 7,(ix+dd)\\r\\nconst variant_DD_CB_dd_B8 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"res 7\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        184\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**B8\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 7 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 7,(ix+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,res 7,(ix+dd)\\r\\nconst variant_DD_CB_dd_B9 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"res 7\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        185\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**B9\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 7 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 7,(ix+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,res 7,(ix+dd)\\r\\nconst variant_DD_CB_dd_BA = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"res 7\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        186\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**BA\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 7 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 7,(ix+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,res 7,(ix+dd)\\r\\nconst variant_DD_CB_dd_BB = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"res 7\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        187\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**BB\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 7 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 7,(ix+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,res 7,(ix+dd)\\r\\nconst variant_DD_CB_dd_BC = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"res 7\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        188\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**BC\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 7 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 7,(ix+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,res 7,(ix+dd)\\r\\nconst variant_DD_CB_dd_BD = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"res 7\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        189\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**BD\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 7 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 7,(ix+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,res 7,(ix+dd)\\r\\nconst variant_DD_CB_dd_BF = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"res 7\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        191\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**BF\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 7 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 7,(ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld res 7,(ix+dd)\\r\\nconst variant_DD_CB_dd_BF_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"res 7\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"res\\",\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        191\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**BF\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 7 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 7,(ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,set 0,(ix+dd)\\r\\nconst variant_DD_CB_dd_C0 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"set 0\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        192\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**C0\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 0 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 0,(ix+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,set 0,(ix+dd)\\r\\nconst variant_DD_CB_dd_C1 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"set 0\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        193\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**C1\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 0 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 0,(ix+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,set 0,(ix+dd)\\r\\nconst variant_DD_CB_dd_C2 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"set 0\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        194\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**C2\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 0 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 0,(ix+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,set 0,(ix+dd)\\r\\nconst variant_DD_CB_dd_C3 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"set 0\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        195\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**C3\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 0 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 0,(ix+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,set 0,(ix+dd)\\r\\nconst variant_DD_CB_dd_C4 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"set 0\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        196\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**C4\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 0 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 0,(ix+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,set 0,(ix+dd)\\r\\nconst variant_DD_CB_dd_C5 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"set 0\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        197\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**C5\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 0 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 0,(ix+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,set 0,(ix+dd)\\r\\nconst variant_DD_CB_dd_C7 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"set 0\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        199\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**C7\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 0 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 0,(ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld set 0,(ix+dd)\\r\\nconst variant_DD_CB_dd_C7_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"set 0\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"set\\",\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        199\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**C7\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 0 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 0,(ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,set 1,(ix+dd)\\r\\nconst variant_DD_CB_dd_C8 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"set 1\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        200\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**C8\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 1 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 1,(ix+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,set 1,(ix+dd)\\r\\nconst variant_DD_CB_dd_C9 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"set 1\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        201\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**C9\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 1 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 1,(ix+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,set 1,(ix+dd)\\r\\nconst variant_DD_CB_dd_CA = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"set 1\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        202\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**CA\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 1 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 1,(ix+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,set 1,(ix+dd)\\r\\nconst variant_DD_CB_dd_CB = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"set 1\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        203\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**CB\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 1 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 1,(ix+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,set 1,(ix+dd)\\r\\nconst variant_DD_CB_dd_CC = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"set 1\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        204\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**CC\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 1 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 1,(ix+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,set 1,(ix+dd)\\r\\nconst variant_DD_CB_dd_CD = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"set 1\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        205\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**CD\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 1 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 1,(ix+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,set 1,(ix+dd)\\r\\nconst variant_DD_CB_dd_CF = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"set 1\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        207\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**CF\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 1 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 1,(ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld set 1,(ix+dd)\\r\\nconst variant_DD_CB_dd_CF_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"set 1\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"set\\",\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        207\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**CF\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 1 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 1,(ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,set 2,(ix+dd)\\r\\nconst variant_DD_CB_dd_D0 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"set 2\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        208\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**D0\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 2 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 2,(ix+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,set 2,(ix+dd)\\r\\nconst variant_DD_CB_dd_D1 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"set 2\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        209\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**D1\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 2 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 2,(ix+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,set 2,(ix+dd)\\r\\nconst variant_DD_CB_dd_D2 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"set 2\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        210\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**D2\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 2 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 2,(ix+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,set 2,(ix+dd)\\r\\nconst variant_DD_CB_dd_D3 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"set 2\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        211\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**D3\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 2 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 2,(ix+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,set 2,(ix+dd)\\r\\nconst variant_DD_CB_dd_D4 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"set 2\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        212\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**D4\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 2 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 2,(ix+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,set 2,(ix+dd)\\r\\nconst variant_DD_CB_dd_D5 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"set 2\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        213\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**D5\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 2 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 2,(ix+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,set 2,(ix+dd)\\r\\nconst variant_DD_CB_dd_D7 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"set 2\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        215\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**D7\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 2 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 2,(ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld set 2,(ix+dd)\\r\\nconst variant_DD_CB_dd_D7_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"set 2\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"set\\",\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        215\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**D7\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 2 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 2,(ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,set 3,(ix+dd)\\r\\nconst variant_DD_CB_dd_D8 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"set 3\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        216\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**D8\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 3 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 3,(ix+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,set 3,(ix+dd)\\r\\nconst variant_DD_CB_dd_D9 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"set 3\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        217\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**D9\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 3 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 3,(ix+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,set 3,(ix+dd)\\r\\nconst variant_DD_CB_dd_DA = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"set 3\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        218\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**DA\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 3 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 3,(ix+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,set 3,(ix+dd)\\r\\nconst variant_DD_CB_dd_DB = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"set 3\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        219\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**DB\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 3 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 3,(ix+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,set 3,(ix+dd)\\r\\nconst variant_DD_CB_dd_DC = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"set 3\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        220\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**DC\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 3 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 3,(ix+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,set 3,(ix+dd)\\r\\nconst variant_DD_CB_dd_DD = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"set 3\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        221\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**DD\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 3 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 3,(ix+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,set 3,(ix+dd)\\r\\nconst variant_DD_CB_dd_DF = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"set 3\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        223\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**DF\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 3 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 3,(ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld set 3,(ix+dd)\\r\\nconst variant_DD_CB_dd_DF_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"set 3\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"set\\",\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        223\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**DF\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 3 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 3,(ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,set 4,(ix+dd)\\r\\nconst variant_DD_CB_dd_E0 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"set 4\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        224\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**E0\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 4 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 4,(ix+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,set 4,(ix+dd)\\r\\nconst variant_DD_CB_dd_E1 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"set 4\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        225\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**E1\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 4 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 4,(ix+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,set 4,(ix+dd)\\r\\nconst variant_DD_CB_dd_E2 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"set 4\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        226\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**E2\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 4 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 4,(ix+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,set 4,(ix+dd)\\r\\nconst variant_DD_CB_dd_E3 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"set 4\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        227\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**E3\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 4 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 4,(ix+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,set 4,(ix+dd)\\r\\nconst variant_DD_CB_dd_E4 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"set 4\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        228\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**E4\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 4 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 4,(ix+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,set 4,(ix+dd)\\r\\nconst variant_DD_CB_dd_E5 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"set 4\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        229\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**E5\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 4 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 4,(ix+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,set 4,(ix+dd)\\r\\nconst variant_DD_CB_dd_E7 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"set 4\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        231\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**E7\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 4 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 4,(ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld set 4,(ix+dd)\\r\\nconst variant_DD_CB_dd_E7_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"set 4\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"set\\",\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        231\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**E7\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 4 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 4,(ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,set 5,(ix+dd)\\r\\nconst variant_DD_CB_dd_E8 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"set 5\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        232\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**E8\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 5 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 5,(ix+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,set 5,(ix+dd)\\r\\nconst variant_DD_CB_dd_E9 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"set 5\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        233\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**E9\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 5 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 5,(ix+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,set 5,(ix+dd)\\r\\nconst variant_DD_CB_dd_EA = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"set 5\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        234\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**EA\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 5 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 5,(ix+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,set 5,(ix+dd)\\r\\nconst variant_DD_CB_dd_EB = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"set 5\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        235\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**EB\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 5 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 5,(ix+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,set 5,(ix+dd)\\r\\nconst variant_DD_CB_dd_EC = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"set 5\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        236\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**EC\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 5 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 5,(ix+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,set 5,(ix+dd)\\r\\nconst variant_DD_CB_dd_ED = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"set 5\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        237\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**ED\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 5 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 5,(ix+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,set 5,(ix+dd)\\r\\nconst variant_DD_CB_dd_EF = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"set 5\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        239\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**EF\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 5 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 5,(ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld set 5,(ix+dd)\\r\\nconst variant_DD_CB_dd_EF_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"set 5\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"set\\",\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        239\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**EF\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 5 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 5,(ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,set 6,(ix+dd)\\r\\nconst variant_DD_CB_dd_F0 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"set 6\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        240\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**F0\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 6 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 6,(ix+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,set 6,(ix+dd)\\r\\nconst variant_DD_CB_dd_F1 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"set 6\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        241\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**F1\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 6 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 6,(ix+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,set 6,(ix+dd)\\r\\nconst variant_DD_CB_dd_F2 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"set 6\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        242\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**F2\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 6 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 6,(ix+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,set 6,(ix+dd)\\r\\nconst variant_DD_CB_dd_F3 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"set 6\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        243\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**F3\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 6 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 6,(ix+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,set 6,(ix+dd)\\r\\nconst variant_DD_CB_dd_F4 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"set 6\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        244\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**F4\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 6 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 6,(ix+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,set 6,(ix+dd)\\r\\nconst variant_DD_CB_dd_F5 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"set 6\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        245\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**F5\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 6 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 6,(ix+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,set 6,(ix+dd)\\r\\nconst variant_DD_CB_dd_F7 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"set 6\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        247\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**F7\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 6 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 6,(ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld set 6,(ix+dd)\\r\\nconst variant_DD_CB_dd_F7_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"set 6\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"set\\",\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        247\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**F7\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 6 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 6,(ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,set 7,(ix+dd)\\r\\nconst variant_DD_CB_dd_F8 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"set 7\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        248\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**F8\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 7 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 7,(ix+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,set 7,(ix+dd)\\r\\nconst variant_DD_CB_dd_F9 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"set 7\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        249\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**F9\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 7 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 7,(ix+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,set 7,(ix+dd)\\r\\nconst variant_DD_CB_dd_FA = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"set 7\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        250\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**FA\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 7 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 7,(ix+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,set 7,(ix+dd)\\r\\nconst variant_DD_CB_dd_FB = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"set 7\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        251\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**FB\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 7 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 7,(ix+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,set 7,(ix+dd)\\r\\nconst variant_DD_CB_dd_FC = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"set 7\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        252\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**FC\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 7 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 7,(ix+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,set 7,(ix+dd)\\r\\nconst variant_DD_CB_dd_FD = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"set 7\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        253\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**FD\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 7 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 7,(ix+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,set 7,(ix+dd)\\r\\nconst variant_DD_CB_dd_FF = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"set 7\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        255\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**FF\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 7 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 7,(ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld set 7,(ix+dd)\\r\\nconst variant_DD_CB_dd_FF_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"set 7\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"set\\",\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        255\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**FF\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 7 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 7,(ix+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld sp,ix\\r\\nconst variant_DD_F9 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"sp\\",\\r\\n        \\"ix\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"sp\\",\\r\\n        \\",\\",\\r\\n        \\"ix\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        249\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDF9\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 10,\\r\\n        \\"without_jump_clock_count\\": 10,\\r\\n        \\"description\\": \\"Loads the value of IX into SP.\\",\\r\\n        \\"instruction\\": \\"ld sp,ix\\"\\r\\n    }\\r\\n};\\r\\n// ld (nnnn),bc\\r\\nconst variant_ED_43_nnnn = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"(nnnn)\\",\\r\\n        \\"bc\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"nnnn\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"bc\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        67,\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED43\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Stores BC into the memory location pointed to by **.\\",\\r\\n        \\"instruction\\": \\"ld (**),bc\\"\\r\\n    }\\r\\n};\\r\\n// ld i,a\\r\\nconst variant_ED_47 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"i\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"i\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        71\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED47\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 9,\\r\\n        \\"without_jump_clock_count\\": 9,\\r\\n        \\"description\\": \\"Stores the value of A into register i or r.\\",\\r\\n        \\"instruction\\": \\"ld i,a\\"\\r\\n    }\\r\\n};\\r\\n// ld bc,(nnnn)\\r\\nconst variant_ED_4B_nnnn = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"bc\\",\\r\\n        \\"(nnnn)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"bc\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"nnnn\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        75,\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED4B\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Loads the value pointed to by ** into BC.\\",\\r\\n        \\"instruction\\": \\"ld bc,(**)\\"\\r\\n    }\\r\\n};\\r\\n// ld r,a\\r\\nconst variant_ED_4F = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"r\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"r\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        79\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED4F\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 9,\\r\\n        \\"without_jump_clock_count\\": 9,\\r\\n        \\"description\\": \\"Stores the value of A into register i or r.\\",\\r\\n        \\"instruction\\": \\"ld r,a\\"\\r\\n    }\\r\\n};\\r\\n// ld (nnnn),de\\r\\nconst variant_ED_53_nnnn = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"(nnnn)\\",\\r\\n        \\"de\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"nnnn\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"de\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        83,\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED53\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Stores DE into the memory location pointed to by **.\\",\\r\\n        \\"instruction\\": \\"ld (**),de\\"\\r\\n    }\\r\\n};\\r\\n// ld a,i\\r\\nconst variant_ED_57 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"i\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"i\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        87\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED57\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0*0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 9,\\r\\n        \\"without_jump_clock_count\\": 9,\\r\\n        \\"description\\": \\"Stores the value of register i or r into A.\\",\\r\\n        \\"instruction\\": \\"ld a,i\\"\\r\\n    }\\r\\n};\\r\\n// ld i\\r\\nconst variant_ED_57_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"i\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"i\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        87\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED57\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0*0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 9,\\r\\n        \\"without_jump_clock_count\\": 9,\\r\\n        \\"description\\": \\"Stores the value of register i or r into A.\\",\\r\\n        \\"instruction\\": \\"ld a,i\\"\\r\\n    }\\r\\n};\\r\\n// ld de,(nnnn)\\r\\nconst variant_ED_5B_nnnn = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"de\\",\\r\\n        \\"(nnnn)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"de\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"nnnn\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        91,\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED5B\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Loads the value pointed to by ** into DE.\\",\\r\\n        \\"instruction\\": \\"ld de,(**)\\"\\r\\n    }\\r\\n};\\r\\n// ld a,r\\r\\nconst variant_ED_5F = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"r\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"r\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        95\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED5F\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0*0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 9,\\r\\n        \\"without_jump_clock_count\\": 9,\\r\\n        \\"description\\": \\"Stores the value of register i or r into A.\\",\\r\\n        \\"instruction\\": \\"ld a,r\\"\\r\\n    }\\r\\n};\\r\\n// ld r\\r\\nconst variant_ED_5F_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"r\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"r\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        95\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED5F\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0*0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 9,\\r\\n        \\"without_jump_clock_count\\": 9,\\r\\n        \\"description\\": \\"Stores the value of register i or r into A.\\",\\r\\n        \\"instruction\\": \\"ld a,r\\"\\r\\n    }\\r\\n};\\r\\n// ld (nnnn),hl\\r\\nconst variant_ED_63_nnnn = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"(nnnn)\\",\\r\\n        \\"hl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"nnnn\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"hl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        99,\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED63\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Stores HL into the memory location pointed to by **.\\",\\r\\n        \\"instruction\\": \\"ld (**),hl\\"\\r\\n    }\\r\\n};\\r\\n// ld hl,(nnnn)\\r\\nconst variant_ED_6B_nnnn = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"hl\\",\\r\\n        \\"(nnnn)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"hl\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"nnnn\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        107,\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED6B\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Loads the value pointed to by ** into HL.\\",\\r\\n        \\"instruction\\": \\"ld hl,(**)\\"\\r\\n    }\\r\\n};\\r\\n// ld (nnnn),sp\\r\\nconst variant_ED_73_nnnn = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"(nnnn)\\",\\r\\n        \\"sp\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"nnnn\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"sp\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        115,\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED73\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Stores SP into the memory location pointed to by **.\\",\\r\\n        \\"instruction\\": \\"ld (**),sp\\"\\r\\n    }\\r\\n};\\r\\n// ld sp,(nnnn)\\r\\nconst variant_ED_7B_nnnn = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"sp\\",\\r\\n        \\"(nnnn)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"sp\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"nnnn\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        123,\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED7B\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Loads the value pointed to by ** into SP.\\",\\r\\n        \\"instruction\\": \\"ld sp,(**)\\"\\r\\n    }\\r\\n};\\r\\n// ld sp,hl\\r\\nconst variant_F9 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"sp\\",\\r\\n        \\"hl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"sp\\",\\r\\n        \\",\\",\\r\\n        \\"hl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        249\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"F9\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 6,\\r\\n        \\"without_jump_clock_count\\": 6,\\r\\n        \\"description\\": \\"Loads the value of HL into SP.\\",\\r\\n        \\"instruction\\": \\"ld sp,hl\\"\\r\\n    }\\r\\n};\\r\\n// ld iy,nnnn\\r\\nconst variant_FD_21_nnnn = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"iy\\",\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iy\\",\\r\\n        \\",\\",\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        33,\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD21\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 14,\\r\\n        \\"without_jump_clock_count\\": 14,\\r\\n        \\"description\\": \\"Loads ** into register IY.\\",\\r\\n        \\"instruction\\": \\"ld iy,**\\"\\r\\n    }\\r\\n};\\r\\n// ld (nnnn),iy\\r\\nconst variant_FD_22_nnnn = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"(nnnn)\\",\\r\\n        \\"iy\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"nnnn\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"iy\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        34,\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD22\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Stores IY into the memory location pointed to by **.\\",\\r\\n        \\"instruction\\": \\"ld (**),iy\\"\\r\\n    }\\r\\n};\\r\\n// ld iyh,nn\\r\\nconst variant_FD_26_nn = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"iyh\\",\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iyh\\",\\r\\n        \\",\\",\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        38,\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD26\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 11,\\r\\n        \\"without_jump_clock_count\\": 11,\\r\\n        \\"description\\": \\"Loads * into IYH.\\",\\r\\n        \\"instruction\\": \\"ld iyh,*\\"\\r\\n    }\\r\\n};\\r\\n// ld iy,(nnnn)\\r\\nconst variant_FD_2A_nnnn = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"iy\\",\\r\\n        \\"(nnnn)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iy\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"nnnn\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        42,\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD2A\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Loads the value pointed to by ** into IY.\\",\\r\\n        \\"instruction\\": \\"ld iy,(**)\\"\\r\\n    }\\r\\n};\\r\\n// ld iyl,nn\\r\\nconst variant_FD_2E_nn = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"iyl\\",\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iyl\\",\\r\\n        \\",\\",\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        46,\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD2E\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 11,\\r\\n        \\"without_jump_clock_count\\": 11,\\r\\n        \\"description\\": \\"Loads * into IYL.\\",\\r\\n        \\"instruction\\": \\"ld iyl,*\\"\\r\\n    }\\r\\n};\\r\\n// ld (iy+dd),nn\\r\\nconst variant_FD_36_dd_nn = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"(iy+dd)\\",\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        54,\\r\\n        \\"dd\\",\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD36\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Stores * to the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"ld (iy+*),*\\"\\r\\n    }\\r\\n};\\r\\n// ld b,iyh\\r\\nconst variant_FD_44 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        68\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD44\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of IYH are loaded into B.\\",\\r\\n        \\"instruction\\": \\"ld b,iyh\\"\\r\\n    }\\r\\n};\\r\\n// ld b,iyl\\r\\nconst variant_FD_45 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        69\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD45\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of IYL are loaded into B.\\",\\r\\n        \\"instruction\\": \\"ld b,iyl\\"\\r\\n    }\\r\\n};\\r\\n// ld b,(iy+dd)\\r\\nconst variant_FD_46_dd = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        70,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD46\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Loads the value pointed to by IY plus * into B.\\",\\r\\n        \\"instruction\\": \\"ld b,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// ld c,iyh\\r\\nconst variant_FD_4C = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        76\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD4C\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of IYH are loaded into C.\\",\\r\\n        \\"instruction\\": \\"ld c,iyh\\"\\r\\n    }\\r\\n};\\r\\n// ld c,iyl\\r\\nconst variant_FD_4D = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        77\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD4D\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of IYL are loaded into C.\\",\\r\\n        \\"instruction\\": \\"ld c,iyl\\"\\r\\n    }\\r\\n};\\r\\n// ld c,(iy+dd)\\r\\nconst variant_FD_4E_dd = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        78,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD4E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Loads the value pointed to by IY plus * into C.\\",\\r\\n        \\"instruction\\": \\"ld c,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// ld d,iyh\\r\\nconst variant_FD_54 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        84\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD54\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of IYH are loaded into D.\\",\\r\\n        \\"instruction\\": \\"ld d,iyh\\"\\r\\n    }\\r\\n};\\r\\n// ld d,iyl\\r\\nconst variant_FD_55 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        85\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD55\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of IYL are loaded into D.\\",\\r\\n        \\"instruction\\": \\"ld d,iyl\\"\\r\\n    }\\r\\n};\\r\\n// ld d,(iy+dd)\\r\\nconst variant_FD_56_dd = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        86,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD56\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Loads the value pointed to by IY plus * into D.\\",\\r\\n        \\"instruction\\": \\"ld d,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// ld e,iyh\\r\\nconst variant_FD_5C = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        92\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD5C\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of IYH are loaded into E.\\",\\r\\n        \\"instruction\\": \\"ld e,iyh\\"\\r\\n    }\\r\\n};\\r\\n// ld e,iyl\\r\\nconst variant_FD_5D = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        93\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD5D\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of IYL are loaded into E.\\",\\r\\n        \\"instruction\\": \\"ld e,iyl\\"\\r\\n    }\\r\\n};\\r\\n// ld e,(iy+dd)\\r\\nconst variant_FD_5E_dd = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        94,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD5E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Loads the value pointed to by IY plus * into E.\\",\\r\\n        \\"instruction\\": \\"ld e,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// ld iyh,b\\r\\nconst variant_FD_60 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"iyh\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iyh\\",\\r\\n        \\",\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        96\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD60\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of B are loaded into IYH.\\",\\r\\n        \\"instruction\\": \\"ld iyh,b\\"\\r\\n    }\\r\\n};\\r\\n// ld iyh,c\\r\\nconst variant_FD_61 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"iyh\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iyh\\",\\r\\n        \\",\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        97\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD61\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of C are loaded into IYH.\\",\\r\\n        \\"instruction\\": \\"ld iyh,c\\"\\r\\n    }\\r\\n};\\r\\n// ld iyh,d\\r\\nconst variant_FD_62 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"iyh\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iyh\\",\\r\\n        \\",\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        98\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD62\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of D are loaded into IYH.\\",\\r\\n        \\"instruction\\": \\"ld iyh,d\\"\\r\\n    }\\r\\n};\\r\\n// ld iyh,e\\r\\nconst variant_FD_63 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"iyh\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iyh\\",\\r\\n        \\",\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        99\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD63\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of E are loaded into IYH.\\",\\r\\n        \\"instruction\\": \\"ld iyh,e\\"\\r\\n    }\\r\\n};\\r\\n// ld iyh,iyh\\r\\nconst variant_FD_64 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"iyh\\",\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iyh\\",\\r\\n        \\",\\",\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        100\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD64\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of IYH are loaded into IYH.\\",\\r\\n        \\"instruction\\": \\"ld iyh,iyh\\"\\r\\n    }\\r\\n};\\r\\n// ld iyh,iyl\\r\\nconst variant_FD_65 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"iyh\\",\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iyh\\",\\r\\n        \\",\\",\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        101\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD65\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of IYL are loaded into IYH.\\",\\r\\n        \\"instruction\\": \\"ld iyh,iyl\\"\\r\\n    }\\r\\n};\\r\\n// ld h,(iy+dd)\\r\\nconst variant_FD_66_dd = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        102,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD66\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Loads the value pointed to by IY plus * into H.\\",\\r\\n        \\"instruction\\": \\"ld h,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// ld iyh,a\\r\\nconst variant_FD_67 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"iyh\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iyh\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        103\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD67\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of A are loaded into IYH.\\",\\r\\n        \\"instruction\\": \\"ld iyh,a\\"\\r\\n    }\\r\\n};\\r\\n// ld iyl,b\\r\\nconst variant_FD_68 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"iyl\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iyl\\",\\r\\n        \\",\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        104\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD68\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of B are loaded into IYL.\\",\\r\\n        \\"instruction\\": \\"ld iyl,b\\"\\r\\n    }\\r\\n};\\r\\n// ld iyl,c\\r\\nconst variant_FD_69 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"iyl\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iyl\\",\\r\\n        \\",\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        105\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD69\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of C are loaded into IYL.\\",\\r\\n        \\"instruction\\": \\"ld iyl,c\\"\\r\\n    }\\r\\n};\\r\\n// ld iyl,d\\r\\nconst variant_FD_6A = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"iyl\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iyl\\",\\r\\n        \\",\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        106\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD6A\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of D are loaded into IYL.\\",\\r\\n        \\"instruction\\": \\"ld iyl,d\\"\\r\\n    }\\r\\n};\\r\\n// ld iyl,e\\r\\nconst variant_FD_6B = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"iyl\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iyl\\",\\r\\n        \\",\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        107\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD6B\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of E are loaded into IYL.\\",\\r\\n        \\"instruction\\": \\"ld iyl,e\\"\\r\\n    }\\r\\n};\\r\\n// ld iyl,iyh\\r\\nconst variant_FD_6C = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"iyl\\",\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iyl\\",\\r\\n        \\",\\",\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        108\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD6C\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of IYH are loaded into IYL.\\",\\r\\n        \\"instruction\\": \\"ld iyl,iyh\\"\\r\\n    }\\r\\n};\\r\\n// ld iyl,iyl\\r\\nconst variant_FD_6D = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"iyl\\",\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iyl\\",\\r\\n        \\",\\",\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        109\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD6D\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of IYL are loaded into IYL.\\",\\r\\n        \\"instruction\\": \\"ld iyl,iyl\\"\\r\\n    }\\r\\n};\\r\\n// ld l,(iy+dd)\\r\\nconst variant_FD_6E_dd = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        110,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD6E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Loads the value pointed to by IY plus * into L.\\",\\r\\n        \\"instruction\\": \\"ld l,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// ld iyl,a\\r\\nconst variant_FD_6F = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"iyl\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iyl\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        111\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD6F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of A are loaded into IYL.\\",\\r\\n        \\"instruction\\": \\"ld iyl,a\\"\\r\\n    }\\r\\n};\\r\\n// ld (iy+dd),b\\r\\nconst variant_FD_70_dd = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"(iy+dd)\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        112,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD70\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Stores B to the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"ld (iy+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld (iy+dd),c\\r\\nconst variant_FD_71_dd = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"(iy+dd)\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        113,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD71\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Stores C to the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"ld (iy+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld (iy+dd),d\\r\\nconst variant_FD_72_dd = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"(iy+dd)\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        114,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD72\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Stores D to the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"ld (iy+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld (iy+dd),e\\r\\nconst variant_FD_73_dd = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"(iy+dd)\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        115,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD73\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Stores E to the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"ld (iy+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld (iy+dd),h\\r\\nconst variant_FD_74_dd = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"(iy+dd)\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        116,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD74\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Stores H to the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"ld (iy+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld (iy+dd),l\\r\\nconst variant_FD_75_dd = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"(iy+dd)\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        117,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD75\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Stores L to the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"ld (iy+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld (iy+dd),a\\r\\nconst variant_FD_77_dd = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"(iy+dd)\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        119,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD77\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Stores A to the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"ld (iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld a,iyh\\r\\nconst variant_FD_7C = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        124\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD7C\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of IYH are loaded into A.\\",\\r\\n        \\"instruction\\": \\"ld a,iyh\\"\\r\\n    }\\r\\n};\\r\\n// ld iyh\\r\\nconst variant_FD_7C_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        124\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD7C\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of IYH are loaded into A.\\",\\r\\n        \\"instruction\\": \\"ld a,iyh\\"\\r\\n    }\\r\\n};\\r\\n// ld a,iyl\\r\\nconst variant_FD_7D = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        125\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD7D\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of IYL are loaded into A.\\",\\r\\n        \\"instruction\\": \\"ld a,iyl\\"\\r\\n    }\\r\\n};\\r\\n// ld iyl\\r\\nconst variant_FD_7D_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        125\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD7D\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of IYL are loaded into A.\\",\\r\\n        \\"instruction\\": \\"ld a,iyl\\"\\r\\n    }\\r\\n};\\r\\n// ld a,(iy+dd)\\r\\nconst variant_FD_7E_dd = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        126,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD7E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Loads the value pointed to by IY plus * into A.\\",\\r\\n        \\"instruction\\": \\"ld a,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// ld (iy+dd)\\r\\nconst variant_FD_7E_dd_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        126,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD7E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Loads the value pointed to by IY plus * into A.\\",\\r\\n        \\"instruction\\": \\"ld a,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// ld b,rlc (iy+dd)\\r\\nconst variant_FD_CB_dd_00 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"rlc (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"rlc\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        0\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**00\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0. The result is then stored in B.\\",\\r\\n        \\"instruction\\": \\"rlc (iy+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,rlc (iy+dd)\\r\\nconst variant_FD_CB_dd_01 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"rlc (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"rlc\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        1\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**01\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0. The result is then stored in C.\\",\\r\\n        \\"instruction\\": \\"rlc (iy+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,rlc (iy+dd)\\r\\nconst variant_FD_CB_dd_02 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"rlc (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"rlc\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        2\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**02\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0. The result is then stored in D.\\",\\r\\n        \\"instruction\\": \\"rlc (iy+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,rlc (iy+dd)\\r\\nconst variant_FD_CB_dd_03 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"rlc (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"rlc\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        3\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**03\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0. The result is then stored in E.\\",\\r\\n        \\"instruction\\": \\"rlc (iy+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,rlc (iy+dd)\\r\\nconst variant_FD_CB_dd_04 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"rlc (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"rlc\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        4\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**04\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0. The result is then stored in H.\\",\\r\\n        \\"instruction\\": \\"rlc (iy+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,rlc (iy+dd)\\r\\nconst variant_FD_CB_dd_05 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"rlc (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"rlc\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        5\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**05\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0. The result is then stored in L.\\",\\r\\n        \\"instruction\\": \\"rlc (iy+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,rlc (iy+dd)\\r\\nconst variant_FD_CB_dd_07 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"rlc (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"rlc\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        7\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**07\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0. The result is then stored in A.\\",\\r\\n        \\"instruction\\": \\"rlc (iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld rlc (iy+dd)\\r\\nconst variant_FD_CB_dd_07_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"rlc (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"rlc\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        7\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**07\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0. The result is then stored in A.\\",\\r\\n        \\"instruction\\": \\"rlc (iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,rrc (iy+dd)\\r\\nconst variant_FD_CB_dd_08 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"rrc (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"rrc\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        8\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**08\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7. The result is then stored in B.\\",\\r\\n        \\"instruction\\": \\"rrc (iy+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,rrc (iy+dd)\\r\\nconst variant_FD_CB_dd_09 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"rrc (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"rrc\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        9\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**09\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7. The result is then stored in C.\\",\\r\\n        \\"instruction\\": \\"rrc (iy+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,rrc (iy+dd)\\r\\nconst variant_FD_CB_dd_0A = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"rrc (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"rrc\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        10\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**0A\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7. The result is then stored in D.\\",\\r\\n        \\"instruction\\": \\"rrc (iy+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,rrc (iy+dd)\\r\\nconst variant_FD_CB_dd_0B = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"rrc (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"rrc\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        11\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**0B\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7. The result is then stored in E.\\",\\r\\n        \\"instruction\\": \\"rrc (iy+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,rrc (iy+dd)\\r\\nconst variant_FD_CB_dd_0C = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"rrc (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"rrc\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        12\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**0C\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7. The result is then stored in H.\\",\\r\\n        \\"instruction\\": \\"rrc (iy+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,rrc (iy+dd)\\r\\nconst variant_FD_CB_dd_0D = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"rrc (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"rrc\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        13\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**0D\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7. The result is then stored in L.\\",\\r\\n        \\"instruction\\": \\"rrc (iy+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,rrc (iy+dd)\\r\\nconst variant_FD_CB_dd_0F = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"rrc (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"rrc\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        15\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**0F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7. The result is then stored in A.\\",\\r\\n        \\"instruction\\": \\"rrc (iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld rrc (iy+dd)\\r\\nconst variant_FD_CB_dd_0F_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"rrc (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"rrc\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        15\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**0F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7. The result is then stored in A.\\",\\r\\n        \\"instruction\\": \\"rrc (iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,rl (iy+dd)\\r\\nconst variant_FD_CB_dd_10 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"rl (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"rl\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        16\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**10\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0. The result is then stored in B.\\",\\r\\n        \\"instruction\\": \\"rl (iy+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,rl (iy+dd)\\r\\nconst variant_FD_CB_dd_11 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"rl (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"rl\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        17\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**11\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0. The result is then stored in C.\\",\\r\\n        \\"instruction\\": \\"rl (iy+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,rl (iy+dd)\\r\\nconst variant_FD_CB_dd_12 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"rl (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"rl\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        18\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**12\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0. The result is then stored in D.\\",\\r\\n        \\"instruction\\": \\"rl (iy+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,rl (iy+dd)\\r\\nconst variant_FD_CB_dd_13 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"rl (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"rl\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        19\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**13\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0. The result is then stored in E.\\",\\r\\n        \\"instruction\\": \\"rl (iy+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,rl (iy+dd)\\r\\nconst variant_FD_CB_dd_14 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"rl (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"rl\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        20\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**14\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0. The result is then stored in H.\\",\\r\\n        \\"instruction\\": \\"rl (iy+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,rl (iy+dd)\\r\\nconst variant_FD_CB_dd_15 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"rl (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"rl\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        21\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**15\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0. The result is then stored in L.\\",\\r\\n        \\"instruction\\": \\"rl (iy+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,rl (iy+dd)\\r\\nconst variant_FD_CB_dd_17 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"rl (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"rl\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        23\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**17\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0. The result is then stored in A.\\",\\r\\n        \\"instruction\\": \\"rl (iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld rl (iy+dd)\\r\\nconst variant_FD_CB_dd_17_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"rl (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"rl\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        23\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**17\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0. The result is then stored in A.\\",\\r\\n        \\"instruction\\": \\"rl (iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,rr (iy+dd)\\r\\nconst variant_FD_CB_dd_18 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"rr (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"rr\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        24\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**18\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7. The result is then stored in B.\\",\\r\\n        \\"instruction\\": \\"rr (iy+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,rr (iy+dd)\\r\\nconst variant_FD_CB_dd_19 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"rr (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"rr\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        25\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**19\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7. The result is then stored in C.\\",\\r\\n        \\"instruction\\": \\"rr (iy+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,rr (iy+dd)\\r\\nconst variant_FD_CB_dd_1A = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"rr (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"rr\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        26\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**1A\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7. The result is then stored in D.\\",\\r\\n        \\"instruction\\": \\"rr (iy+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,rr (iy+dd)\\r\\nconst variant_FD_CB_dd_1B = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"rr (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"rr\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        27\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**1B\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7. The result is then stored in E.\\",\\r\\n        \\"instruction\\": \\"rr (iy+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,rr (iy+dd)\\r\\nconst variant_FD_CB_dd_1C = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"rr (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"rr\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        28\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**1C\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7. The result is then stored in H.\\",\\r\\n        \\"instruction\\": \\"rr (iy+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,rr (iy+dd)\\r\\nconst variant_FD_CB_dd_1D = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"rr (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"rr\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        29\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**1D\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7. The result is then stored in L.\\",\\r\\n        \\"instruction\\": \\"rr (iy+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,rr (iy+dd)\\r\\nconst variant_FD_CB_dd_1F = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"rr (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"rr\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        31\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**1F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7. The result is then stored in A.\\",\\r\\n        \\"instruction\\": \\"rr (iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld rr (iy+dd)\\r\\nconst variant_FD_CB_dd_1F_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"rr (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"rr\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        31\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**1F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7. The result is then stored in A.\\",\\r\\n        \\"instruction\\": \\"rr (iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,sla (iy+dd)\\r\\nconst variant_FD_CB_dd_20 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"sla (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"sla\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        32\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**20\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are shifted left one bit position. The contents of bit 7 are copied to the carry flag and a zero is put into bit 0. The result is then stored in B.\\",\\r\\n        \\"instruction\\": \\"sla (iy+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,sla (iy+dd)\\r\\nconst variant_FD_CB_dd_21 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"sla (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"sla\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        33\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**21\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are shifted left one bit position. The contents of bit 7 are copied to the carry flag and a zero is put into bit 0. The result is then stored in C.\\",\\r\\n        \\"instruction\\": \\"sla (iy+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,sla (iy+dd)\\r\\nconst variant_FD_CB_dd_22 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"sla (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"sla\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        34\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**22\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are shifted left one bit position. The contents of bit 7 are copied to the carry flag and a zero is put into bit 0. The result is then stored in D.\\",\\r\\n        \\"instruction\\": \\"sla (iy+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,sla (iy+dd)\\r\\nconst variant_FD_CB_dd_23 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"sla (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"sla\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        35\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**23\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are shifted left one bit position. The contents of bit 7 are copied to the carry flag and a zero is put into bit 0. The result is then stored in E.\\",\\r\\n        \\"instruction\\": \\"sla (iy+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,sla (iy+dd)\\r\\nconst variant_FD_CB_dd_24 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"sla (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"sla\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        36\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**24\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are shifted left one bit position. The contents of bit 7 are copied to the carry flag and a zero is put into bit 0. The result is then stored in H.\\",\\r\\n        \\"instruction\\": \\"sla (iy+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,sla (iy+dd)\\r\\nconst variant_FD_CB_dd_25 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"sla (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"sla\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        37\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**25\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are shifted left one bit position. The contents of bit 7 are copied to the carry flag and a zero is put into bit 0. The result is then stored in L.\\",\\r\\n        \\"instruction\\": \\"sla (iy+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,sla (iy+dd)\\r\\nconst variant_FD_CB_dd_27 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"sla (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"sla\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        39\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**27\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are shifted left one bit position. The contents of bit 7 are copied to the carry flag and a zero is put into bit 0. The result is then stored in A.\\",\\r\\n        \\"instruction\\": \\"sla (iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld sla (iy+dd)\\r\\nconst variant_FD_CB_dd_27_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"sla (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"sla\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        39\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**27\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are shifted left one bit position. The contents of bit 7 are copied to the carry flag and a zero is put into bit 0. The result is then stored in A.\\",\\r\\n        \\"instruction\\": \\"sla (iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,sra (iy+dd)\\r\\nconst variant_FD_CB_dd_28 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"sra (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"sra\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        40\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**28\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are shifted right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of bit 7 are unchanged. The result is then stored in B.\\",\\r\\n        \\"instruction\\": \\"sra (iy+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,sra (iy+dd)\\r\\nconst variant_FD_CB_dd_29 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"sra (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"sra\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        41\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**29\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are shifted right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of bit 7 are unchanged. The result is then stored in C.\\",\\r\\n        \\"instruction\\": \\"sra (iy+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,sra (iy+dd)\\r\\nconst variant_FD_CB_dd_2A = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"sra (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"sra\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        42\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**2A\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are shifted right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of bit 7 are unchanged. The result is then stored in D.\\",\\r\\n        \\"instruction\\": \\"sra (iy+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,sra (iy+dd)\\r\\nconst variant_FD_CB_dd_2B = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"sra (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"sra\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        43\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**2B\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are shifted right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of bit 7 are unchanged. The result is then stored in E.\\",\\r\\n        \\"instruction\\": \\"sra (iy+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,sra (iy+dd)\\r\\nconst variant_FD_CB_dd_2C = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"sra (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"sra\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        44\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**2C\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are shifted right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of bit 7 are unchanged. The result is then stored in H.\\",\\r\\n        \\"instruction\\": \\"sra (iy+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,sra (iy+dd)\\r\\nconst variant_FD_CB_dd_2D = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"sra (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"sra\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        45\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**2D\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are shifted right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of bit 7 are unchanged. The result is then stored in L.\\",\\r\\n        \\"instruction\\": \\"sra (iy+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,sra (iy+dd)\\r\\nconst variant_FD_CB_dd_2F = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"sra (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"sra\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        47\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**2F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are shifted right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of bit 7 are unchanged. The result is then stored in A.\\",\\r\\n        \\"instruction\\": \\"sra (iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld sra (iy+dd)\\r\\nconst variant_FD_CB_dd_2F_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"sra (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"sra\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        47\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**2F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are shifted right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of bit 7 are unchanged. The result is then stored in A.\\",\\r\\n        \\"instruction\\": \\"sra (iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,sll (iy+dd)\\r\\nconst variant_FD_CB_dd_30 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"sll (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"sll\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        48\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**30\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are shifted left one bit position. The contents of bit 7 are put into the carry flag and a one is put into bit 0. The result is then stored in B.\\",\\r\\n        \\"instruction\\": \\"sll (iy+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,sll (iy+dd)\\r\\nconst variant_FD_CB_dd_31 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"sll (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"sll\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        49\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**31\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are shifted left one bit position. The contents of bit 7 are put into the carry flag and a one is put into bit 0. The result is then stored in C.\\",\\r\\n        \\"instruction\\": \\"sll (iy+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,sll (iy+dd)\\r\\nconst variant_FD_CB_dd_32 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"sll (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"sll\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        50\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**32\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are shifted left one bit position. The contents of bit 7 are put into the carry flag and a one is put into bit 0. The result is then stored in D.\\",\\r\\n        \\"instruction\\": \\"sll (iy+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,sll (iy+dd)\\r\\nconst variant_FD_CB_dd_33 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"sll (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"sll\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        51\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**33\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are shifted left one bit position. The contents of bit 7 are put into the carry flag and a one is put into bit 0. The result is then stored in E.\\",\\r\\n        \\"instruction\\": \\"sll (iy+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,sll (iy+dd)\\r\\nconst variant_FD_CB_dd_34 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"sll (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"sll\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        52\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**34\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are shifted left one bit position. The contents of bit 7 are put into the carry flag and a one is put into bit 0. The result is then stored in H.\\",\\r\\n        \\"instruction\\": \\"sll (iy+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,sll (iy+dd)\\r\\nconst variant_FD_CB_dd_35 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"sll (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"sll\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        53\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**35\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are shifted left one bit position. The contents of bit 7 are put into the carry flag and a one is put into bit 0. The result is then stored in L.\\",\\r\\n        \\"instruction\\": \\"sll (iy+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,sll (iy+dd)\\r\\nconst variant_FD_CB_dd_37 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"sll (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"sll\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        55\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**37\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are shifted left one bit position. The contents of bit 7 are put into the carry flag and a one is put into bit 0. The result is then stored in A.\\",\\r\\n        \\"instruction\\": \\"sll (iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld sll (iy+dd)\\r\\nconst variant_FD_CB_dd_37_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"sll (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"sll\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        55\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**37\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are shifted left one bit position. The contents of bit 7 are put into the carry flag and a one is put into bit 0. The result is then stored in A.\\",\\r\\n        \\"instruction\\": \\"sll (iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,srl (iy+dd)\\r\\nconst variant_FD_CB_dd_38 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"srl (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"srl\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        56\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**38\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are shifted right one bit position. The contents of bit 0 are copied to the carry flag and a zero is put into bit 7. The result is then stored in B.\\",\\r\\n        \\"instruction\\": \\"srl (iy+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,srl (iy+dd)\\r\\nconst variant_FD_CB_dd_39 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"srl (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"srl\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        57\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**39\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are shifted right one bit position. The contents of bit 0 are copied to the carry flag and a zero is put into bit 7. The result is then stored in C.\\",\\r\\n        \\"instruction\\": \\"srl (iy+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,srl (iy+dd)\\r\\nconst variant_FD_CB_dd_3A = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"srl (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"srl\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        58\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**3A\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are shifted right one bit position. The contents of bit 0 are copied to the carry flag and a zero is put into bit 7. The result is then stored in D.\\",\\r\\n        \\"instruction\\": \\"srl (iy+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,srl (iy+dd)\\r\\nconst variant_FD_CB_dd_3B = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"srl (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"srl\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        59\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**3B\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are shifted right one bit position. The contents of bit 0 are copied to the carry flag and a zero is put into bit 7. The result is then stored in E.\\",\\r\\n        \\"instruction\\": \\"srl (iy+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,srl (iy+dd)\\r\\nconst variant_FD_CB_dd_3C = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"srl (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"srl\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        60\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**3C\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are shifted right one bit position. The contents of bit 0 are copied to the carry flag and a zero is put into bit 7. The result is then stored in H.\\",\\r\\n        \\"instruction\\": \\"srl (iy+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,srl (iy+dd)\\r\\nconst variant_FD_CB_dd_3D = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"srl (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"srl\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        61\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**3D\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are shifted right one bit position. The contents of bit 0 are copied to the carry flag and a zero is put into bit 7. The result is then stored in L.\\",\\r\\n        \\"instruction\\": \\"srl (iy+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,srl (iy+dd)\\r\\nconst variant_FD_CB_dd_3F = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"srl (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"srl\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        63\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**3F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are shifted right one bit position. The contents of bit 0 are copied to the carry flag and a zero is put into bit 7. The result is then stored in A.\\",\\r\\n        \\"instruction\\": \\"srl (iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld srl (iy+dd)\\r\\nconst variant_FD_CB_dd_3F_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"srl (iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"srl\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        63\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**3F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are shifted right one bit position. The contents of bit 0 are copied to the carry flag and a zero is put into bit 7. The result is then stored in A.\\",\\r\\n        \\"instruction\\": \\"srl (iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,res 0,(iy+dd)\\r\\nconst variant_FD_CB_dd_80 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"res 0\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        128\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**80\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 0 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 0,(iy+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,res 0,(iy+dd)\\r\\nconst variant_FD_CB_dd_81 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"res 0\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        129\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**81\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 0 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 0,(iy+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,res 0,(iy+dd)\\r\\nconst variant_FD_CB_dd_82 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"res 0\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        130\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**82\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 0 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 0,(iy+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,res 0,(iy+dd)\\r\\nconst variant_FD_CB_dd_83 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"res 0\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        131\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**83\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 0 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 0,(iy+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,res 0,(iy+dd)\\r\\nconst variant_FD_CB_dd_84 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"res 0\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        132\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**84\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 0 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 0,(iy+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,res 0,(iy+dd)\\r\\nconst variant_FD_CB_dd_85 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"res 0\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        133\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**85\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 0 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 0,(iy+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,res 0,(iy+dd)\\r\\nconst variant_FD_CB_dd_87 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"res 0\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        135\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**87\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 0 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 0,(iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld res 0,(iy+dd)\\r\\nconst variant_FD_CB_dd_87_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"res 0\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"res\\",\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        135\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**87\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 0 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 0,(iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,res 1,(iy+dd)\\r\\nconst variant_FD_CB_dd_88 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"res 1\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        136\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**88\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 1 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 1,(iy+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,res 1,(iy+dd)\\r\\nconst variant_FD_CB_dd_89 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"res 1\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        137\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**89\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 1 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 1,(iy+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,res 1,(iy+dd)\\r\\nconst variant_FD_CB_dd_8A = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"res 1\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        138\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**8A\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 1 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 1,(iy+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,res 1,(iy+dd)\\r\\nconst variant_FD_CB_dd_8B = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"res 1\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        139\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**8B\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 1 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 1,(iy+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,res 1,(iy+dd)\\r\\nconst variant_FD_CB_dd_8C = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"res 1\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        140\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**8C\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 1 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 1,(iy+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,res 1,(iy+dd)\\r\\nconst variant_FD_CB_dd_8D = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"res 1\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        141\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**8D\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 1 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 1,(iy+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,res 1,(iy+dd)\\r\\nconst variant_FD_CB_dd_8F = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"res 1\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        143\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**8F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 1 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 1,(iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld res 1,(iy+dd)\\r\\nconst variant_FD_CB_dd_8F_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"res 1\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"res\\",\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        143\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**8F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 1 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 1,(iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,res 2,(iy+dd)\\r\\nconst variant_FD_CB_dd_90 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"res 2\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        144\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**90\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 2 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 2,(iy+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,res 2,(iy+dd)\\r\\nconst variant_FD_CB_dd_91 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"res 2\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        145\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**91\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 2 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 2,(iy+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,res 2,(iy+dd)\\r\\nconst variant_FD_CB_dd_92 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"res 2\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        146\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**92\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 2 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 2,(iy+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,res 2,(iy+dd)\\r\\nconst variant_FD_CB_dd_93 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"res 2\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        147\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**93\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 2 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 2,(iy+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,res 2,(iy+dd)\\r\\nconst variant_FD_CB_dd_94 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"res 2\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        148\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**94\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 2 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 2,(iy+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,res 2,(iy+dd)\\r\\nconst variant_FD_CB_dd_95 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"res 2\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        149\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**95\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 2 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 2,(iy+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,res 2,(iy+dd)\\r\\nconst variant_FD_CB_dd_97 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"res 2\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        151\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**97\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 2 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 2,(iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld res 2,(iy+dd)\\r\\nconst variant_FD_CB_dd_97_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"res 2\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"res\\",\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        151\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**97\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 2 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 2,(iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,res 3,(iy+dd)\\r\\nconst variant_FD_CB_dd_98 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"res 3\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        152\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**98\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 3 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 3,(iy+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,res 3,(iy+dd)\\r\\nconst variant_FD_CB_dd_99 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"res 3\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        153\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**99\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 3 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 3,(iy+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,res 3,(iy+dd)\\r\\nconst variant_FD_CB_dd_9A = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"res 3\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        154\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**9A\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 3 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 3,(iy+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,res 3,(iy+dd)\\r\\nconst variant_FD_CB_dd_9B = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"res 3\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        155\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**9B\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 3 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 3,(iy+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,res 3,(iy+dd)\\r\\nconst variant_FD_CB_dd_9C = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"res 3\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        156\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**9C\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 3 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 3,(iy+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,res 3,(iy+dd)\\r\\nconst variant_FD_CB_dd_9D = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"res 3\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        157\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**9D\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 3 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 3,(iy+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,res 3,(iy+dd)\\r\\nconst variant_FD_CB_dd_9F = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"res 3\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        159\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**9F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 3 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 3,(iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld res 3,(iy+dd)\\r\\nconst variant_FD_CB_dd_9F_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"res 3\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"res\\",\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        159\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**9F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 3 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 3,(iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,res 4,(iy+dd)\\r\\nconst variant_FD_CB_dd_A0 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"res 4\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        160\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**A0\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 4 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 4,(iy+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,res 4,(iy+dd)\\r\\nconst variant_FD_CB_dd_A1 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"res 4\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        161\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**A1\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 4 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 4,(iy+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,res 4,(iy+dd)\\r\\nconst variant_FD_CB_dd_A2 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"res 4\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        162\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**A2\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 4 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 4,(iy+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,res 4,(iy+dd)\\r\\nconst variant_FD_CB_dd_A3 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"res 4\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        163\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**A3\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 4 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 4,(iy+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,res 4,(iy+dd)\\r\\nconst variant_FD_CB_dd_A4 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"res 4\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        164\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**A4\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 4 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 4,(iy+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,res 4,(iy+dd)\\r\\nconst variant_FD_CB_dd_A5 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"res 4\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        165\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**A5\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 4 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 4,(iy+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,res 4,(iy+dd)\\r\\nconst variant_FD_CB_dd_A7 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"res 4\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        167\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**A7\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 4 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 4,(iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld res 4,(iy+dd)\\r\\nconst variant_FD_CB_dd_A7_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"res 4\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"res\\",\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        167\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**A7\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 4 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 4,(iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,res 5,(iy+dd)\\r\\nconst variant_FD_CB_dd_A8 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"res 5\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        168\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**A8\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 5 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 5,(iy+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,res 5,(iy+dd)\\r\\nconst variant_FD_CB_dd_A9 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"res 5\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        169\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**A9\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 5 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 5,(iy+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,res 5,(iy+dd)\\r\\nconst variant_FD_CB_dd_AA = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"res 5\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        170\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**AA\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 5 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 5,(iy+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,res 5,(iy+dd)\\r\\nconst variant_FD_CB_dd_AB = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"res 5\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        171\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**AB\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 5 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 5,(iy+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,res 5,(iy+dd)\\r\\nconst variant_FD_CB_dd_AC = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"res 5\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        172\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**AC\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 5 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 5,(iy+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,res 5,(iy+dd)\\r\\nconst variant_FD_CB_dd_AD = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"res 5\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        173\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**AD\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 5 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 5,(iy+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,res 5,(iy+dd)\\r\\nconst variant_FD_CB_dd_AF = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"res 5\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        175\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**AF\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 5 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 5,(iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld res 5,(iy+dd)\\r\\nconst variant_FD_CB_dd_AF_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"res 5\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"res\\",\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        175\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**AF\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 5 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 5,(iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,res 6,(iy+dd)\\r\\nconst variant_FD_CB_dd_B0 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"res 6\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        176\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**B0\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 6 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 6,(iy+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,res 6,(iy+dd)\\r\\nconst variant_FD_CB_dd_B1 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"res 6\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        177\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**B1\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 6 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 6,(iy+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,res 6,(iy+dd)\\r\\nconst variant_FD_CB_dd_B2 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"res 6\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        178\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**B2\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 6 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 6,(iy+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,res 6,(iy+dd)\\r\\nconst variant_FD_CB_dd_B3 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"res 6\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        179\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**B3\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 6 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 6,(iy+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,res 6,(iy+dd)\\r\\nconst variant_FD_CB_dd_B4 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"res 6\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        180\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**B4\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 6 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 6,(iy+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,res 6,(iy+dd)\\r\\nconst variant_FD_CB_dd_B5 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"res 6\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        181\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**B5\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 6 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 6,(iy+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,res 6,(iy+dd)\\r\\nconst variant_FD_CB_dd_B7 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"res 6\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        183\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**B7\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 6 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 6,(iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld res 6,(iy+dd)\\r\\nconst variant_FD_CB_dd_B7_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"res 6\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"res\\",\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        183\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**B7\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 6 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 6,(iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,res 7,(iy+dd)\\r\\nconst variant_FD_CB_dd_B8 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"res 7\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        184\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**B8\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 7 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 7,(iy+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,res 7,(iy+dd)\\r\\nconst variant_FD_CB_dd_B9 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"res 7\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        185\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**B9\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 7 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 7,(iy+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,res 7,(iy+dd)\\r\\nconst variant_FD_CB_dd_BA = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"res 7\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        186\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**BA\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 7 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 7,(iy+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,res 7,(iy+dd)\\r\\nconst variant_FD_CB_dd_BB = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"res 7\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        187\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**BB\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 7 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 7,(iy+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,res 7,(iy+dd)\\r\\nconst variant_FD_CB_dd_BC = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"res 7\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        188\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**BC\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 7 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 7,(iy+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,res 7,(iy+dd)\\r\\nconst variant_FD_CB_dd_BD = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"res 7\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        189\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**BD\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 7 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 7,(iy+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,res 7,(iy+dd)\\r\\nconst variant_FD_CB_dd_BF = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"res 7\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"res\\",\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        191\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**BF\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 7 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 7,(iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld res 7,(iy+dd)\\r\\nconst variant_FD_CB_dd_BF_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"res 7\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"res\\",\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        191\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**BF\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 7 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 7,(iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,set 0,(iy+dd)\\r\\nconst variant_FD_CB_dd_C0 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"set 0\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        192\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**C0\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 0 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 0,(iy+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,set 0,(iy+dd)\\r\\nconst variant_FD_CB_dd_C1 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"set 0\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        193\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**C1\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 0 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 0,(iy+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,set 0,(iy+dd)\\r\\nconst variant_FD_CB_dd_C2 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"set 0\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        194\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**C2\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 0 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 0,(iy+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,set 0,(iy+dd)\\r\\nconst variant_FD_CB_dd_C3 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"set 0\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        195\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**C3\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 0 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 0,(iy+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,set 0,(iy+dd)\\r\\nconst variant_FD_CB_dd_C4 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"set 0\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        196\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**C4\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 0 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 0,(iy+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,set 0,(iy+dd)\\r\\nconst variant_FD_CB_dd_C5 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"set 0\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        197\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**C5\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 0 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 0,(iy+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,set 0,(iy+dd)\\r\\nconst variant_FD_CB_dd_C7 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"set 0\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        199\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**C7\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 0 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 0,(iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld set 0,(iy+dd)\\r\\nconst variant_FD_CB_dd_C7_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"set 0\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"set\\",\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        199\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**C7\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 0 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 0,(iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,set 1,(iy+dd)\\r\\nconst variant_FD_CB_dd_C8 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"set 1\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        200\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**C8\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 1 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 1,(iy+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,set 1,(iy+dd)\\r\\nconst variant_FD_CB_dd_C9 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"set 1\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        201\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**C9\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 1 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 1,(iy+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,set 1,(iy+dd)\\r\\nconst variant_FD_CB_dd_CA = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"set 1\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        202\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**CA\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 1 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 1,(iy+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,set 1,(iy+dd)\\r\\nconst variant_FD_CB_dd_CB = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"set 1\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        203\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**CB\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 1 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 1,(iy+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,set 1,(iy+dd)\\r\\nconst variant_FD_CB_dd_CC = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"set 1\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        204\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**CC\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 1 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 1,(iy+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,set 1,(iy+dd)\\r\\nconst variant_FD_CB_dd_CD = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"set 1\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        205\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**CD\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 1 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 1,(iy+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,set 1,(iy+dd)\\r\\nconst variant_FD_CB_dd_CF = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"set 1\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        207\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**CF\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 1 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 1,(iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld set 1,(iy+dd)\\r\\nconst variant_FD_CB_dd_CF_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"set 1\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"set\\",\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        207\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**CF\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 1 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 1,(iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,set 2,(iy+dd)\\r\\nconst variant_FD_CB_dd_D0 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"set 2\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        208\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**D0\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 2 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 2,(iy+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,set 2,(iy+dd)\\r\\nconst variant_FD_CB_dd_D1 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"set 2\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        209\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**D1\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 2 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 2,(iy+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,set 2,(iy+dd)\\r\\nconst variant_FD_CB_dd_D2 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"set 2\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        210\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**D2\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 2 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 2,(iy+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,set 2,(iy+dd)\\r\\nconst variant_FD_CB_dd_D3 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"set 2\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        211\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**D3\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 2 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 2,(iy+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,set 2,(iy+dd)\\r\\nconst variant_FD_CB_dd_D4 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"set 2\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        212\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**D4\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 2 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 2,(iy+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,set 2,(iy+dd)\\r\\nconst variant_FD_CB_dd_D5 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"set 2\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        213\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**D5\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 2 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 2,(iy+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,set 2,(iy+dd)\\r\\nconst variant_FD_CB_dd_D7 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"set 2\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        215\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**D7\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 2 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 2,(iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld set 2,(iy+dd)\\r\\nconst variant_FD_CB_dd_D7_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"set 2\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"set\\",\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        215\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**D7\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 2 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 2,(iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,set 3,(iy+dd)\\r\\nconst variant_FD_CB_dd_D8 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"set 3\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        216\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**D8\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 3 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 3,(iy+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,set 3,(iy+dd)\\r\\nconst variant_FD_CB_dd_D9 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"set 3\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        217\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**D9\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 3 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 3,(iy+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,set 3,(iy+dd)\\r\\nconst variant_FD_CB_dd_DA = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"set 3\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        218\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**DA\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 3 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 3,(iy+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,set 3,(iy+dd)\\r\\nconst variant_FD_CB_dd_DB = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"set 3\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        219\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**DB\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 3 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 3,(iy+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,set 3,(iy+dd)\\r\\nconst variant_FD_CB_dd_DC = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"set 3\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        220\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**DC\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 3 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 3,(iy+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,set 3,(iy+dd)\\r\\nconst variant_FD_CB_dd_DD = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"set 3\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        221\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**DD\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 3 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 3,(iy+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,set 3,(iy+dd)\\r\\nconst variant_FD_CB_dd_DF = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"set 3\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        223\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**DF\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 3 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 3,(iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld set 3,(iy+dd)\\r\\nconst variant_FD_CB_dd_DF_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"set 3\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"set\\",\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        223\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**DF\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 3 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 3,(iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,set 4,(iy+dd)\\r\\nconst variant_FD_CB_dd_E0 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"set 4\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        224\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**E0\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 4 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 4,(iy+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,set 4,(iy+dd)\\r\\nconst variant_FD_CB_dd_E1 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"set 4\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        225\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**E1\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 4 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 4,(iy+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,set 4,(iy+dd)\\r\\nconst variant_FD_CB_dd_E2 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"set 4\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        226\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**E2\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 4 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 4,(iy+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,set 4,(iy+dd)\\r\\nconst variant_FD_CB_dd_E3 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"set 4\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        227\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**E3\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 4 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 4,(iy+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,set 4,(iy+dd)\\r\\nconst variant_FD_CB_dd_E4 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"set 4\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        228\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**E4\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 4 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 4,(iy+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,set 4,(iy+dd)\\r\\nconst variant_FD_CB_dd_E5 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"set 4\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        229\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**E5\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 4 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 4,(iy+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,set 4,(iy+dd)\\r\\nconst variant_FD_CB_dd_E7 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"set 4\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        231\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**E7\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 4 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 4,(iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld set 4,(iy+dd)\\r\\nconst variant_FD_CB_dd_E7_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"set 4\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"set\\",\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        231\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**E7\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 4 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 4,(iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,set 5,(iy+dd)\\r\\nconst variant_FD_CB_dd_E8 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"set 5\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        232\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**E8\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 5 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 5,(iy+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,set 5,(iy+dd)\\r\\nconst variant_FD_CB_dd_E9 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"set 5\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        233\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**E9\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 5 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 5,(iy+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,set 5,(iy+dd)\\r\\nconst variant_FD_CB_dd_EA = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"set 5\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        234\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**EA\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 5 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 5,(iy+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,set 5,(iy+dd)\\r\\nconst variant_FD_CB_dd_EB = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"set 5\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        235\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**EB\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 5 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 5,(iy+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,set 5,(iy+dd)\\r\\nconst variant_FD_CB_dd_EC = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"set 5\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        236\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**EC\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 5 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 5,(iy+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,set 5,(iy+dd)\\r\\nconst variant_FD_CB_dd_ED = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"set 5\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        237\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**ED\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 5 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 5,(iy+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,set 5,(iy+dd)\\r\\nconst variant_FD_CB_dd_EF = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"set 5\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        239\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**EF\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 5 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 5,(iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld set 5,(iy+dd)\\r\\nconst variant_FD_CB_dd_EF_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"set 5\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"set\\",\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        239\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**EF\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 5 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 5,(iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,set 6,(iy+dd)\\r\\nconst variant_FD_CB_dd_F0 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"set 6\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        240\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**F0\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 6 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 6,(iy+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,set 6,(iy+dd)\\r\\nconst variant_FD_CB_dd_F1 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"set 6\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        241\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**F1\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 6 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 6,(iy+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,set 6,(iy+dd)\\r\\nconst variant_FD_CB_dd_F2 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"set 6\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        242\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**F2\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 6 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 6,(iy+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,set 6,(iy+dd)\\r\\nconst variant_FD_CB_dd_F3 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"set 6\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        243\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**F3\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 6 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 6,(iy+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,set 6,(iy+dd)\\r\\nconst variant_FD_CB_dd_F4 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"set 6\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        244\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**F4\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 6 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 6,(iy+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,set 6,(iy+dd)\\r\\nconst variant_FD_CB_dd_F5 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"set 6\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        245\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**F5\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 6 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 6,(iy+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,set 6,(iy+dd)\\r\\nconst variant_FD_CB_dd_F7 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"set 6\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        247\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**F7\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 6 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 6,(iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld set 6,(iy+dd)\\r\\nconst variant_FD_CB_dd_F7_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"set 6\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"set\\",\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        247\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**F7\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 6 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 6,(iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld b,set 7,(iy+dd)\\r\\nconst variant_FD_CB_dd_F8 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"set 7\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        248\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**F8\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 7 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 7,(iy+*),b\\"\\r\\n    }\\r\\n};\\r\\n// ld c,set 7,(iy+dd)\\r\\nconst variant_FD_CB_dd_F9 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"set 7\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        249\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**F9\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 7 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 7,(iy+*),c\\"\\r\\n    }\\r\\n};\\r\\n// ld d,set 7,(iy+dd)\\r\\nconst variant_FD_CB_dd_FA = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"set 7\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        250\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**FA\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 7 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 7,(iy+*),d\\"\\r\\n    }\\r\\n};\\r\\n// ld e,set 7,(iy+dd)\\r\\nconst variant_FD_CB_dd_FB = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"set 7\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        251\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**FB\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 7 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 7,(iy+*),e\\"\\r\\n    }\\r\\n};\\r\\n// ld h,set 7,(iy+dd)\\r\\nconst variant_FD_CB_dd_FC = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"set 7\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        252\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**FC\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 7 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 7,(iy+*),h\\"\\r\\n    }\\r\\n};\\r\\n// ld l,set 7,(iy+dd)\\r\\nconst variant_FD_CB_dd_FD = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"set 7\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        253\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**FD\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 7 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 7,(iy+*),l\\"\\r\\n    }\\r\\n};\\r\\n// ld a,set 7,(iy+dd)\\r\\nconst variant_FD_CB_dd_FF = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"set 7\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"set\\",\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        255\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**FF\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 7 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 7,(iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld set 7,(iy+dd)\\r\\nconst variant_FD_CB_dd_FF_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"set 7\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"set\\",\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        255\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**FF\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 7 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 7,(iy+*),a\\"\\r\\n    }\\r\\n};\\r\\n// ld sp,iy\\r\\nconst variant_FD_F9 = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"sp\\",\\r\\n        \\"iy\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"sp\\",\\r\\n        \\",\\",\\r\\n        \\"iy\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        249\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDF9\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 10,\\r\\n        \\"without_jump_clock_count\\": 10,\\r\\n        \\"description\\": \\"Loads the value of IY into SP.\\",\\r\\n        \\"instruction\\": \\"ld sp,iy\\"\\r\\n    }\\r\\n};\\r\\n// ld hl,bc\\r\\nconst variant_60_69_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"hl\\",\\r\\n        \\"bc\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"hl\\",\\r\\n        \\",\\",\\r\\n        \\"bc\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        96,\\r\\n        105\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false\\r\\n};\\r\\n// ld bc,hl\\r\\nconst variant_44_4D_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"bc\\",\\r\\n        \\"hl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"bc\\",\\r\\n        \\",\\",\\r\\n        \\"hl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        68,\\r\\n        77\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false\\r\\n};\\r\\n// ld de,hl\\r\\nconst variant_54_5D_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"de\\",\\r\\n        \\"hl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"de\\",\\r\\n        \\",\\",\\r\\n        \\"hl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        84,\\r\\n        93\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false\\r\\n};\\r\\n// ld hl,de\\r\\nconst variant_62_6B_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"hl\\",\\r\\n        \\"de\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"hl\\",\\r\\n        \\",\\",\\r\\n        \\"de\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        98,\\r\\n        107\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false\\r\\n};\\r\\n// ld bc,(hl)\\r\\nconst variant_4E_23_46_2B_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"bc\\",\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"bc\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        78,\\r\\n        35,\\r\\n        70,\\r\\n        43\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false\\r\\n};\\r\\n// ld (hl),bc\\r\\nconst variant_71_23_70_2B_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"(hl)\\",\\r\\n        \\"bc\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"bc\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        113,\\r\\n        35,\\r\\n        112,\\r\\n        43\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false\\r\\n};\\r\\n// ld (hl),de\\r\\nconst variant_73_23_72_2B_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"(hl)\\",\\r\\n        \\"de\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"de\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        115,\\r\\n        35,\\r\\n        114,\\r\\n        43\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false\\r\\n};\\r\\n// ld de,bc\\r\\nconst variant_50_59_pseudo = {\\r\\n    \\"mnemonic\\": \\"ld\\",\\r\\n    \\"params\\": [\\r\\n        \\"de\\",\\r\\n        \\"bc\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"de\\",\\r\\n        \\",\\",\\r\\n        \\"bc\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        80,\\r\\n        89\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false\\r\\n};\\r\\n// inc bc\\r\\nconst variant_03 = {\\r\\n    \\"mnemonic\\": \\"inc\\",\\r\\n    \\"params\\": [\\r\\n        \\"bc\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"bc\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        3\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"03\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 6,\\r\\n        \\"without_jump_clock_count\\": 6,\\r\\n        \\"description\\": \\"Adds one to BC.\\",\\r\\n        \\"instruction\\": \\"inc bc\\"\\r\\n    }\\r\\n};\\r\\n// inc b\\r\\nconst variant_04 = {\\r\\n    \\"mnemonic\\": \\"inc\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        4\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"04\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-+V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Adds one to B.\\",\\r\\n        \\"instruction\\": \\"inc b\\"\\r\\n    }\\r\\n};\\r\\n// inc c\\r\\nconst variant_0C = {\\r\\n    \\"mnemonic\\": \\"inc\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        12\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"0C\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-+V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Adds one to C.\\",\\r\\n        \\"instruction\\": \\"inc c\\"\\r\\n    }\\r\\n};\\r\\n// inc de\\r\\nconst variant_13 = {\\r\\n    \\"mnemonic\\": \\"inc\\",\\r\\n    \\"params\\": [\\r\\n        \\"de\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"de\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        19\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"13\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 6,\\r\\n        \\"without_jump_clock_count\\": 6,\\r\\n        \\"description\\": \\"Adds one to DE.\\",\\r\\n        \\"instruction\\": \\"inc de\\"\\r\\n    }\\r\\n};\\r\\n// inc d\\r\\nconst variant_14 = {\\r\\n    \\"mnemonic\\": \\"inc\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        20\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"14\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-+V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Adds one to D.\\",\\r\\n        \\"instruction\\": \\"inc d\\"\\r\\n    }\\r\\n};\\r\\n// inc e\\r\\nconst variant_1C = {\\r\\n    \\"mnemonic\\": \\"inc\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        28\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"1C\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-+V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Adds one to E.\\",\\r\\n        \\"instruction\\": \\"inc e\\"\\r\\n    }\\r\\n};\\r\\n// inc hl\\r\\nconst variant_23 = {\\r\\n    \\"mnemonic\\": \\"inc\\",\\r\\n    \\"params\\": [\\r\\n        \\"hl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"hl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        35\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"23\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 6,\\r\\n        \\"without_jump_clock_count\\": 6,\\r\\n        \\"description\\": \\"Adds one to HL.\\",\\r\\n        \\"instruction\\": \\"inc hl\\"\\r\\n    }\\r\\n};\\r\\n// inc h\\r\\nconst variant_24 = {\\r\\n    \\"mnemonic\\": \\"inc\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        36\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"24\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-+V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Adds one to H.\\",\\r\\n        \\"instruction\\": \\"inc h\\"\\r\\n    }\\r\\n};\\r\\n// inc l\\r\\nconst variant_2C = {\\r\\n    \\"mnemonic\\": \\"inc\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        44\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"2C\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-+V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Adds one to L.\\",\\r\\n        \\"instruction\\": \\"inc l\\"\\r\\n    }\\r\\n};\\r\\n// inc sp\\r\\nconst variant_33 = {\\r\\n    \\"mnemonic\\": \\"inc\\",\\r\\n    \\"params\\": [\\r\\n        \\"sp\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"sp\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        51\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"33\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 6,\\r\\n        \\"without_jump_clock_count\\": 6,\\r\\n        \\"description\\": \\"Adds one to SP.\\",\\r\\n        \\"instruction\\": \\"inc sp\\"\\r\\n    }\\r\\n};\\r\\n// inc (hl)\\r\\nconst variant_34 = {\\r\\n    \\"mnemonic\\": \\"inc\\",\\r\\n    \\"params\\": [\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        52\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"34\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-+V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 11,\\r\\n        \\"without_jump_clock_count\\": 11,\\r\\n        \\"description\\": \\"Adds one to (HL).\\",\\r\\n        \\"instruction\\": \\"inc (hl)\\"\\r\\n    }\\r\\n};\\r\\n// inc a\\r\\nconst variant_3C = {\\r\\n    \\"mnemonic\\": \\"inc\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        60\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"3C\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-+V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Adds one to A.\\",\\r\\n        \\"instruction\\": \\"inc a\\"\\r\\n    }\\r\\n};\\r\\n// inc ix\\r\\nconst variant_DD_23 = {\\r\\n    \\"mnemonic\\": \\"inc\\",\\r\\n    \\"params\\": [\\r\\n        \\"ix\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ix\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        35\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD23\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 10,\\r\\n        \\"without_jump_clock_count\\": 10,\\r\\n        \\"description\\": \\"Adds one to IX.\\",\\r\\n        \\"instruction\\": \\"inc ix\\"\\r\\n    }\\r\\n};\\r\\n// inc ixh\\r\\nconst variant_DD_24 = {\\r\\n    \\"mnemonic\\": \\"inc\\",\\r\\n    \\"params\\": [\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        36\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD24\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-+V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Adds one to IXH.\\",\\r\\n        \\"instruction\\": \\"inc ixh\\"\\r\\n    }\\r\\n};\\r\\n// inc ixl\\r\\nconst variant_DD_2C = {\\r\\n    \\"mnemonic\\": \\"inc\\",\\r\\n    \\"params\\": [\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        44\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD2C\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-+V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Adds one to IXL.\\",\\r\\n        \\"instruction\\": \\"inc ixl\\"\\r\\n    }\\r\\n};\\r\\n// inc (ix+dd)\\r\\nconst variant_DD_34_dd = {\\r\\n    \\"mnemonic\\": \\"inc\\",\\r\\n    \\"params\\": [\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        52,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD34\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-+V+++\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Adds one to the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"inc (ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// inc iy\\r\\nconst variant_FD_23 = {\\r\\n    \\"mnemonic\\": \\"inc\\",\\r\\n    \\"params\\": [\\r\\n        \\"iy\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iy\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        35\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD23\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 10,\\r\\n        \\"without_jump_clock_count\\": 10,\\r\\n        \\"description\\": \\"Adds one to IY.\\",\\r\\n        \\"instruction\\": \\"inc iy\\"\\r\\n    }\\r\\n};\\r\\n// inc iyh\\r\\nconst variant_FD_24 = {\\r\\n    \\"mnemonic\\": \\"inc\\",\\r\\n    \\"params\\": [\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        36\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD24\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-+V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Adds one to IYH.\\",\\r\\n        \\"instruction\\": \\"inc iyh\\"\\r\\n    }\\r\\n};\\r\\n// inc iyl\\r\\nconst variant_FD_2C = {\\r\\n    \\"mnemonic\\": \\"inc\\",\\r\\n    \\"params\\": [\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        44\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD2C\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-+V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Adds one to IYL.\\",\\r\\n        \\"instruction\\": \\"inc iyl\\"\\r\\n    }\\r\\n};\\r\\n// inc (iy+dd)\\r\\nconst variant_FD_34_dd = {\\r\\n    \\"mnemonic\\": \\"inc\\",\\r\\n    \\"params\\": [\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        52,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD34\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-+V+++\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Adds one to the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"inc (iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// dec b\\r\\nconst variant_05 = {\\r\\n    \\"mnemonic\\": \\"dec\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        5\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"05\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-+V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Subtracts one from B.\\",\\r\\n        \\"instruction\\": \\"dec b\\"\\r\\n    }\\r\\n};\\r\\n// dec bc\\r\\nconst variant_0B = {\\r\\n    \\"mnemonic\\": \\"dec\\",\\r\\n    \\"params\\": [\\r\\n        \\"bc\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"bc\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        11\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"0B\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 6,\\r\\n        \\"without_jump_clock_count\\": 6,\\r\\n        \\"description\\": \\"Subtracts one from BC.\\",\\r\\n        \\"instruction\\": \\"dec bc\\"\\r\\n    }\\r\\n};\\r\\n// dec c\\r\\nconst variant_0D = {\\r\\n    \\"mnemonic\\": \\"dec\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        13\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"0D\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-+V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Subtracts one from C.\\",\\r\\n        \\"instruction\\": \\"dec c\\"\\r\\n    }\\r\\n};\\r\\n// dec d\\r\\nconst variant_15 = {\\r\\n    \\"mnemonic\\": \\"dec\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        21\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"15\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-+V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Subtracts one from D.\\",\\r\\n        \\"instruction\\": \\"dec d\\"\\r\\n    }\\r\\n};\\r\\n// dec de\\r\\nconst variant_1B = {\\r\\n    \\"mnemonic\\": \\"dec\\",\\r\\n    \\"params\\": [\\r\\n        \\"de\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"de\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        27\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"1B\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 6,\\r\\n        \\"without_jump_clock_count\\": 6,\\r\\n        \\"description\\": \\"Subtracts one from DE.\\",\\r\\n        \\"instruction\\": \\"dec de\\"\\r\\n    }\\r\\n};\\r\\n// dec e\\r\\nconst variant_1D = {\\r\\n    \\"mnemonic\\": \\"dec\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        29\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"1D\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-+V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Subtracts one from E.\\",\\r\\n        \\"instruction\\": \\"dec e\\"\\r\\n    }\\r\\n};\\r\\n// dec h\\r\\nconst variant_25 = {\\r\\n    \\"mnemonic\\": \\"dec\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        37\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"25\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-+V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Subtracts one from H.\\",\\r\\n        \\"instruction\\": \\"dec h\\"\\r\\n    }\\r\\n};\\r\\n// dec hl\\r\\nconst variant_2B = {\\r\\n    \\"mnemonic\\": \\"dec\\",\\r\\n    \\"params\\": [\\r\\n        \\"hl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"hl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        43\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"2B\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 6,\\r\\n        \\"without_jump_clock_count\\": 6,\\r\\n        \\"description\\": \\"Subtracts one from HL.\\",\\r\\n        \\"instruction\\": \\"dec hl\\"\\r\\n    }\\r\\n};\\r\\n// dec l\\r\\nconst variant_2D = {\\r\\n    \\"mnemonic\\": \\"dec\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        45\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"2D\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-+V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Subtracts one from L.\\",\\r\\n        \\"instruction\\": \\"dec l\\"\\r\\n    }\\r\\n};\\r\\n// dec (hl)\\r\\nconst variant_35 = {\\r\\n    \\"mnemonic\\": \\"dec\\",\\r\\n    \\"params\\": [\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        53\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"35\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-+V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 11,\\r\\n        \\"without_jump_clock_count\\": 11,\\r\\n        \\"description\\": \\"Subtracts one from (HL).\\",\\r\\n        \\"instruction\\": \\"dec (hl)\\"\\r\\n    }\\r\\n};\\r\\n// dec sp\\r\\nconst variant_3B = {\\r\\n    \\"mnemonic\\": \\"dec\\",\\r\\n    \\"params\\": [\\r\\n        \\"sp\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"sp\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        59\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"3B\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 6,\\r\\n        \\"without_jump_clock_count\\": 6,\\r\\n        \\"description\\": \\"Subtracts one from SP.\\",\\r\\n        \\"instruction\\": \\"dec sp\\"\\r\\n    }\\r\\n};\\r\\n// dec a\\r\\nconst variant_3D = {\\r\\n    \\"mnemonic\\": \\"dec\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        61\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"3D\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-+V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Subtracts one from A.\\",\\r\\n        \\"instruction\\": \\"dec a\\"\\r\\n    }\\r\\n};\\r\\n// dec ixh\\r\\nconst variant_DD_25 = {\\r\\n    \\"mnemonic\\": \\"dec\\",\\r\\n    \\"params\\": [\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        37\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD25\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-+V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Subtracts one from IXH.\\",\\r\\n        \\"instruction\\": \\"dec ixh\\"\\r\\n    }\\r\\n};\\r\\n// dec ix\\r\\nconst variant_DD_2B = {\\r\\n    \\"mnemonic\\": \\"dec\\",\\r\\n    \\"params\\": [\\r\\n        \\"ix\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ix\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        43\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD2B\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 10,\\r\\n        \\"without_jump_clock_count\\": 10,\\r\\n        \\"description\\": \\"Subtracts one from IX.\\",\\r\\n        \\"instruction\\": \\"dec ix\\"\\r\\n    }\\r\\n};\\r\\n// dec ixl\\r\\nconst variant_DD_2D = {\\r\\n    \\"mnemonic\\": \\"dec\\",\\r\\n    \\"params\\": [\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        45\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD2D\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-+V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Subtracts one from IXL.\\",\\r\\n        \\"instruction\\": \\"dec ixl\\"\\r\\n    }\\r\\n};\\r\\n// dec (ix+dd)\\r\\nconst variant_DD_35_dd = {\\r\\n    \\"mnemonic\\": \\"dec\\",\\r\\n    \\"params\\": [\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        53,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD35\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-+V+++\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Subtracts one from the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"dec (ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// dec iyh\\r\\nconst variant_FD_25 = {\\r\\n    \\"mnemonic\\": \\"dec\\",\\r\\n    \\"params\\": [\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        37\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD25\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-+V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Subtracts one from IYH.\\",\\r\\n        \\"instruction\\": \\"dec iyh\\"\\r\\n    }\\r\\n};\\r\\n// dec iy\\r\\nconst variant_FD_2B = {\\r\\n    \\"mnemonic\\": \\"dec\\",\\r\\n    \\"params\\": [\\r\\n        \\"iy\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iy\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        43\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD2B\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 10,\\r\\n        \\"without_jump_clock_count\\": 10,\\r\\n        \\"description\\": \\"Subtracts one from IY.\\",\\r\\n        \\"instruction\\": \\"dec iy\\"\\r\\n    }\\r\\n};\\r\\n// dec iyl\\r\\nconst variant_FD_2D = {\\r\\n    \\"mnemonic\\": \\"dec\\",\\r\\n    \\"params\\": [\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        45\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD2D\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-+V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Subtracts one from IYL.\\",\\r\\n        \\"instruction\\": \\"dec iyl\\"\\r\\n    }\\r\\n};\\r\\n// dec (iy+dd)\\r\\nconst variant_FD_35_dd = {\\r\\n    \\"mnemonic\\": \\"dec\\",\\r\\n    \\"params\\": [\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        53,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD35\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-+V+++\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Subtracts one from the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"dec (iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// rlca\\r\\nconst variant_07 = {\\r\\n    \\"mnemonic\\": \\"rlca\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        7\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"07\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0-0--\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of A are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0.\\",\\r\\n        \\"instruction\\": \\"rlca\\"\\r\\n    }\\r\\n};\\r\\n// ex af,af\'\\r\\nconst variant_08 = {\\r\\n    \\"mnemonic\\": \\"ex\\",\\r\\n    \\"params\\": [\\r\\n        \\"af\\",\\r\\n        \\"af\'\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"af\\",\\r\\n        \\",\\",\\r\\n        \\"af\'\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        8\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"08\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Exchanges the 16-bit contents of AF and AF\'.\\",\\r\\n        \\"instruction\\": \\"ex af,af\'\\"\\r\\n    }\\r\\n};\\r\\n// ex (sp),ix\\r\\nconst variant_DD_E3 = {\\r\\n    \\"mnemonic\\": \\"ex\\",\\r\\n    \\"params\\": [\\r\\n        \\"(sp)\\",\\r\\n        \\"ix\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"sp\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"ix\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        227\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDE3\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Exchanges (SP) with the IXL, and (SP+1) with the IXH.\\",\\r\\n        \\"instruction\\": \\"ex (sp),ix\\"\\r\\n    }\\r\\n};\\r\\n// ex (sp),hl\\r\\nconst variant_E3 = {\\r\\n    \\"mnemonic\\": \\"ex\\",\\r\\n    \\"params\\": [\\r\\n        \\"(sp)\\",\\r\\n        \\"hl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"sp\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"hl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        227\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"E3\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Exchanges (SP) with L, and (SP+1) with H.\\",\\r\\n        \\"instruction\\": \\"ex (sp),hl\\"\\r\\n    }\\r\\n};\\r\\n// ex de,hl\\r\\nconst variant_EB = {\\r\\n    \\"mnemonic\\": \\"ex\\",\\r\\n    \\"params\\": [\\r\\n        \\"de\\",\\r\\n        \\"hl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"de\\",\\r\\n        \\",\\",\\r\\n        \\"hl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        235\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"EB\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Exchanges the 16-bit contents of DE and HL.\\",\\r\\n        \\"instruction\\": \\"ex de,hl\\"\\r\\n    }\\r\\n};\\r\\n// ex (sp),iy\\r\\nconst variant_FD_E3 = {\\r\\n    \\"mnemonic\\": \\"ex\\",\\r\\n    \\"params\\": [\\r\\n        \\"(sp)\\",\\r\\n        \\"iy\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"sp\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"iy\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        227\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDE3\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Exchanges (SP) with the IYL, and (SP+1) with the IYH.\\",\\r\\n        \\"instruction\\": \\"ex (sp),iy\\"\\r\\n    }\\r\\n};\\r\\n// add hl,bc\\r\\nconst variant_09 = {\\r\\n    \\"mnemonic\\": \\"add\\",\\r\\n    \\"params\\": [\\r\\n        \\"hl\\",\\r\\n        \\"bc\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"hl\\",\\r\\n        \\",\\",\\r\\n        \\"bc\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        9\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"09\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++-+--\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 11,\\r\\n        \\"without_jump_clock_count\\": 11,\\r\\n        \\"description\\": \\"The value of BC is added to HL.\\",\\r\\n        \\"instruction\\": \\"add hl,bc\\"\\r\\n    }\\r\\n};\\r\\n// add hl,de\\r\\nconst variant_19 = {\\r\\n    \\"mnemonic\\": \\"add\\",\\r\\n    \\"params\\": [\\r\\n        \\"hl\\",\\r\\n        \\"de\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"hl\\",\\r\\n        \\",\\",\\r\\n        \\"de\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        25\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"19\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++-+--\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 11,\\r\\n        \\"without_jump_clock_count\\": 11,\\r\\n        \\"description\\": \\"The value of DE is added to HL.\\",\\r\\n        \\"instruction\\": \\"add hl,de\\"\\r\\n    }\\r\\n};\\r\\n// add hl,hl\\r\\nconst variant_29 = {\\r\\n    \\"mnemonic\\": \\"add\\",\\r\\n    \\"params\\": [\\r\\n        \\"hl\\",\\r\\n        \\"hl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"hl\\",\\r\\n        \\",\\",\\r\\n        \\"hl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        41\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"29\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++-+--\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 11,\\r\\n        \\"without_jump_clock_count\\": 11,\\r\\n        \\"description\\": \\"The value of HL is added to HL.\\",\\r\\n        \\"instruction\\": \\"add hl,hl\\"\\r\\n    }\\r\\n};\\r\\n// add hl,sp\\r\\nconst variant_39 = {\\r\\n    \\"mnemonic\\": \\"add\\",\\r\\n    \\"params\\": [\\r\\n        \\"hl\\",\\r\\n        \\"sp\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"hl\\",\\r\\n        \\",\\",\\r\\n        \\"sp\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        57\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"39\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++-+--\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 11,\\r\\n        \\"without_jump_clock_count\\": 11,\\r\\n        \\"description\\": \\"The value of HL is added to HL.\\",\\r\\n        \\"instruction\\": \\"add hl,sp\\"\\r\\n    }\\r\\n};\\r\\n// add a,b\\r\\nconst variant_80 = {\\r\\n    \\"mnemonic\\": \\"add\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        128\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"80\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Adds B to A.\\",\\r\\n        \\"instruction\\": \\"add a,b\\"\\r\\n    }\\r\\n};\\r\\n// add b\\r\\nconst variant_80_pseudo = {\\r\\n    \\"mnemonic\\": \\"add\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        128\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"80\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Adds B to A.\\",\\r\\n        \\"instruction\\": \\"add a,b\\"\\r\\n    }\\r\\n};\\r\\n// add a,c\\r\\nconst variant_81 = {\\r\\n    \\"mnemonic\\": \\"add\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        129\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"81\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Adds C to A.\\",\\r\\n        \\"instruction\\": \\"add a,c\\"\\r\\n    }\\r\\n};\\r\\n// add c\\r\\nconst variant_81_pseudo = {\\r\\n    \\"mnemonic\\": \\"add\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        129\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"81\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Adds C to A.\\",\\r\\n        \\"instruction\\": \\"add a,c\\"\\r\\n    }\\r\\n};\\r\\n// add a,d\\r\\nconst variant_82 = {\\r\\n    \\"mnemonic\\": \\"add\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        130\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"82\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Adds D to A.\\",\\r\\n        \\"instruction\\": \\"add a,d\\"\\r\\n    }\\r\\n};\\r\\n// add d\\r\\nconst variant_82_pseudo = {\\r\\n    \\"mnemonic\\": \\"add\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        130\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"82\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Adds D to A.\\",\\r\\n        \\"instruction\\": \\"add a,d\\"\\r\\n    }\\r\\n};\\r\\n// add a,e\\r\\nconst variant_83 = {\\r\\n    \\"mnemonic\\": \\"add\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        131\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"83\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Adds E to A.\\",\\r\\n        \\"instruction\\": \\"add a,e\\"\\r\\n    }\\r\\n};\\r\\n// add e\\r\\nconst variant_83_pseudo = {\\r\\n    \\"mnemonic\\": \\"add\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        131\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"83\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Adds E to A.\\",\\r\\n        \\"instruction\\": \\"add a,e\\"\\r\\n    }\\r\\n};\\r\\n// add a,h\\r\\nconst variant_84 = {\\r\\n    \\"mnemonic\\": \\"add\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        132\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"84\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Adds H to A.\\",\\r\\n        \\"instruction\\": \\"add a,h\\"\\r\\n    }\\r\\n};\\r\\n// add h\\r\\nconst variant_84_pseudo = {\\r\\n    \\"mnemonic\\": \\"add\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        132\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"84\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Adds H to A.\\",\\r\\n        \\"instruction\\": \\"add a,h\\"\\r\\n    }\\r\\n};\\r\\n// add a,l\\r\\nconst variant_85 = {\\r\\n    \\"mnemonic\\": \\"add\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        133\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"85\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Adds L to A.\\",\\r\\n        \\"instruction\\": \\"add a,l\\"\\r\\n    }\\r\\n};\\r\\n// add l\\r\\nconst variant_85_pseudo = {\\r\\n    \\"mnemonic\\": \\"add\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        133\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"85\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Adds L to A.\\",\\r\\n        \\"instruction\\": \\"add a,l\\"\\r\\n    }\\r\\n};\\r\\n// add a,(hl)\\r\\nconst variant_86 = {\\r\\n    \\"mnemonic\\": \\"add\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        134\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"86\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"Adds (HL) to A.\\",\\r\\n        \\"instruction\\": \\"add a,(hl)\\"\\r\\n    }\\r\\n};\\r\\n// add (hl)\\r\\nconst variant_86_pseudo = {\\r\\n    \\"mnemonic\\": \\"add\\",\\r\\n    \\"params\\": [\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        134\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"86\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"Adds (HL) to A.\\",\\r\\n        \\"instruction\\": \\"add a,(hl)\\"\\r\\n    }\\r\\n};\\r\\n// add a,a\\r\\nconst variant_87 = {\\r\\n    \\"mnemonic\\": \\"add\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        135\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"87\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Adds A to A.\\",\\r\\n        \\"instruction\\": \\"add a,a\\"\\r\\n    }\\r\\n};\\r\\n// add a\\r\\nconst variant_87_pseudo = {\\r\\n    \\"mnemonic\\": \\"add\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        135\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"87\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Adds A to A.\\",\\r\\n        \\"instruction\\": \\"add a,a\\"\\r\\n    }\\r\\n};\\r\\n// add a,nn\\r\\nconst variant_C6_nn = {\\r\\n    \\"mnemonic\\": \\"add\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        198,\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"C6\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"Adds * to A.\\",\\r\\n        \\"instruction\\": \\"add a,*\\"\\r\\n    }\\r\\n};\\r\\n// add nn\\r\\nconst variant_C6_nn_pseudo = {\\r\\n    \\"mnemonic\\": \\"add\\",\\r\\n    \\"params\\": [\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        198,\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"C6\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"Adds * to A.\\",\\r\\n        \\"instruction\\": \\"add a,*\\"\\r\\n    }\\r\\n};\\r\\n// add ix,bc\\r\\nconst variant_DD_09 = {\\r\\n    \\"mnemonic\\": \\"add\\",\\r\\n    \\"params\\": [\\r\\n        \\"ix\\",\\r\\n        \\"bc\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ix\\",\\r\\n        \\",\\",\\r\\n        \\"bc\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        9\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD09\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++-+--\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 15,\\r\\n        \\"without_jump_clock_count\\": 15,\\r\\n        \\"description\\": \\"The value of BC is added to IX.\\",\\r\\n        \\"instruction\\": \\"add ix,bc\\"\\r\\n    }\\r\\n};\\r\\n// add ix,de\\r\\nconst variant_DD_19 = {\\r\\n    \\"mnemonic\\": \\"add\\",\\r\\n    \\"params\\": [\\r\\n        \\"ix\\",\\r\\n        \\"de\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ix\\",\\r\\n        \\",\\",\\r\\n        \\"de\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        25\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD19\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++-+--\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 15,\\r\\n        \\"without_jump_clock_count\\": 15,\\r\\n        \\"description\\": \\"The value of DE is added to IX.\\",\\r\\n        \\"instruction\\": \\"add ix,de\\"\\r\\n    }\\r\\n};\\r\\n// add ix,ix\\r\\nconst variant_DD_29 = {\\r\\n    \\"mnemonic\\": \\"add\\",\\r\\n    \\"params\\": [\\r\\n        \\"ix\\",\\r\\n        \\"ix\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ix\\",\\r\\n        \\",\\",\\r\\n        \\"ix\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        41\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD29\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++-+--\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 15,\\r\\n        \\"without_jump_clock_count\\": 15,\\r\\n        \\"description\\": \\"The value of IX is added to IX.\\",\\r\\n        \\"instruction\\": \\"add ix,ix\\"\\r\\n    }\\r\\n};\\r\\n// add ix,sp\\r\\nconst variant_DD_39 = {\\r\\n    \\"mnemonic\\": \\"add\\",\\r\\n    \\"params\\": [\\r\\n        \\"ix\\",\\r\\n        \\"sp\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ix\\",\\r\\n        \\",\\",\\r\\n        \\"sp\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        57\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD39\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++-+--\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 15,\\r\\n        \\"without_jump_clock_count\\": 15,\\r\\n        \\"description\\": \\"The value of SP is added to IX.\\",\\r\\n        \\"instruction\\": \\"add ix,sp\\"\\r\\n    }\\r\\n};\\r\\n// add a,ixh\\r\\nconst variant_DD_84 = {\\r\\n    \\"mnemonic\\": \\"add\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        132\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD84\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Adds IXH to A.\\",\\r\\n        \\"instruction\\": \\"add a,ixh\\"\\r\\n    }\\r\\n};\\r\\n// add ixh\\r\\nconst variant_DD_84_pseudo = {\\r\\n    \\"mnemonic\\": \\"add\\",\\r\\n    \\"params\\": [\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        132\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD84\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Adds IXH to A.\\",\\r\\n        \\"instruction\\": \\"add a,ixh\\"\\r\\n    }\\r\\n};\\r\\n// add a,ixl\\r\\nconst variant_DD_85 = {\\r\\n    \\"mnemonic\\": \\"add\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        133\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD85\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Adds IXL to A.\\",\\r\\n        \\"instruction\\": \\"add a,ixl\\"\\r\\n    }\\r\\n};\\r\\n// add ixl\\r\\nconst variant_DD_85_pseudo = {\\r\\n    \\"mnemonic\\": \\"add\\",\\r\\n    \\"params\\": [\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        133\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD85\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Adds IXL to A.\\",\\r\\n        \\"instruction\\": \\"add a,ixl\\"\\r\\n    }\\r\\n};\\r\\n// add a,(ix+dd)\\r\\nconst variant_DD_86_dd = {\\r\\n    \\"mnemonic\\": \\"add\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        134,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD86\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Adds the value pointed to by IX plus * to A.\\",\\r\\n        \\"instruction\\": \\"add a,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// add (ix+dd)\\r\\nconst variant_DD_86_dd_pseudo = {\\r\\n    \\"mnemonic\\": \\"add\\",\\r\\n    \\"params\\": [\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        134,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD86\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Adds the value pointed to by IX plus * to A.\\",\\r\\n        \\"instruction\\": \\"add a,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// add iy,bc\\r\\nconst variant_FD_09 = {\\r\\n    \\"mnemonic\\": \\"add\\",\\r\\n    \\"params\\": [\\r\\n        \\"iy\\",\\r\\n        \\"bc\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iy\\",\\r\\n        \\",\\",\\r\\n        \\"bc\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        9\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD09\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++-+--\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 15,\\r\\n        \\"without_jump_clock_count\\": 15,\\r\\n        \\"description\\": \\"The value of BC is added to IY.\\",\\r\\n        \\"instruction\\": \\"add iy,bc\\"\\r\\n    }\\r\\n};\\r\\n// add iy,de\\r\\nconst variant_FD_19 = {\\r\\n    \\"mnemonic\\": \\"add\\",\\r\\n    \\"params\\": [\\r\\n        \\"iy\\",\\r\\n        \\"de\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iy\\",\\r\\n        \\",\\",\\r\\n        \\"de\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        25\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD19\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++-+--\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 15,\\r\\n        \\"without_jump_clock_count\\": 15,\\r\\n        \\"description\\": \\"The value of DE is added to IY.\\",\\r\\n        \\"instruction\\": \\"add iy,de\\"\\r\\n    }\\r\\n};\\r\\n// add iy,iy\\r\\nconst variant_FD_29 = {\\r\\n    \\"mnemonic\\": \\"add\\",\\r\\n    \\"params\\": [\\r\\n        \\"iy\\",\\r\\n        \\"iy\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iy\\",\\r\\n        \\",\\",\\r\\n        \\"iy\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        41\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD29\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++-+--\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 15,\\r\\n        \\"without_jump_clock_count\\": 15,\\r\\n        \\"description\\": \\"The value of IX is added to IY.\\",\\r\\n        \\"instruction\\": \\"add iy,iy\\"\\r\\n    }\\r\\n};\\r\\n// add iy,sp\\r\\nconst variant_FD_39 = {\\r\\n    \\"mnemonic\\": \\"add\\",\\r\\n    \\"params\\": [\\r\\n        \\"iy\\",\\r\\n        \\"sp\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iy\\",\\r\\n        \\",\\",\\r\\n        \\"sp\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        57\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD39\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++-+--\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 15,\\r\\n        \\"without_jump_clock_count\\": 15,\\r\\n        \\"description\\": \\"The value of SP is added to IY.\\",\\r\\n        \\"instruction\\": \\"add iy,sp\\"\\r\\n    }\\r\\n};\\r\\n// add a,iyh\\r\\nconst variant_FD_84 = {\\r\\n    \\"mnemonic\\": \\"add\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        132\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD84\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Adds IYH to A.\\",\\r\\n        \\"instruction\\": \\"add a,iyh\\"\\r\\n    }\\r\\n};\\r\\n// add iyh\\r\\nconst variant_FD_84_pseudo = {\\r\\n    \\"mnemonic\\": \\"add\\",\\r\\n    \\"params\\": [\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        132\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD84\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Adds IYH to A.\\",\\r\\n        \\"instruction\\": \\"add a,iyh\\"\\r\\n    }\\r\\n};\\r\\n// add a,iyl\\r\\nconst variant_FD_85 = {\\r\\n    \\"mnemonic\\": \\"add\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        133\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD85\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Adds IYL to A.\\",\\r\\n        \\"instruction\\": \\"add a,iyl\\"\\r\\n    }\\r\\n};\\r\\n// add iyl\\r\\nconst variant_FD_85_pseudo = {\\r\\n    \\"mnemonic\\": \\"add\\",\\r\\n    \\"params\\": [\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        133\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD85\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Adds IYL to A.\\",\\r\\n        \\"instruction\\": \\"add a,iyl\\"\\r\\n    }\\r\\n};\\r\\n// add a,(iy+dd)\\r\\nconst variant_FD_86_dd = {\\r\\n    \\"mnemonic\\": \\"add\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        134,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD86\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Adds the value pointed to by IY plus * to A.\\",\\r\\n        \\"instruction\\": \\"add a,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// add (iy+dd)\\r\\nconst variant_FD_86_dd_pseudo = {\\r\\n    \\"mnemonic\\": \\"add\\",\\r\\n    \\"params\\": [\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        134,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD86\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Adds the value pointed to by IY plus * to A.\\",\\r\\n        \\"instruction\\": \\"add a,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// rrca\\r\\nconst variant_0F = {\\r\\n    \\"mnemonic\\": \\"rrca\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        15\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"0F\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0-0--\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of A are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7.\\",\\r\\n        \\"instruction\\": \\"rrca\\"\\r\\n    }\\r\\n};\\r\\n// djnz offset\\r\\nconst variant_10_offset = {\\r\\n    \\"mnemonic\\": \\"djnz\\",\\r\\n    \\"params\\": [\\r\\n        \\"offset\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"offset\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        16,\\r\\n        \\"offset\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"10\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 13,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The B register is decremented, and if not zero, the signed value * is added to PC. The jump is measured from the start of the instruction opcode.\\",\\r\\n        \\"instruction\\": \\"djnz *\\"\\r\\n    }\\r\\n};\\r\\n// rla\\r\\nconst variant_17 = {\\r\\n    \\"mnemonic\\": \\"rla\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        23\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"17\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0-0--\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of A are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0.\\",\\r\\n        \\"instruction\\": \\"rla\\"\\r\\n    }\\r\\n};\\r\\n// jr offset\\r\\nconst variant_18_offset = {\\r\\n    \\"mnemonic\\": \\"jr\\",\\r\\n    \\"params\\": [\\r\\n        \\"offset\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"offset\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        24,\\r\\n        \\"offset\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"18\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 12,\\r\\n        \\"without_jump_clock_count\\": 12,\\r\\n        \\"description\\": \\"The signed value * is added to PC. The jump is measured from the start of the instruction opcode.\\",\\r\\n        \\"instruction\\": \\"jr *\\"\\r\\n    }\\r\\n};\\r\\n// jr nz,offset\\r\\nconst variant_20_offset = {\\r\\n    \\"mnemonic\\": \\"jr\\",\\r\\n    \\"params\\": [\\r\\n        \\"nz\\",\\r\\n        \\"offset\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"nz\\",\\r\\n        \\",\\",\\r\\n        \\"offset\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        32,\\r\\n        \\"offset\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"20\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 12,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"If condition CC is true, the signed value * is added to PC. The jump is measured from the start of the instruction opcode.\\",\\r\\n        \\"instruction\\": \\"jr nz,*\\"\\r\\n    }\\r\\n};\\r\\n// jr z,offset\\r\\nconst variant_28_offset = {\\r\\n    \\"mnemonic\\": \\"jr\\",\\r\\n    \\"params\\": [\\r\\n        \\"z\\",\\r\\n        \\"offset\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"z\\",\\r\\n        \\",\\",\\r\\n        \\"offset\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        40,\\r\\n        \\"offset\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"28\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 12,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"If condition CC is true, the signed value * is added to PC. The jump is measured from the start of the instruction opcode.\\",\\r\\n        \\"instruction\\": \\"jr z,*\\"\\r\\n    }\\r\\n};\\r\\n// jr nc,offset\\r\\nconst variant_30_offset = {\\r\\n    \\"mnemonic\\": \\"jr\\",\\r\\n    \\"params\\": [\\r\\n        \\"nc\\",\\r\\n        \\"offset\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"nc\\",\\r\\n        \\",\\",\\r\\n        \\"offset\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        48,\\r\\n        \\"offset\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"30\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 12,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"If condition CC is true, the signed value * is added to PC. The jump is measured from the start of the instruction opcode.\\",\\r\\n        \\"instruction\\": \\"jr nc,*\\"\\r\\n    }\\r\\n};\\r\\n// jr c,offset\\r\\nconst variant_38_offset = {\\r\\n    \\"mnemonic\\": \\"jr\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"offset\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"offset\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        56,\\r\\n        \\"offset\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"38\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 12,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"If condition CC is true, the signed value * is added to PC. The jump is measured from the start of the instruction opcode.\\",\\r\\n        \\"instruction\\": \\"jr c,*\\"\\r\\n    }\\r\\n};\\r\\n// rra\\r\\nconst variant_1F = {\\r\\n    \\"mnemonic\\": \\"rra\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        31\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"1F\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0-0--\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of A are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7.\\",\\r\\n        \\"instruction\\": \\"rra\\"\\r\\n    }\\r\\n};\\r\\n// daa\\r\\nconst variant_27 = {\\r\\n    \\"mnemonic\\": \\"daa\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        39\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"27\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"*-P*++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Adjusts A for BCD addition and subtraction operations.\\",\\r\\n        \\"instruction\\": \\"daa\\"\\r\\n    }\\r\\n};\\r\\n// cpl\\r\\nconst variant_2F = {\\r\\n    \\"mnemonic\\": \\"cpl\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        47\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"2F\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-1-1--\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"The contents of A are inverted (one\'s complement).\\",\\r\\n        \\"instruction\\": \\"cpl\\"\\r\\n    }\\r\\n};\\r\\n// scf\\r\\nconst variant_37 = {\\r\\n    \\"mnemonic\\": \\"scf\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        55\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"37\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"10-0--\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Sets the carry flag.\\",\\r\\n        \\"instruction\\": \\"scf\\"\\r\\n    }\\r\\n};\\r\\n// ccf\\r\\nconst variant_3F = {\\r\\n    \\"mnemonic\\": \\"ccf\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        63\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"3F\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"*0-*--\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Inverts the carry flag.\\",\\r\\n        \\"instruction\\": \\"ccf\\"\\r\\n    }\\r\\n};\\r\\n// halt\\r\\nconst variant_76 = {\\r\\n    \\"mnemonic\\": \\"halt\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        118\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"76\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Suspends CPU operation until an interrupt or reset occurs.\\",\\r\\n        \\"instruction\\": \\"halt\\"\\r\\n    }\\r\\n};\\r\\n// adc a,b\\r\\nconst variant_88 = {\\r\\n    \\"mnemonic\\": \\"adc\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        136\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"88\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Adds B and the carry flag to A.\\",\\r\\n        \\"instruction\\": \\"adc a,b\\"\\r\\n    }\\r\\n};\\r\\n// adc b\\r\\nconst variant_88_pseudo = {\\r\\n    \\"mnemonic\\": \\"adc\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        136\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"88\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Adds B and the carry flag to A.\\",\\r\\n        \\"instruction\\": \\"adc a,b\\"\\r\\n    }\\r\\n};\\r\\n// adc a,c\\r\\nconst variant_89 = {\\r\\n    \\"mnemonic\\": \\"adc\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        137\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"89\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Adds C and the carry flag to A.\\",\\r\\n        \\"instruction\\": \\"adc a,c\\"\\r\\n    }\\r\\n};\\r\\n// adc c\\r\\nconst variant_89_pseudo = {\\r\\n    \\"mnemonic\\": \\"adc\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        137\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"89\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Adds C and the carry flag to A.\\",\\r\\n        \\"instruction\\": \\"adc a,c\\"\\r\\n    }\\r\\n};\\r\\n// adc a,d\\r\\nconst variant_8A = {\\r\\n    \\"mnemonic\\": \\"adc\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        138\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"8A\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Adds D and the carry flag to A.\\",\\r\\n        \\"instruction\\": \\"adc a,d\\"\\r\\n    }\\r\\n};\\r\\n// adc d\\r\\nconst variant_8A_pseudo = {\\r\\n    \\"mnemonic\\": \\"adc\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        138\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"8A\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Adds D and the carry flag to A.\\",\\r\\n        \\"instruction\\": \\"adc a,d\\"\\r\\n    }\\r\\n};\\r\\n// adc a,e\\r\\nconst variant_8B = {\\r\\n    \\"mnemonic\\": \\"adc\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        139\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"8B\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Adds E and the carry flag to A.\\",\\r\\n        \\"instruction\\": \\"adc a,e\\"\\r\\n    }\\r\\n};\\r\\n// adc e\\r\\nconst variant_8B_pseudo = {\\r\\n    \\"mnemonic\\": \\"adc\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        139\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"8B\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Adds E and the carry flag to A.\\",\\r\\n        \\"instruction\\": \\"adc a,e\\"\\r\\n    }\\r\\n};\\r\\n// adc a,h\\r\\nconst variant_8C = {\\r\\n    \\"mnemonic\\": \\"adc\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        140\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"8C\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Adds H and the carry flag to A.\\",\\r\\n        \\"instruction\\": \\"adc a,h\\"\\r\\n    }\\r\\n};\\r\\n// adc h\\r\\nconst variant_8C_pseudo = {\\r\\n    \\"mnemonic\\": \\"adc\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        140\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"8C\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Adds H and the carry flag to A.\\",\\r\\n        \\"instruction\\": \\"adc a,h\\"\\r\\n    }\\r\\n};\\r\\n// adc a,l\\r\\nconst variant_8D = {\\r\\n    \\"mnemonic\\": \\"adc\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        141\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"8D\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Adds L and the carry flag to A.\\",\\r\\n        \\"instruction\\": \\"adc a,l\\"\\r\\n    }\\r\\n};\\r\\n// adc l\\r\\nconst variant_8D_pseudo = {\\r\\n    \\"mnemonic\\": \\"adc\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        141\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"8D\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Adds L and the carry flag to A.\\",\\r\\n        \\"instruction\\": \\"adc a,l\\"\\r\\n    }\\r\\n};\\r\\n// adc a,(hl)\\r\\nconst variant_8E = {\\r\\n    \\"mnemonic\\": \\"adc\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        142\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"8E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"Adds (HL) and the carry flag to A.\\",\\r\\n        \\"instruction\\": \\"adc a,(hl)\\"\\r\\n    }\\r\\n};\\r\\n// adc (hl)\\r\\nconst variant_8E_pseudo = {\\r\\n    \\"mnemonic\\": \\"adc\\",\\r\\n    \\"params\\": [\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        142\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"8E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"Adds (HL) and the carry flag to A.\\",\\r\\n        \\"instruction\\": \\"adc a,(hl)\\"\\r\\n    }\\r\\n};\\r\\n// adc a,a\\r\\nconst variant_8F = {\\r\\n    \\"mnemonic\\": \\"adc\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        143\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"8F\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Adds A and the carry flag to A.\\",\\r\\n        \\"instruction\\": \\"adc a,a\\"\\r\\n    }\\r\\n};\\r\\n// adc a\\r\\nconst variant_8F_pseudo = {\\r\\n    \\"mnemonic\\": \\"adc\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        143\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"8F\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Adds A and the carry flag to A.\\",\\r\\n        \\"instruction\\": \\"adc a,a\\"\\r\\n    }\\r\\n};\\r\\n// adc a,nn\\r\\nconst variant_CE_nn = {\\r\\n    \\"mnemonic\\": \\"adc\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        206,\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CE\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"Adds * and the carry flag to A.\\",\\r\\n        \\"instruction\\": \\"adc a,*\\"\\r\\n    }\\r\\n};\\r\\n// adc nn\\r\\nconst variant_CE_nn_pseudo = {\\r\\n    \\"mnemonic\\": \\"adc\\",\\r\\n    \\"params\\": [\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        206,\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CE\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"Adds * and the carry flag to A.\\",\\r\\n        \\"instruction\\": \\"adc a,*\\"\\r\\n    }\\r\\n};\\r\\n// adc a,ixh\\r\\nconst variant_DD_8C = {\\r\\n    \\"mnemonic\\": \\"adc\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        140\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD8C\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Adds IXH and the carry flag to A.\\",\\r\\n        \\"instruction\\": \\"adc a,ixh\\"\\r\\n    }\\r\\n};\\r\\n// adc ixh\\r\\nconst variant_DD_8C_pseudo = {\\r\\n    \\"mnemonic\\": \\"adc\\",\\r\\n    \\"params\\": [\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        140\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD8C\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Adds IXH and the carry flag to A.\\",\\r\\n        \\"instruction\\": \\"adc a,ixh\\"\\r\\n    }\\r\\n};\\r\\n// adc a,ixl\\r\\nconst variant_DD_8D = {\\r\\n    \\"mnemonic\\": \\"adc\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        141\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD8D\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Adds IXL and the carry flag to A.\\",\\r\\n        \\"instruction\\": \\"adc a,ixl\\"\\r\\n    }\\r\\n};\\r\\n// adc ixl\\r\\nconst variant_DD_8D_pseudo = {\\r\\n    \\"mnemonic\\": \\"adc\\",\\r\\n    \\"params\\": [\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        141\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD8D\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Adds IXL and the carry flag to A.\\",\\r\\n        \\"instruction\\": \\"adc a,ixl\\"\\r\\n    }\\r\\n};\\r\\n// adc a,(ix+dd)\\r\\nconst variant_DD_8E_dd = {\\r\\n    \\"mnemonic\\": \\"adc\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        142,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD8E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Adds the value pointed to by IX plus * and the carry flag to A.\\",\\r\\n        \\"instruction\\": \\"adc a,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// adc (ix+dd)\\r\\nconst variant_DD_8E_dd_pseudo = {\\r\\n    \\"mnemonic\\": \\"adc\\",\\r\\n    \\"params\\": [\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        142,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD8E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Adds the value pointed to by IX plus * and the carry flag to A.\\",\\r\\n        \\"instruction\\": \\"adc a,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// adc hl,bc\\r\\nconst variant_ED_4A = {\\r\\n    \\"mnemonic\\": \\"adc\\",\\r\\n    \\"params\\": [\\r\\n        \\"hl\\",\\r\\n        \\"bc\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"hl\\",\\r\\n        \\",\\",\\r\\n        \\"bc\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        74\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED4A\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 15,\\r\\n        \\"without_jump_clock_count\\": 15,\\r\\n        \\"description\\": \\"Adds BC and the carry flag to HL.\\",\\r\\n        \\"instruction\\": \\"adc hl,bc\\"\\r\\n    }\\r\\n};\\r\\n// adc hl,de\\r\\nconst variant_ED_5A = {\\r\\n    \\"mnemonic\\": \\"adc\\",\\r\\n    \\"params\\": [\\r\\n        \\"hl\\",\\r\\n        \\"de\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"hl\\",\\r\\n        \\",\\",\\r\\n        \\"de\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        90\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED5A\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 15,\\r\\n        \\"without_jump_clock_count\\": 15,\\r\\n        \\"description\\": \\"Adds DE and the carry flag to HL.\\",\\r\\n        \\"instruction\\": \\"adc hl,de\\"\\r\\n    }\\r\\n};\\r\\n// adc hl,hl\\r\\nconst variant_ED_6A = {\\r\\n    \\"mnemonic\\": \\"adc\\",\\r\\n    \\"params\\": [\\r\\n        \\"hl\\",\\r\\n        \\"hl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"hl\\",\\r\\n        \\",\\",\\r\\n        \\"hl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        106\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED6A\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 15,\\r\\n        \\"without_jump_clock_count\\": 15,\\r\\n        \\"description\\": \\"Adds HL and the carry flag to HL.\\",\\r\\n        \\"instruction\\": \\"adc hl,hl\\"\\r\\n    }\\r\\n};\\r\\n// adc hl,sp\\r\\nconst variant_ED_7A = {\\r\\n    \\"mnemonic\\": \\"adc\\",\\r\\n    \\"params\\": [\\r\\n        \\"hl\\",\\r\\n        \\"sp\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"hl\\",\\r\\n        \\",\\",\\r\\n        \\"sp\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        122\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED7A\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 15,\\r\\n        \\"without_jump_clock_count\\": 15,\\r\\n        \\"description\\": \\"Adds HL and the carry flag to HL.\\",\\r\\n        \\"instruction\\": \\"adc hl,sp\\"\\r\\n    }\\r\\n};\\r\\n// adc a,iyh\\r\\nconst variant_FD_8C = {\\r\\n    \\"mnemonic\\": \\"adc\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        140\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD8C\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Adds IYH and the carry flag to A.\\",\\r\\n        \\"instruction\\": \\"adc a,iyh\\"\\r\\n    }\\r\\n};\\r\\n// adc iyh\\r\\nconst variant_FD_8C_pseudo = {\\r\\n    \\"mnemonic\\": \\"adc\\",\\r\\n    \\"params\\": [\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        140\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD8C\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Adds IYH and the carry flag to A.\\",\\r\\n        \\"instruction\\": \\"adc a,iyh\\"\\r\\n    }\\r\\n};\\r\\n// adc a,iyl\\r\\nconst variant_FD_8D = {\\r\\n    \\"mnemonic\\": \\"adc\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        141\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD8D\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Adds IYL and the carry flag to A.\\",\\r\\n        \\"instruction\\": \\"adc a,iyl\\"\\r\\n    }\\r\\n};\\r\\n// adc iyl\\r\\nconst variant_FD_8D_pseudo = {\\r\\n    \\"mnemonic\\": \\"adc\\",\\r\\n    \\"params\\": [\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        141\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD8D\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Adds IYL and the carry flag to A.\\",\\r\\n        \\"instruction\\": \\"adc a,iyl\\"\\r\\n    }\\r\\n};\\r\\n// adc a,(iy+dd)\\r\\nconst variant_FD_8E_dd = {\\r\\n    \\"mnemonic\\": \\"adc\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        142,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD8E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Adds the value pointed to by IY plus * and the carry flag to A.\\",\\r\\n        \\"instruction\\": \\"adc a,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// adc (iy+dd)\\r\\nconst variant_FD_8E_dd_pseudo = {\\r\\n    \\"mnemonic\\": \\"adc\\",\\r\\n    \\"params\\": [\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        142,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD8E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Adds the value pointed to by IY plus * and the carry flag to A.\\",\\r\\n        \\"instruction\\": \\"adc a,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// sub a,b\\r\\nconst variant_90 = {\\r\\n    \\"mnemonic\\": \\"sub\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        144\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"90\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Subtracts B from A.\\",\\r\\n        \\"instruction\\": \\"sub b\\"\\r\\n    }\\r\\n};\\r\\n// sub b\\r\\nconst variant_90_pseudo = {\\r\\n    \\"mnemonic\\": \\"sub\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        144\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"90\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Subtracts B from A.\\",\\r\\n        \\"instruction\\": \\"sub b\\"\\r\\n    }\\r\\n};\\r\\n// sub a,c\\r\\nconst variant_91 = {\\r\\n    \\"mnemonic\\": \\"sub\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        145\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"91\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Subtracts C from A.\\",\\r\\n        \\"instruction\\": \\"sub c\\"\\r\\n    }\\r\\n};\\r\\n// sub c\\r\\nconst variant_91_pseudo = {\\r\\n    \\"mnemonic\\": \\"sub\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        145\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"91\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Subtracts C from A.\\",\\r\\n        \\"instruction\\": \\"sub c\\"\\r\\n    }\\r\\n};\\r\\n// sub a,d\\r\\nconst variant_92 = {\\r\\n    \\"mnemonic\\": \\"sub\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        146\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"92\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Subtracts D from A.\\",\\r\\n        \\"instruction\\": \\"sub d\\"\\r\\n    }\\r\\n};\\r\\n// sub d\\r\\nconst variant_92_pseudo = {\\r\\n    \\"mnemonic\\": \\"sub\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        146\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"92\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Subtracts D from A.\\",\\r\\n        \\"instruction\\": \\"sub d\\"\\r\\n    }\\r\\n};\\r\\n// sub a,e\\r\\nconst variant_93 = {\\r\\n    \\"mnemonic\\": \\"sub\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        147\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"93\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Subtracts E from A.\\",\\r\\n        \\"instruction\\": \\"sub e\\"\\r\\n    }\\r\\n};\\r\\n// sub e\\r\\nconst variant_93_pseudo = {\\r\\n    \\"mnemonic\\": \\"sub\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        147\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"93\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Subtracts E from A.\\",\\r\\n        \\"instruction\\": \\"sub e\\"\\r\\n    }\\r\\n};\\r\\n// sub a,h\\r\\nconst variant_94 = {\\r\\n    \\"mnemonic\\": \\"sub\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        148\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"94\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Subtracts H from A.\\",\\r\\n        \\"instruction\\": \\"sub h\\"\\r\\n    }\\r\\n};\\r\\n// sub h\\r\\nconst variant_94_pseudo = {\\r\\n    \\"mnemonic\\": \\"sub\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        148\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"94\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Subtracts H from A.\\",\\r\\n        \\"instruction\\": \\"sub h\\"\\r\\n    }\\r\\n};\\r\\n// sub a,l\\r\\nconst variant_95 = {\\r\\n    \\"mnemonic\\": \\"sub\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        149\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"95\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Subtracts L from A.\\",\\r\\n        \\"instruction\\": \\"sub l\\"\\r\\n    }\\r\\n};\\r\\n// sub l\\r\\nconst variant_95_pseudo = {\\r\\n    \\"mnemonic\\": \\"sub\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        149\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"95\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Subtracts L from A.\\",\\r\\n        \\"instruction\\": \\"sub l\\"\\r\\n    }\\r\\n};\\r\\n// sub a,(hl)\\r\\nconst variant_96 = {\\r\\n    \\"mnemonic\\": \\"sub\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        150\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"96\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"Subtracts (HL) from A.\\",\\r\\n        \\"instruction\\": \\"sub (hl)\\"\\r\\n    }\\r\\n};\\r\\n// sub (hl)\\r\\nconst variant_96_pseudo = {\\r\\n    \\"mnemonic\\": \\"sub\\",\\r\\n    \\"params\\": [\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        150\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"96\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"Subtracts (HL) from A.\\",\\r\\n        \\"instruction\\": \\"sub (hl)\\"\\r\\n    }\\r\\n};\\r\\n// sub a,a\\r\\nconst variant_97 = {\\r\\n    \\"mnemonic\\": \\"sub\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        151\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"97\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Subtracts A from A.\\",\\r\\n        \\"instruction\\": \\"sub a\\"\\r\\n    }\\r\\n};\\r\\n// sub a\\r\\nconst variant_97_pseudo = {\\r\\n    \\"mnemonic\\": \\"sub\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        151\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"97\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Subtracts A from A.\\",\\r\\n        \\"instruction\\": \\"sub a\\"\\r\\n    }\\r\\n};\\r\\n// sub a,nn\\r\\nconst variant_D6_nn = {\\r\\n    \\"mnemonic\\": \\"sub\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        214,\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"D6\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"Subtracts * from A.\\",\\r\\n        \\"instruction\\": \\"sub *\\"\\r\\n    }\\r\\n};\\r\\n// sub nn\\r\\nconst variant_D6_nn_pseudo = {\\r\\n    \\"mnemonic\\": \\"sub\\",\\r\\n    \\"params\\": [\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        214,\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"D6\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"Subtracts * from A.\\",\\r\\n        \\"instruction\\": \\"sub *\\"\\r\\n    }\\r\\n};\\r\\n// sub a,ixh\\r\\nconst variant_DD_94 = {\\r\\n    \\"mnemonic\\": \\"sub\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        148\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD94\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Subtracts IXH from A.\\",\\r\\n        \\"instruction\\": \\"sub ixh\\"\\r\\n    }\\r\\n};\\r\\n// sub ixh\\r\\nconst variant_DD_94_pseudo = {\\r\\n    \\"mnemonic\\": \\"sub\\",\\r\\n    \\"params\\": [\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        148\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD94\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Subtracts IXH from A.\\",\\r\\n        \\"instruction\\": \\"sub ixh\\"\\r\\n    }\\r\\n};\\r\\n// sub a,ixl\\r\\nconst variant_DD_95 = {\\r\\n    \\"mnemonic\\": \\"sub\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        149\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD95\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Subtracts IXL from A.\\",\\r\\n        \\"instruction\\": \\"sub ixl\\"\\r\\n    }\\r\\n};\\r\\n// sub ixl\\r\\nconst variant_DD_95_pseudo = {\\r\\n    \\"mnemonic\\": \\"sub\\",\\r\\n    \\"params\\": [\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        149\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD95\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Subtracts IXL from A.\\",\\r\\n        \\"instruction\\": \\"sub ixl\\"\\r\\n    }\\r\\n};\\r\\n// sub a,(ix+dd)\\r\\nconst variant_DD_96_dd = {\\r\\n    \\"mnemonic\\": \\"sub\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        150,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD96\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Subtracts the value pointed to by IX plus * from A.\\",\\r\\n        \\"instruction\\": \\"sub (ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// sub (ix+dd)\\r\\nconst variant_DD_96_dd_pseudo = {\\r\\n    \\"mnemonic\\": \\"sub\\",\\r\\n    \\"params\\": [\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        150,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD96\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Subtracts the value pointed to by IX plus * from A.\\",\\r\\n        \\"instruction\\": \\"sub (ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// sub a,iyh\\r\\nconst variant_FD_94 = {\\r\\n    \\"mnemonic\\": \\"sub\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        148\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD94\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Subtracts IYH from A.\\",\\r\\n        \\"instruction\\": \\"sub iyh\\"\\r\\n    }\\r\\n};\\r\\n// sub iyh\\r\\nconst variant_FD_94_pseudo = {\\r\\n    \\"mnemonic\\": \\"sub\\",\\r\\n    \\"params\\": [\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        148\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD94\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Subtracts IYH from A.\\",\\r\\n        \\"instruction\\": \\"sub iyh\\"\\r\\n    }\\r\\n};\\r\\n// sub a,iyl\\r\\nconst variant_FD_95 = {\\r\\n    \\"mnemonic\\": \\"sub\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        149\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD95\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Subtracts IYL from A.\\",\\r\\n        \\"instruction\\": \\"sub iyl\\"\\r\\n    }\\r\\n};\\r\\n// sub iyl\\r\\nconst variant_FD_95_pseudo = {\\r\\n    \\"mnemonic\\": \\"sub\\",\\r\\n    \\"params\\": [\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        149\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD95\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Subtracts IYL from A.\\",\\r\\n        \\"instruction\\": \\"sub iyl\\"\\r\\n    }\\r\\n};\\r\\n// sub a,(iy+dd)\\r\\nconst variant_FD_96_dd = {\\r\\n    \\"mnemonic\\": \\"sub\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        150,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD96\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Subtracts the value pointed to by IY plus * from A.\\",\\r\\n        \\"instruction\\": \\"sub (iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// sub (iy+dd)\\r\\nconst variant_FD_96_dd_pseudo = {\\r\\n    \\"mnemonic\\": \\"sub\\",\\r\\n    \\"params\\": [\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        150,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD96\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Subtracts the value pointed to by IY plus * from A.\\",\\r\\n        \\"instruction\\": \\"sub (iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// sbc a,b\\r\\nconst variant_98 = {\\r\\n    \\"mnemonic\\": \\"sbc\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        152\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"98\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Subtracts B and the carry flag from A.\\",\\r\\n        \\"instruction\\": \\"sbc a,b\\"\\r\\n    }\\r\\n};\\r\\n// sbc b\\r\\nconst variant_98_pseudo = {\\r\\n    \\"mnemonic\\": \\"sbc\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        152\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"98\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Subtracts B and the carry flag from A.\\",\\r\\n        \\"instruction\\": \\"sbc a,b\\"\\r\\n    }\\r\\n};\\r\\n// sbc a,c\\r\\nconst variant_99 = {\\r\\n    \\"mnemonic\\": \\"sbc\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        153\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"99\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Subtracts C and the carry flag from A.\\",\\r\\n        \\"instruction\\": \\"sbc a,c\\"\\r\\n    }\\r\\n};\\r\\n// sbc c\\r\\nconst variant_99_pseudo = {\\r\\n    \\"mnemonic\\": \\"sbc\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        153\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"99\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Subtracts C and the carry flag from A.\\",\\r\\n        \\"instruction\\": \\"sbc a,c\\"\\r\\n    }\\r\\n};\\r\\n// sbc a,d\\r\\nconst variant_9A = {\\r\\n    \\"mnemonic\\": \\"sbc\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        154\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"9A\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Subtracts D and the carry flag from A.\\",\\r\\n        \\"instruction\\": \\"sbc a,d\\"\\r\\n    }\\r\\n};\\r\\n// sbc d\\r\\nconst variant_9A_pseudo = {\\r\\n    \\"mnemonic\\": \\"sbc\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        154\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"9A\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Subtracts D and the carry flag from A.\\",\\r\\n        \\"instruction\\": \\"sbc a,d\\"\\r\\n    }\\r\\n};\\r\\n// sbc a,e\\r\\nconst variant_9B = {\\r\\n    \\"mnemonic\\": \\"sbc\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        155\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"9B\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Subtracts E and the carry flag from A.\\",\\r\\n        \\"instruction\\": \\"sbc a,e\\"\\r\\n    }\\r\\n};\\r\\n// sbc e\\r\\nconst variant_9B_pseudo = {\\r\\n    \\"mnemonic\\": \\"sbc\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        155\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"9B\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Subtracts E and the carry flag from A.\\",\\r\\n        \\"instruction\\": \\"sbc a,e\\"\\r\\n    }\\r\\n};\\r\\n// sbc a,h\\r\\nconst variant_9C = {\\r\\n    \\"mnemonic\\": \\"sbc\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        156\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"9C\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Subtracts H and the carry flag from A.\\",\\r\\n        \\"instruction\\": \\"sbc a,h\\"\\r\\n    }\\r\\n};\\r\\n// sbc h\\r\\nconst variant_9C_pseudo = {\\r\\n    \\"mnemonic\\": \\"sbc\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        156\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"9C\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Subtracts H and the carry flag from A.\\",\\r\\n        \\"instruction\\": \\"sbc a,h\\"\\r\\n    }\\r\\n};\\r\\n// sbc a,l\\r\\nconst variant_9D = {\\r\\n    \\"mnemonic\\": \\"sbc\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        157\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"9D\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Subtracts L and the carry flag from A.\\",\\r\\n        \\"instruction\\": \\"sbc a,l\\"\\r\\n    }\\r\\n};\\r\\n// sbc l\\r\\nconst variant_9D_pseudo = {\\r\\n    \\"mnemonic\\": \\"sbc\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        157\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"9D\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Subtracts L and the carry flag from A.\\",\\r\\n        \\"instruction\\": \\"sbc a,l\\"\\r\\n    }\\r\\n};\\r\\n// sbc a,(hl)\\r\\nconst variant_9E = {\\r\\n    \\"mnemonic\\": \\"sbc\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        158\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"9E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"Subtracts (HL) and the carry flag from A.\\",\\r\\n        \\"instruction\\": \\"sbc a,(hl)\\"\\r\\n    }\\r\\n};\\r\\n// sbc (hl)\\r\\nconst variant_9E_pseudo = {\\r\\n    \\"mnemonic\\": \\"sbc\\",\\r\\n    \\"params\\": [\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        158\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"9E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"Subtracts (HL) and the carry flag from A.\\",\\r\\n        \\"instruction\\": \\"sbc a,(hl)\\"\\r\\n    }\\r\\n};\\r\\n// sbc a,a\\r\\nconst variant_9F = {\\r\\n    \\"mnemonic\\": \\"sbc\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        159\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"9F\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Subtracts A and the carry flag from A.\\",\\r\\n        \\"instruction\\": \\"sbc a,a\\"\\r\\n    }\\r\\n};\\r\\n// sbc a\\r\\nconst variant_9F_pseudo = {\\r\\n    \\"mnemonic\\": \\"sbc\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        159\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"9F\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Subtracts A and the carry flag from A.\\",\\r\\n        \\"instruction\\": \\"sbc a,a\\"\\r\\n    }\\r\\n};\\r\\n// sbc a,ixh\\r\\nconst variant_DD_9C = {\\r\\n    \\"mnemonic\\": \\"sbc\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        156\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD9C\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Subtracts IXH and the carry flag from A.\\",\\r\\n        \\"instruction\\": \\"sbc a,ixh\\"\\r\\n    }\\r\\n};\\r\\n// sbc ixh\\r\\nconst variant_DD_9C_pseudo = {\\r\\n    \\"mnemonic\\": \\"sbc\\",\\r\\n    \\"params\\": [\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        156\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD9C\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Subtracts IXH and the carry flag from A.\\",\\r\\n        \\"instruction\\": \\"sbc a,ixh\\"\\r\\n    }\\r\\n};\\r\\n// sbc a,ixl\\r\\nconst variant_DD_9D = {\\r\\n    \\"mnemonic\\": \\"sbc\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        157\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD9D\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Subtracts IXL and the carry flag from A.\\",\\r\\n        \\"instruction\\": \\"sbc a,ixl\\"\\r\\n    }\\r\\n};\\r\\n// sbc ixl\\r\\nconst variant_DD_9D_pseudo = {\\r\\n    \\"mnemonic\\": \\"sbc\\",\\r\\n    \\"params\\": [\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        157\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD9D\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Subtracts IXL and the carry flag from A.\\",\\r\\n        \\"instruction\\": \\"sbc a,ixl\\"\\r\\n    }\\r\\n};\\r\\n// sbc a,(ix+dd)\\r\\nconst variant_DD_9E_dd = {\\r\\n    \\"mnemonic\\": \\"sbc\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        158,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD9E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Subtracts the value pointed to by IX plus * and the carry flag from A.\\",\\r\\n        \\"instruction\\": \\"sbc a,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// sbc (ix+dd)\\r\\nconst variant_DD_9E_dd_pseudo = {\\r\\n    \\"mnemonic\\": \\"sbc\\",\\r\\n    \\"params\\": [\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        158,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DD9E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Subtracts the value pointed to by IX plus * and the carry flag from A.\\",\\r\\n        \\"instruction\\": \\"sbc a,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// sbc a,nn\\r\\nconst variant_DE_nn = {\\r\\n    \\"mnemonic\\": \\"sbc\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        222,\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DE\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"Subtracts * and the carry flag from A.\\",\\r\\n        \\"instruction\\": \\"sbc a,*\\"\\r\\n    }\\r\\n};\\r\\n// sbc nn\\r\\nconst variant_DE_nn_pseudo = {\\r\\n    \\"mnemonic\\": \\"sbc\\",\\r\\n    \\"params\\": [\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        222,\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DE\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"Subtracts * and the carry flag from A.\\",\\r\\n        \\"instruction\\": \\"sbc a,*\\"\\r\\n    }\\r\\n};\\r\\n// sbc hl,bc\\r\\nconst variant_ED_42 = {\\r\\n    \\"mnemonic\\": \\"sbc\\",\\r\\n    \\"params\\": [\\r\\n        \\"hl\\",\\r\\n        \\"bc\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"hl\\",\\r\\n        \\",\\",\\r\\n        \\"bc\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        66\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED42\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 15,\\r\\n        \\"without_jump_clock_count\\": 15,\\r\\n        \\"description\\": \\"Subtracts BC and the carry flag from HL.\\",\\r\\n        \\"instruction\\": \\"sbc hl,bc\\"\\r\\n    }\\r\\n};\\r\\n// sbc hl,de\\r\\nconst variant_ED_52 = {\\r\\n    \\"mnemonic\\": \\"sbc\\",\\r\\n    \\"params\\": [\\r\\n        \\"hl\\",\\r\\n        \\"de\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"hl\\",\\r\\n        \\",\\",\\r\\n        \\"de\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        82\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED52\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 15,\\r\\n        \\"without_jump_clock_count\\": 15,\\r\\n        \\"description\\": \\"Subtracts DE and the carry flag from HL.\\",\\r\\n        \\"instruction\\": \\"sbc hl,de\\"\\r\\n    }\\r\\n};\\r\\n// sbc hl,hl\\r\\nconst variant_ED_62 = {\\r\\n    \\"mnemonic\\": \\"sbc\\",\\r\\n    \\"params\\": [\\r\\n        \\"hl\\",\\r\\n        \\"hl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"hl\\",\\r\\n        \\",\\",\\r\\n        \\"hl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        98\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED62\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 15,\\r\\n        \\"without_jump_clock_count\\": 15,\\r\\n        \\"description\\": \\"Subtracts HL and the carry flag from HL.\\",\\r\\n        \\"instruction\\": \\"sbc hl,hl\\"\\r\\n    }\\r\\n};\\r\\n// sbc hl,sp\\r\\nconst variant_ED_72 = {\\r\\n    \\"mnemonic\\": \\"sbc\\",\\r\\n    \\"params\\": [\\r\\n        \\"hl\\",\\r\\n        \\"sp\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"hl\\",\\r\\n        \\",\\",\\r\\n        \\"sp\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        114\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED72\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 15,\\r\\n        \\"without_jump_clock_count\\": 15,\\r\\n        \\"description\\": \\"Subtracts HL and the carry flag from HL.\\",\\r\\n        \\"instruction\\": \\"sbc hl,sp\\"\\r\\n    }\\r\\n};\\r\\n// sbc a,iyh\\r\\nconst variant_FD_9C = {\\r\\n    \\"mnemonic\\": \\"sbc\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        156\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD9C\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Subtracts IYH and the carry flag from A.\\",\\r\\n        \\"instruction\\": \\"sbc a,iyh\\"\\r\\n    }\\r\\n};\\r\\n// sbc iyh\\r\\nconst variant_FD_9C_pseudo = {\\r\\n    \\"mnemonic\\": \\"sbc\\",\\r\\n    \\"params\\": [\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        156\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD9C\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Subtracts IYH and the carry flag from A.\\",\\r\\n        \\"instruction\\": \\"sbc a,iyh\\"\\r\\n    }\\r\\n};\\r\\n// sbc a,iyl\\r\\nconst variant_FD_9D = {\\r\\n    \\"mnemonic\\": \\"sbc\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        157\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD9D\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Subtracts IYL and the carry flag from A.\\",\\r\\n        \\"instruction\\": \\"sbc a,iyl\\"\\r\\n    }\\r\\n};\\r\\n// sbc iyl\\r\\nconst variant_FD_9D_pseudo = {\\r\\n    \\"mnemonic\\": \\"sbc\\",\\r\\n    \\"params\\": [\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        157\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD9D\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Subtracts IYL and the carry flag from A.\\",\\r\\n        \\"instruction\\": \\"sbc a,iyl\\"\\r\\n    }\\r\\n};\\r\\n// sbc a,(iy+dd)\\r\\nconst variant_FD_9E_dd = {\\r\\n    \\"mnemonic\\": \\"sbc\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        158,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD9E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Subtracts the value pointed to by IY plus * and the carry flag from A.\\",\\r\\n        \\"instruction\\": \\"sbc a,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// sbc (iy+dd)\\r\\nconst variant_FD_9E_dd_pseudo = {\\r\\n    \\"mnemonic\\": \\"sbc\\",\\r\\n    \\"params\\": [\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        158,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FD9E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Subtracts the value pointed to by IY plus * and the carry flag from A.\\",\\r\\n        \\"instruction\\": \\"sbc a,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// and a,b\\r\\nconst variant_A0 = {\\r\\n    \\"mnemonic\\": \\"and\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        160\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"A0\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P1++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Bitwise AND on A with B.\\",\\r\\n        \\"instruction\\": \\"and b\\"\\r\\n    }\\r\\n};\\r\\n// and b\\r\\nconst variant_A0_pseudo = {\\r\\n    \\"mnemonic\\": \\"and\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        160\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"A0\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P1++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Bitwise AND on A with B.\\",\\r\\n        \\"instruction\\": \\"and b\\"\\r\\n    }\\r\\n};\\r\\n// and a,c\\r\\nconst variant_A1 = {\\r\\n    \\"mnemonic\\": \\"and\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        161\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"A1\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P1++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Bitwise AND on A with C.\\",\\r\\n        \\"instruction\\": \\"and c\\"\\r\\n    }\\r\\n};\\r\\n// and c\\r\\nconst variant_A1_pseudo = {\\r\\n    \\"mnemonic\\": \\"and\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        161\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"A1\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P1++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Bitwise AND on A with C.\\",\\r\\n        \\"instruction\\": \\"and c\\"\\r\\n    }\\r\\n};\\r\\n// and a,d\\r\\nconst variant_A2 = {\\r\\n    \\"mnemonic\\": \\"and\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        162\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"A2\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P1++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Bitwise AND on A with D.\\",\\r\\n        \\"instruction\\": \\"and d\\"\\r\\n    }\\r\\n};\\r\\n// and d\\r\\nconst variant_A2_pseudo = {\\r\\n    \\"mnemonic\\": \\"and\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        162\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"A2\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P1++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Bitwise AND on A with D.\\",\\r\\n        \\"instruction\\": \\"and d\\"\\r\\n    }\\r\\n};\\r\\n// and a,e\\r\\nconst variant_A3 = {\\r\\n    \\"mnemonic\\": \\"and\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        163\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"A3\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P1++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Bitwise AND on A with E.\\",\\r\\n        \\"instruction\\": \\"and e\\"\\r\\n    }\\r\\n};\\r\\n// and e\\r\\nconst variant_A3_pseudo = {\\r\\n    \\"mnemonic\\": \\"and\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        163\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"A3\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P1++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Bitwise AND on A with E.\\",\\r\\n        \\"instruction\\": \\"and e\\"\\r\\n    }\\r\\n};\\r\\n// and a,h\\r\\nconst variant_A4 = {\\r\\n    \\"mnemonic\\": \\"and\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        164\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"A4\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P1++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Bitwise AND on A with H.\\",\\r\\n        \\"instruction\\": \\"and h\\"\\r\\n    }\\r\\n};\\r\\n// and h\\r\\nconst variant_A4_pseudo = {\\r\\n    \\"mnemonic\\": \\"and\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        164\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"A4\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P1++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Bitwise AND on A with H.\\",\\r\\n        \\"instruction\\": \\"and h\\"\\r\\n    }\\r\\n};\\r\\n// and a,l\\r\\nconst variant_A5 = {\\r\\n    \\"mnemonic\\": \\"and\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        165\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"A5\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P1++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Bitwise AND on A with L.\\",\\r\\n        \\"instruction\\": \\"and l\\"\\r\\n    }\\r\\n};\\r\\n// and l\\r\\nconst variant_A5_pseudo = {\\r\\n    \\"mnemonic\\": \\"and\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        165\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"A5\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P1++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Bitwise AND on A with L.\\",\\r\\n        \\"instruction\\": \\"and l\\"\\r\\n    }\\r\\n};\\r\\n// and a,(hl)\\r\\nconst variant_A6 = {\\r\\n    \\"mnemonic\\": \\"and\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        166\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"A6\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P1++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"Bitwise AND on A with (HL).\\",\\r\\n        \\"instruction\\": \\"and (hl)\\"\\r\\n    }\\r\\n};\\r\\n// and (hl)\\r\\nconst variant_A6_pseudo = {\\r\\n    \\"mnemonic\\": \\"and\\",\\r\\n    \\"params\\": [\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        166\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"A6\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P1++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"Bitwise AND on A with (HL).\\",\\r\\n        \\"instruction\\": \\"and (hl)\\"\\r\\n    }\\r\\n};\\r\\n// and a,a\\r\\nconst variant_A7 = {\\r\\n    \\"mnemonic\\": \\"and\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        167\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"A7\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P1++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Bitwise AND on A with A.\\",\\r\\n        \\"instruction\\": \\"and a\\"\\r\\n    }\\r\\n};\\r\\n// and a\\r\\nconst variant_A7_pseudo = {\\r\\n    \\"mnemonic\\": \\"and\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        167\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"A7\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P1++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Bitwise AND on A with A.\\",\\r\\n        \\"instruction\\": \\"and a\\"\\r\\n    }\\r\\n};\\r\\n// and a,ixh\\r\\nconst variant_DD_A4 = {\\r\\n    \\"mnemonic\\": \\"and\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        164\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDA4\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"00P1++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Bitwise AND on A with IXH.\\",\\r\\n        \\"instruction\\": \\"and ixh\\"\\r\\n    }\\r\\n};\\r\\n// and ixh\\r\\nconst variant_DD_A4_pseudo = {\\r\\n    \\"mnemonic\\": \\"and\\",\\r\\n    \\"params\\": [\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        164\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDA4\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"00P1++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Bitwise AND on A with IXH.\\",\\r\\n        \\"instruction\\": \\"and ixh\\"\\r\\n    }\\r\\n};\\r\\n// and a,ixl\\r\\nconst variant_DD_A5 = {\\r\\n    \\"mnemonic\\": \\"and\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        165\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDA5\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"00P1++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Bitwise AND on A with IXL.\\",\\r\\n        \\"instruction\\": \\"and ixl\\"\\r\\n    }\\r\\n};\\r\\n// and ixl\\r\\nconst variant_DD_A5_pseudo = {\\r\\n    \\"mnemonic\\": \\"and\\",\\r\\n    \\"params\\": [\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        165\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDA5\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"00P1++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Bitwise AND on A with IXL.\\",\\r\\n        \\"instruction\\": \\"and ixl\\"\\r\\n    }\\r\\n};\\r\\n// and a,(ix+dd)\\r\\nconst variant_DD_A6_dd = {\\r\\n    \\"mnemonic\\": \\"and\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        166,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDA6\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P1++\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Bitwise AND on A with the value pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"and (ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// and (ix+dd)\\r\\nconst variant_DD_A6_dd_pseudo = {\\r\\n    \\"mnemonic\\": \\"and\\",\\r\\n    \\"params\\": [\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        166,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDA6\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P1++\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Bitwise AND on A with the value pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"and (ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// and nn\\r\\nconst variant_E6_nn = {\\r\\n    \\"mnemonic\\": \\"and\\",\\r\\n    \\"params\\": [\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        230,\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"E6\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P1++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"Bitwise AND on A with *.\\",\\r\\n        \\"instruction\\": \\"and *\\"\\r\\n    }\\r\\n};\\r\\n// and a,iyh\\r\\nconst variant_FD_A4 = {\\r\\n    \\"mnemonic\\": \\"and\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        164\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDA4\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"00P1++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Bitwise AND on A with IYH.\\",\\r\\n        \\"instruction\\": \\"and iyh\\"\\r\\n    }\\r\\n};\\r\\n// and iyh\\r\\nconst variant_FD_A4_pseudo = {\\r\\n    \\"mnemonic\\": \\"and\\",\\r\\n    \\"params\\": [\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        164\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDA4\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"00P1++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Bitwise AND on A with IYH.\\",\\r\\n        \\"instruction\\": \\"and iyh\\"\\r\\n    }\\r\\n};\\r\\n// and a,iyl\\r\\nconst variant_FD_A5 = {\\r\\n    \\"mnemonic\\": \\"and\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        165\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDA5\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"00P1++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Bitwise AND on A with IYL.\\",\\r\\n        \\"instruction\\": \\"and iyl\\"\\r\\n    }\\r\\n};\\r\\n// and iyl\\r\\nconst variant_FD_A5_pseudo = {\\r\\n    \\"mnemonic\\": \\"and\\",\\r\\n    \\"params\\": [\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        165\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDA5\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"00P1++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Bitwise AND on A with IYL.\\",\\r\\n        \\"instruction\\": \\"and iyl\\"\\r\\n    }\\r\\n};\\r\\n// and a,(iy+dd)\\r\\nconst variant_FD_A6_dd = {\\r\\n    \\"mnemonic\\": \\"and\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        166,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDA6\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P1++\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Bitwise AND on A with the value pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"and (iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// and (iy+dd)\\r\\nconst variant_FD_A6_dd_pseudo = {\\r\\n    \\"mnemonic\\": \\"and\\",\\r\\n    \\"params\\": [\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        166,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDA6\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P1++\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Bitwise AND on A with the value pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"and (iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// xor a,b\\r\\nconst variant_A8 = {\\r\\n    \\"mnemonic\\": \\"xor\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        168\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"A8\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Bitwise XOR on A with B.\\",\\r\\n        \\"instruction\\": \\"xor b\\"\\r\\n    }\\r\\n};\\r\\n// xor b\\r\\nconst variant_A8_pseudo = {\\r\\n    \\"mnemonic\\": \\"xor\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        168\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"A8\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Bitwise XOR on A with B.\\",\\r\\n        \\"instruction\\": \\"xor b\\"\\r\\n    }\\r\\n};\\r\\n// xor a,c\\r\\nconst variant_A9 = {\\r\\n    \\"mnemonic\\": \\"xor\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        169\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"A9\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Bitwise XOR on A with C.\\",\\r\\n        \\"instruction\\": \\"xor c\\"\\r\\n    }\\r\\n};\\r\\n// xor c\\r\\nconst variant_A9_pseudo = {\\r\\n    \\"mnemonic\\": \\"xor\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        169\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"A9\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Bitwise XOR on A with C.\\",\\r\\n        \\"instruction\\": \\"xor c\\"\\r\\n    }\\r\\n};\\r\\n// xor a,d\\r\\nconst variant_AA = {\\r\\n    \\"mnemonic\\": \\"xor\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        170\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"AA\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Bitwise XOR on A with D.\\",\\r\\n        \\"instruction\\": \\"xor d\\"\\r\\n    }\\r\\n};\\r\\n// xor d\\r\\nconst variant_AA_pseudo = {\\r\\n    \\"mnemonic\\": \\"xor\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        170\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"AA\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Bitwise XOR on A with D.\\",\\r\\n        \\"instruction\\": \\"xor d\\"\\r\\n    }\\r\\n};\\r\\n// xor a,e\\r\\nconst variant_AB = {\\r\\n    \\"mnemonic\\": \\"xor\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        171\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"AB\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Bitwise XOR on A with E.\\",\\r\\n        \\"instruction\\": \\"xor e\\"\\r\\n    }\\r\\n};\\r\\n// xor e\\r\\nconst variant_AB_pseudo = {\\r\\n    \\"mnemonic\\": \\"xor\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        171\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"AB\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Bitwise XOR on A with E.\\",\\r\\n        \\"instruction\\": \\"xor e\\"\\r\\n    }\\r\\n};\\r\\n// xor a,h\\r\\nconst variant_AC = {\\r\\n    \\"mnemonic\\": \\"xor\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        172\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"AC\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Bitwise XOR on A with H.\\",\\r\\n        \\"instruction\\": \\"xor h\\"\\r\\n    }\\r\\n};\\r\\n// xor h\\r\\nconst variant_AC_pseudo = {\\r\\n    \\"mnemonic\\": \\"xor\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        172\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"AC\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Bitwise XOR on A with H.\\",\\r\\n        \\"instruction\\": \\"xor h\\"\\r\\n    }\\r\\n};\\r\\n// xor a,l\\r\\nconst variant_AD = {\\r\\n    \\"mnemonic\\": \\"xor\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        173\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"AD\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Bitwise XOR on A with L.\\",\\r\\n        \\"instruction\\": \\"xor l\\"\\r\\n    }\\r\\n};\\r\\n// xor l\\r\\nconst variant_AD_pseudo = {\\r\\n    \\"mnemonic\\": \\"xor\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        173\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"AD\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Bitwise XOR on A with L.\\",\\r\\n        \\"instruction\\": \\"xor l\\"\\r\\n    }\\r\\n};\\r\\n// xor a,(hl)\\r\\nconst variant_AE = {\\r\\n    \\"mnemonic\\": \\"xor\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        174\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"AE\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"Bitwise XOR on A with (HL).\\",\\r\\n        \\"instruction\\": \\"xor (hl)\\"\\r\\n    }\\r\\n};\\r\\n// xor (hl)\\r\\nconst variant_AE_pseudo = {\\r\\n    \\"mnemonic\\": \\"xor\\",\\r\\n    \\"params\\": [\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        174\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"AE\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"Bitwise XOR on A with (HL).\\",\\r\\n        \\"instruction\\": \\"xor (hl)\\"\\r\\n    }\\r\\n};\\r\\n// xor a,a\\r\\nconst variant_AF = {\\r\\n    \\"mnemonic\\": \\"xor\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        175\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"AF\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Bitwise XOR on A with A.\\",\\r\\n        \\"instruction\\": \\"xor a\\"\\r\\n    }\\r\\n};\\r\\n// xor a\\r\\nconst variant_AF_pseudo = {\\r\\n    \\"mnemonic\\": \\"xor\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        175\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"AF\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Bitwise XOR on A with A.\\",\\r\\n        \\"instruction\\": \\"xor a\\"\\r\\n    }\\r\\n};\\r\\n// xor a,ixh\\r\\nconst variant_DD_AC = {\\r\\n    \\"mnemonic\\": \\"xor\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        172\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDAC\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Bitwise XOR on A with IXH.\\",\\r\\n        \\"instruction\\": \\"xor ixh\\"\\r\\n    }\\r\\n};\\r\\n// xor ixh\\r\\nconst variant_DD_AC_pseudo = {\\r\\n    \\"mnemonic\\": \\"xor\\",\\r\\n    \\"params\\": [\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        172\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDAC\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Bitwise XOR on A with IXH.\\",\\r\\n        \\"instruction\\": \\"xor ixh\\"\\r\\n    }\\r\\n};\\r\\n// xor a,ixl\\r\\nconst variant_DD_AD = {\\r\\n    \\"mnemonic\\": \\"xor\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        173\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDAD\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Bitwise XOR on A with IXL.\\",\\r\\n        \\"instruction\\": \\"xor ixl\\"\\r\\n    }\\r\\n};\\r\\n// xor ixl\\r\\nconst variant_DD_AD_pseudo = {\\r\\n    \\"mnemonic\\": \\"xor\\",\\r\\n    \\"params\\": [\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        173\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDAD\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Bitwise XOR on A with IXL.\\",\\r\\n        \\"instruction\\": \\"xor ixl\\"\\r\\n    }\\r\\n};\\r\\n// xor a,(ix+dd)\\r\\nconst variant_DD_AE_dd = {\\r\\n    \\"mnemonic\\": \\"xor\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        174,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDAE\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Bitwise XOR on A with the value pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"xor (ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// xor (ix+dd)\\r\\nconst variant_DD_AE_dd_pseudo = {\\r\\n    \\"mnemonic\\": \\"xor\\",\\r\\n    \\"params\\": [\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        174,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDAE\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Bitwise XOR on A with the value pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"xor (ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// xor a,nn\\r\\nconst variant_EE_nn = {\\r\\n    \\"mnemonic\\": \\"xor\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        238,\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"EE\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"Bitwise XOR on A with *.\\",\\r\\n        \\"instruction\\": \\"xor *\\"\\r\\n    }\\r\\n};\\r\\n// xor nn\\r\\nconst variant_EE_nn_pseudo = {\\r\\n    \\"mnemonic\\": \\"xor\\",\\r\\n    \\"params\\": [\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        238,\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"EE\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"Bitwise XOR on A with *.\\",\\r\\n        \\"instruction\\": \\"xor *\\"\\r\\n    }\\r\\n};\\r\\n// xor a,iyh\\r\\nconst variant_FD_AC = {\\r\\n    \\"mnemonic\\": \\"xor\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        172\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDAC\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Bitwise XOR on A with IYH.\\",\\r\\n        \\"instruction\\": \\"xor iyh\\"\\r\\n    }\\r\\n};\\r\\n// xor iyh\\r\\nconst variant_FD_AC_pseudo = {\\r\\n    \\"mnemonic\\": \\"xor\\",\\r\\n    \\"params\\": [\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        172\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDAC\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Bitwise XOR on A with IYH.\\",\\r\\n        \\"instruction\\": \\"xor iyh\\"\\r\\n    }\\r\\n};\\r\\n// xor a,iyl\\r\\nconst variant_FD_AD = {\\r\\n    \\"mnemonic\\": \\"xor\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        173\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDAD\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Bitwise XOR on A with IYL.\\",\\r\\n        \\"instruction\\": \\"xor iyl\\"\\r\\n    }\\r\\n};\\r\\n// xor iyl\\r\\nconst variant_FD_AD_pseudo = {\\r\\n    \\"mnemonic\\": \\"xor\\",\\r\\n    \\"params\\": [\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        173\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDAD\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Bitwise XOR on A with IYL.\\",\\r\\n        \\"instruction\\": \\"xor iyl\\"\\r\\n    }\\r\\n};\\r\\n// xor a,(iy+dd)\\r\\nconst variant_FD_AE_dd = {\\r\\n    \\"mnemonic\\": \\"xor\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        174,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDAE\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Bitwise XOR on A with the value pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"xor (iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// xor (iy+dd)\\r\\nconst variant_FD_AE_dd_pseudo = {\\r\\n    \\"mnemonic\\": \\"xor\\",\\r\\n    \\"params\\": [\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        174,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDAE\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Bitwise XOR on A with the value pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"xor (iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// or a,b\\r\\nconst variant_B0 = {\\r\\n    \\"mnemonic\\": \\"or\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        176\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"B0\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Bitwise OR on A with B.\\",\\r\\n        \\"instruction\\": \\"or b\\"\\r\\n    }\\r\\n};\\r\\n// or b\\r\\nconst variant_B0_pseudo = {\\r\\n    \\"mnemonic\\": \\"or\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        176\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"B0\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Bitwise OR on A with B.\\",\\r\\n        \\"instruction\\": \\"or b\\"\\r\\n    }\\r\\n};\\r\\n// or a,c\\r\\nconst variant_B1 = {\\r\\n    \\"mnemonic\\": \\"or\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        177\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"B1\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Bitwise OR on A with C.\\",\\r\\n        \\"instruction\\": \\"or c\\"\\r\\n    }\\r\\n};\\r\\n// or c\\r\\nconst variant_B1_pseudo = {\\r\\n    \\"mnemonic\\": \\"or\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        177\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"B1\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Bitwise OR on A with C.\\",\\r\\n        \\"instruction\\": \\"or c\\"\\r\\n    }\\r\\n};\\r\\n// or a,d\\r\\nconst variant_B2 = {\\r\\n    \\"mnemonic\\": \\"or\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        178\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"B2\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Bitwise OR on A with D.\\",\\r\\n        \\"instruction\\": \\"or d\\"\\r\\n    }\\r\\n};\\r\\n// or d\\r\\nconst variant_B2_pseudo = {\\r\\n    \\"mnemonic\\": \\"or\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        178\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"B2\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Bitwise OR on A with D.\\",\\r\\n        \\"instruction\\": \\"or d\\"\\r\\n    }\\r\\n};\\r\\n// or a,e\\r\\nconst variant_B3 = {\\r\\n    \\"mnemonic\\": \\"or\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        179\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"B3\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Bitwise OR on A with E.\\",\\r\\n        \\"instruction\\": \\"or e\\"\\r\\n    }\\r\\n};\\r\\n// or e\\r\\nconst variant_B3_pseudo = {\\r\\n    \\"mnemonic\\": \\"or\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        179\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"B3\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Bitwise OR on A with E.\\",\\r\\n        \\"instruction\\": \\"or e\\"\\r\\n    }\\r\\n};\\r\\n// or a,h\\r\\nconst variant_B4 = {\\r\\n    \\"mnemonic\\": \\"or\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        180\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"B4\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Bitwise OR on A with H.\\",\\r\\n        \\"instruction\\": \\"or h\\"\\r\\n    }\\r\\n};\\r\\n// or h\\r\\nconst variant_B4_pseudo = {\\r\\n    \\"mnemonic\\": \\"or\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        180\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"B4\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Bitwise OR on A with H.\\",\\r\\n        \\"instruction\\": \\"or h\\"\\r\\n    }\\r\\n};\\r\\n// or a,l\\r\\nconst variant_B5 = {\\r\\n    \\"mnemonic\\": \\"or\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        181\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"B5\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Bitwise OR on A with L.\\",\\r\\n        \\"instruction\\": \\"or l\\"\\r\\n    }\\r\\n};\\r\\n// or l\\r\\nconst variant_B5_pseudo = {\\r\\n    \\"mnemonic\\": \\"or\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        181\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"B5\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Bitwise OR on A with L.\\",\\r\\n        \\"instruction\\": \\"or l\\"\\r\\n    }\\r\\n};\\r\\n// or a,(hl)\\r\\nconst variant_B6 = {\\r\\n    \\"mnemonic\\": \\"or\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        182\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"B6\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"Bitwise OR on A with (HL).\\",\\r\\n        \\"instruction\\": \\"or (hl)\\"\\r\\n    }\\r\\n};\\r\\n// or (hl)\\r\\nconst variant_B6_pseudo = {\\r\\n    \\"mnemonic\\": \\"or\\",\\r\\n    \\"params\\": [\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        182\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"B6\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"Bitwise OR on A with (HL).\\",\\r\\n        \\"instruction\\": \\"or (hl)\\"\\r\\n    }\\r\\n};\\r\\n// or a,a\\r\\nconst variant_B7 = {\\r\\n    \\"mnemonic\\": \\"or\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        183\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"B7\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Bitwise OR on A with A.\\",\\r\\n        \\"instruction\\": \\"or a\\"\\r\\n    }\\r\\n};\\r\\n// or a\\r\\nconst variant_B7_pseudo = {\\r\\n    \\"mnemonic\\": \\"or\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        183\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"B7\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Bitwise OR on A with A.\\",\\r\\n        \\"instruction\\": \\"or a\\"\\r\\n    }\\r\\n};\\r\\n// or a,ixh\\r\\nconst variant_DD_B4 = {\\r\\n    \\"mnemonic\\": \\"or\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        180\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDB4\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Bitwise OR on A with IXH.\\",\\r\\n        \\"instruction\\": \\"or ixh\\"\\r\\n    }\\r\\n};\\r\\n// or ixh\\r\\nconst variant_DD_B4_pseudo = {\\r\\n    \\"mnemonic\\": \\"or\\",\\r\\n    \\"params\\": [\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        180\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDB4\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Bitwise OR on A with IXH.\\",\\r\\n        \\"instruction\\": \\"or ixh\\"\\r\\n    }\\r\\n};\\r\\n// or a,ixl\\r\\nconst variant_DD_B5 = {\\r\\n    \\"mnemonic\\": \\"or\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        181\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDB5\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Bitwise OR on A with IXL.\\",\\r\\n        \\"instruction\\": \\"or ixl\\"\\r\\n    }\\r\\n};\\r\\n// or ixl\\r\\nconst variant_DD_B5_pseudo = {\\r\\n    \\"mnemonic\\": \\"or\\",\\r\\n    \\"params\\": [\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        181\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDB5\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Bitwise OR on A with IXL.\\",\\r\\n        \\"instruction\\": \\"or ixl\\"\\r\\n    }\\r\\n};\\r\\n// or a,(ix+dd)\\r\\nconst variant_DD_B6_dd = {\\r\\n    \\"mnemonic\\": \\"or\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        182,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDB6\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Bitwise OR on A with the value pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"or (ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// or (ix+dd)\\r\\nconst variant_DD_B6_dd_pseudo = {\\r\\n    \\"mnemonic\\": \\"or\\",\\r\\n    \\"params\\": [\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        182,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDB6\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Bitwise OR on A with the value pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"or (ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// or nn\\r\\nconst variant_F6_nn = {\\r\\n    \\"mnemonic\\": \\"or\\",\\r\\n    \\"params\\": [\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        246,\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"F6\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"Bitwise OR on A with *.\\",\\r\\n        \\"instruction\\": \\"or *\\"\\r\\n    }\\r\\n};\\r\\n// or a,iyh\\r\\nconst variant_FD_B4 = {\\r\\n    \\"mnemonic\\": \\"or\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        180\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDB4\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Bitwise OR on A with IYH.\\",\\r\\n        \\"instruction\\": \\"or iyh\\"\\r\\n    }\\r\\n};\\r\\n// or iyh\\r\\nconst variant_FD_B4_pseudo = {\\r\\n    \\"mnemonic\\": \\"or\\",\\r\\n    \\"params\\": [\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        180\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDB4\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Bitwise OR on A with IYH.\\",\\r\\n        \\"instruction\\": \\"or iyh\\"\\r\\n    }\\r\\n};\\r\\n// or a,iyl\\r\\nconst variant_FD_B5 = {\\r\\n    \\"mnemonic\\": \\"or\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        181\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDB5\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Bitwise OR on A with IYL.\\",\\r\\n        \\"instruction\\": \\"or iyl\\"\\r\\n    }\\r\\n};\\r\\n// or iyl\\r\\nconst variant_FD_B5_pseudo = {\\r\\n    \\"mnemonic\\": \\"or\\",\\r\\n    \\"params\\": [\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        181\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDB5\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Bitwise OR on A with IYL.\\",\\r\\n        \\"instruction\\": \\"or iyl\\"\\r\\n    }\\r\\n};\\r\\n// or a,(iy+dd)\\r\\nconst variant_FD_B6_dd = {\\r\\n    \\"mnemonic\\": \\"or\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        182,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDB6\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Bitwise OR on A with the value pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"or (iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// or (iy+dd)\\r\\nconst variant_FD_B6_dd_pseudo = {\\r\\n    \\"mnemonic\\": \\"or\\",\\r\\n    \\"params\\": [\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        182,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDB6\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"00P0++\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Bitwise OR on A with the value pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"or (iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// cp b\\r\\nconst variant_B8 = {\\r\\n    \\"mnemonic\\": \\"cp\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        184\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"B8\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Subtracts B from A and affects flags according to the result. A is not modified.\\",\\r\\n        \\"instruction\\": \\"cp b\\"\\r\\n    }\\r\\n};\\r\\n// cp c\\r\\nconst variant_B9 = {\\r\\n    \\"mnemonic\\": \\"cp\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        185\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"B9\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Subtracts C from A and affects flags according to the result. A is not modified.\\",\\r\\n        \\"instruction\\": \\"cp c\\"\\r\\n    }\\r\\n};\\r\\n// cp d\\r\\nconst variant_BA = {\\r\\n    \\"mnemonic\\": \\"cp\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        186\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"BA\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Subtracts D from A and affects flags according to the result. A is not modified.\\",\\r\\n        \\"instruction\\": \\"cp d\\"\\r\\n    }\\r\\n};\\r\\n// cp e\\r\\nconst variant_BB = {\\r\\n    \\"mnemonic\\": \\"cp\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        187\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"BB\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Subtracts E from A and affects flags according to the result. A is not modified.\\",\\r\\n        \\"instruction\\": \\"cp e\\"\\r\\n    }\\r\\n};\\r\\n// cp h\\r\\nconst variant_BC = {\\r\\n    \\"mnemonic\\": \\"cp\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        188\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"BC\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Subtracts H from A and affects flags according to the result. A is not modified.\\",\\r\\n        \\"instruction\\": \\"cp h\\"\\r\\n    }\\r\\n};\\r\\n// cp l\\r\\nconst variant_BD = {\\r\\n    \\"mnemonic\\": \\"cp\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        189\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"BD\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Subtracts L from A and affects flags according to the result. A is not modified.\\",\\r\\n        \\"instruction\\": \\"cp l\\"\\r\\n    }\\r\\n};\\r\\n// cp (hl)\\r\\nconst variant_BE = {\\r\\n    \\"mnemonic\\": \\"cp\\",\\r\\n    \\"params\\": [\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        190\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"BE\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"Subtracts (HL) from A and affects flags according to the result. A is not modified.\\",\\r\\n        \\"instruction\\": \\"cp (hl)\\"\\r\\n    }\\r\\n};\\r\\n// cp a\\r\\nconst variant_BF = {\\r\\n    \\"mnemonic\\": \\"cp\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        191\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"BF\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Subtracts A from A and affects flags according to the result. A is not modified.\\",\\r\\n        \\"instruction\\": \\"cp a\\"\\r\\n    }\\r\\n};\\r\\n// cp ixh\\r\\nconst variant_DD_BC = {\\r\\n    \\"mnemonic\\": \\"cp\\",\\r\\n    \\"params\\": [\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ixh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        188\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDBC\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Subtracts IXH from A and affects flags according to the result. A is not modified.\\",\\r\\n        \\"instruction\\": \\"cp ixh\\"\\r\\n    }\\r\\n};\\r\\n// cp ixl\\r\\nconst variant_DD_BD = {\\r\\n    \\"mnemonic\\": \\"cp\\",\\r\\n    \\"params\\": [\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ixl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        189\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDBD\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Subtracts IXL from A and affects flags according to the result. A is not modified.\\",\\r\\n        \\"instruction\\": \\"cp ixl\\"\\r\\n    }\\r\\n};\\r\\n// cp (ix+dd)\\r\\nconst variant_DD_BE_dd = {\\r\\n    \\"mnemonic\\": \\"cp\\",\\r\\n    \\"params\\": [\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        190,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDBE\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Subtracts the value pointed to by IX plus * from A and affects flags according to the result. A is not modified.\\",\\r\\n        \\"instruction\\": \\"cp (ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// cp iyh\\r\\nconst variant_FD_BC = {\\r\\n    \\"mnemonic\\": \\"cp\\",\\r\\n    \\"params\\": [\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iyh\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        188\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDBC\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Subtracts IYH from A and affects flags according to the result. A is not modified.\\",\\r\\n        \\"instruction\\": \\"cp iyh\\"\\r\\n    }\\r\\n};\\r\\n// cp iyl\\r\\nconst variant_FD_BD = {\\r\\n    \\"mnemonic\\": \\"cp\\",\\r\\n    \\"params\\": [\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iyl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        189\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDBD\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Subtracts IYL from A and affects flags according to the result. A is not modified.\\",\\r\\n        \\"instruction\\": \\"cp iyl\\"\\r\\n    }\\r\\n};\\r\\n// cp (iy+dd)\\r\\nconst variant_FD_BE_dd = {\\r\\n    \\"mnemonic\\": \\"cp\\",\\r\\n    \\"params\\": [\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        190,\\r\\n        \\"dd\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDBE\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 19,\\r\\n        \\"without_jump_clock_count\\": 19,\\r\\n        \\"description\\": \\"Subtracts the value pointed to by IY plus * from A and affects flags according to the result. A is not modified.\\",\\r\\n        \\"instruction\\": \\"cp (iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// cp nn\\r\\nconst variant_FE_nn = {\\r\\n    \\"mnemonic\\": \\"cp\\",\\r\\n    \\"params\\": [\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        254,\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FE\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 7,\\r\\n        \\"without_jump_clock_count\\": 7,\\r\\n        \\"description\\": \\"Subtracts * from A and affects flags according to the result. A is not modified.\\",\\r\\n        \\"instruction\\": \\"cp *\\"\\r\\n    }\\r\\n};\\r\\n// ret nz\\r\\nconst variant_C0 = {\\r\\n    \\"mnemonic\\": \\"ret\\",\\r\\n    \\"params\\": [\\r\\n        \\"nz\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"nz\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        192\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"C0\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 11,\\r\\n        \\"without_jump_clock_count\\": 5,\\r\\n        \\"description\\": \\"If condition CC is true, the top stack entry is popped into PC.\\",\\r\\n        \\"instruction\\": \\"ret nz\\"\\r\\n    }\\r\\n};\\r\\n// ret z\\r\\nconst variant_C8 = {\\r\\n    \\"mnemonic\\": \\"ret\\",\\r\\n    \\"params\\": [\\r\\n        \\"z\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"z\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        200\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"C8\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 11,\\r\\n        \\"without_jump_clock_count\\": 5,\\r\\n        \\"description\\": \\"If condition CC is true, the top stack entry is popped into PC.\\",\\r\\n        \\"instruction\\": \\"ret z\\"\\r\\n    }\\r\\n};\\r\\n// ret\\r\\nconst variant_C9 = {\\r\\n    \\"mnemonic\\": \\"ret\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        201\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"C9\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 10,\\r\\n        \\"without_jump_clock_count\\": 10,\\r\\n        \\"description\\": \\"The top stack entry is popped into PC.\\",\\r\\n        \\"instruction\\": \\"ret\\"\\r\\n    }\\r\\n};\\r\\n// ret nc\\r\\nconst variant_D0 = {\\r\\n    \\"mnemonic\\": \\"ret\\",\\r\\n    \\"params\\": [\\r\\n        \\"nc\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"nc\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        208\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"D0\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 11,\\r\\n        \\"without_jump_clock_count\\": 5,\\r\\n        \\"description\\": \\"If condition CC is true, the top stack entry is popped into PC.\\",\\r\\n        \\"instruction\\": \\"ret nc\\"\\r\\n    }\\r\\n};\\r\\n// ret c\\r\\nconst variant_D8 = {\\r\\n    \\"mnemonic\\": \\"ret\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        216\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"D8\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 11,\\r\\n        \\"without_jump_clock_count\\": 5,\\r\\n        \\"description\\": \\"If condition CC is true, the top stack entry is popped into PC.\\",\\r\\n        \\"instruction\\": \\"ret c\\"\\r\\n    }\\r\\n};\\r\\n// ret po\\r\\nconst variant_E0 = {\\r\\n    \\"mnemonic\\": \\"ret\\",\\r\\n    \\"params\\": [\\r\\n        \\"po\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"po\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        224\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"E0\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 11,\\r\\n        \\"without_jump_clock_count\\": 5,\\r\\n        \\"description\\": \\"If condition CC is true, the top stack entry is popped into PC.\\",\\r\\n        \\"instruction\\": \\"ret po\\"\\r\\n    }\\r\\n};\\r\\n// ret pe\\r\\nconst variant_E8 = {\\r\\n    \\"mnemonic\\": \\"ret\\",\\r\\n    \\"params\\": [\\r\\n        \\"pe\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"pe\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        232\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"E8\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 11,\\r\\n        \\"without_jump_clock_count\\": 5,\\r\\n        \\"description\\": \\"If condition CC is true, the top stack entry is popped into PC.\\",\\r\\n        \\"instruction\\": \\"ret pe\\"\\r\\n    }\\r\\n};\\r\\n// ret p\\r\\nconst variant_F0 = {\\r\\n    \\"mnemonic\\": \\"ret\\",\\r\\n    \\"params\\": [\\r\\n        \\"p\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"p\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        240\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"F0\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 11,\\r\\n        \\"without_jump_clock_count\\": 5,\\r\\n        \\"description\\": \\"If condition CC is true, the top stack entry is popped into PC.\\",\\r\\n        \\"instruction\\": \\"ret p\\"\\r\\n    }\\r\\n};\\r\\n// ret m\\r\\nconst variant_F8 = {\\r\\n    \\"mnemonic\\": \\"ret\\",\\r\\n    \\"params\\": [\\r\\n        \\"m\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"m\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        248\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"F8\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 11,\\r\\n        \\"without_jump_clock_count\\": 5,\\r\\n        \\"description\\": \\"If condition CC is true, the top stack entry is popped into PC.\\",\\r\\n        \\"instruction\\": \\"ret m\\"\\r\\n    }\\r\\n};\\r\\n// pop bc\\r\\nconst variant_C1 = {\\r\\n    \\"mnemonic\\": \\"pop\\",\\r\\n    \\"params\\": [\\r\\n        \\"bc\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"bc\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        193\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"C1\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 10,\\r\\n        \\"without_jump_clock_count\\": 10,\\r\\n        \\"description\\": \\"The memory location pointed to by SP is stored into C and SP is incremented. The memory location pointed to by SP is stored into B and SP is incremented again.\\",\\r\\n        \\"instruction\\": \\"pop bc\\"\\r\\n    }\\r\\n};\\r\\n// pop de\\r\\nconst variant_D1 = {\\r\\n    \\"mnemonic\\": \\"pop\\",\\r\\n    \\"params\\": [\\r\\n        \\"de\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"de\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        209\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"D1\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 10,\\r\\n        \\"without_jump_clock_count\\": 10,\\r\\n        \\"description\\": \\"The memory location pointed to by SP is stored into E and SP is incremented. The memory location pointed to by SP is stored into D and SP is incremented again.\\",\\r\\n        \\"instruction\\": \\"pop de\\"\\r\\n    }\\r\\n};\\r\\n// pop ix\\r\\nconst variant_DD_E1 = {\\r\\n    \\"mnemonic\\": \\"pop\\",\\r\\n    \\"params\\": [\\r\\n        \\"ix\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ix\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        225\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDE1\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 14,\\r\\n        \\"without_jump_clock_count\\": 14,\\r\\n        \\"description\\": \\"The memory location pointed to by SP is stored into IXL and SP is incremented. The memory location pointed to by SP is stored into IXH and SP is incremented again.\\",\\r\\n        \\"instruction\\": \\"pop ix\\"\\r\\n    }\\r\\n};\\r\\n// pop hl\\r\\nconst variant_E1 = {\\r\\n    \\"mnemonic\\": \\"pop\\",\\r\\n    \\"params\\": [\\r\\n        \\"hl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"hl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        225\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"E1\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 10,\\r\\n        \\"without_jump_clock_count\\": 10,\\r\\n        \\"description\\": \\"The memory location pointed to by SP is stored into L and SP is incremented. The memory location pointed to by SP is stored into H and SP is incremented again.\\",\\r\\n        \\"instruction\\": \\"pop hl\\"\\r\\n    }\\r\\n};\\r\\n// pop af\\r\\nconst variant_F1 = {\\r\\n    \\"mnemonic\\": \\"pop\\",\\r\\n    \\"params\\": [\\r\\n        \\"af\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"af\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        241\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"F1\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 10,\\r\\n        \\"without_jump_clock_count\\": 10,\\r\\n        \\"description\\": \\"The memory location pointed to by SP is stored into F and SP is incremented. The memory location pointed to by SP is stored into A and SP is incremented again.\\",\\r\\n        \\"instruction\\": \\"pop af\\"\\r\\n    }\\r\\n};\\r\\n// pop iy\\r\\nconst variant_FD_E1 = {\\r\\n    \\"mnemonic\\": \\"pop\\",\\r\\n    \\"params\\": [\\r\\n        \\"iy\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iy\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        225\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDE1\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 14,\\r\\n        \\"without_jump_clock_count\\": 14,\\r\\n        \\"description\\": \\"The memory location pointed to by SP is stored into IYL and SP is incremented. The memory location pointed to by SP is stored into IYH and SP is incremented again.\\",\\r\\n        \\"instruction\\": \\"pop iy\\"\\r\\n    }\\r\\n};\\r\\n// jp nz,nnnn\\r\\nconst variant_C2_nnnn = {\\r\\n    \\"mnemonic\\": \\"jp\\",\\r\\n    \\"params\\": [\\r\\n        \\"nz\\",\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"nz\\",\\r\\n        \\",\\",\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        194,\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"C2\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 10,\\r\\n        \\"without_jump_clock_count\\": 10,\\r\\n        \\"description\\": \\"If condition CC is true, ** is copied to PC.\\",\\r\\n        \\"instruction\\": \\"jp nz,**\\"\\r\\n    }\\r\\n};\\r\\n// jp nnnn\\r\\nconst variant_C3_nnnn = {\\r\\n    \\"mnemonic\\": \\"jp\\",\\r\\n    \\"params\\": [\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        195,\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"C3\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 10,\\r\\n        \\"without_jump_clock_count\\": 10,\\r\\n        \\"description\\": \\"** is copied to PC.\\",\\r\\n        \\"instruction\\": \\"jp **\\"\\r\\n    }\\r\\n};\\r\\n// jp z,nnnn\\r\\nconst variant_CA_nnnn = {\\r\\n    \\"mnemonic\\": \\"jp\\",\\r\\n    \\"params\\": [\\r\\n        \\"z\\",\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"z\\",\\r\\n        \\",\\",\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        202,\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CA\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 10,\\r\\n        \\"without_jump_clock_count\\": 10,\\r\\n        \\"description\\": \\"If condition CC is true, ** is copied to PC.\\",\\r\\n        \\"instruction\\": \\"jp z,**\\"\\r\\n    }\\r\\n};\\r\\n// jp nc,nnnn\\r\\nconst variant_D2_nnnn = {\\r\\n    \\"mnemonic\\": \\"jp\\",\\r\\n    \\"params\\": [\\r\\n        \\"nc\\",\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"nc\\",\\r\\n        \\",\\",\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        210,\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"D2\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 10,\\r\\n        \\"without_jump_clock_count\\": 10,\\r\\n        \\"description\\": \\"If condition CC is true, ** is copied to PC.\\",\\r\\n        \\"instruction\\": \\"jp nc,**\\"\\r\\n    }\\r\\n};\\r\\n// jp c,nnnn\\r\\nconst variant_DA_nnnn = {\\r\\n    \\"mnemonic\\": \\"jp\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        218,\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DA\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 10,\\r\\n        \\"without_jump_clock_count\\": 10,\\r\\n        \\"description\\": \\"If condition CC is true, ** is copied to PC.\\",\\r\\n        \\"instruction\\": \\"jp c,**\\"\\r\\n    }\\r\\n};\\r\\n// jp ix\\r\\nconst variant_DD_E9 = {\\r\\n    \\"mnemonic\\": \\"jp\\",\\r\\n    \\"params\\": [\\r\\n        \\"ix\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ix\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        233\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDE9\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Loads the value of IX into PC.\\",\\r\\n        \\"instruction\\": \\"jp (ix)\\"\\r\\n    }\\r\\n};\\r\\n// jp po,nnnn\\r\\nconst variant_E2_nnnn = {\\r\\n    \\"mnemonic\\": \\"jp\\",\\r\\n    \\"params\\": [\\r\\n        \\"po\\",\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"po\\",\\r\\n        \\",\\",\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        226,\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"E2\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 10,\\r\\n        \\"without_jump_clock_count\\": 10,\\r\\n        \\"description\\": \\"If condition CC is true, ** is copied to PC.\\",\\r\\n        \\"instruction\\": \\"jp po,**\\"\\r\\n    }\\r\\n};\\r\\n// jp hl\\r\\nconst variant_E9 = {\\r\\n    \\"mnemonic\\": \\"jp\\",\\r\\n    \\"params\\": [\\r\\n        \\"hl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"hl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        233\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"E9\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Loads the value of HL into PC.\\",\\r\\n        \\"instruction\\": \\"jp (hl)\\"\\r\\n    }\\r\\n};\\r\\n// jp (hl)\\r\\nconst variant_E9_pseudo = {\\r\\n    \\"mnemonic\\": \\"jp\\",\\r\\n    \\"params\\": [\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        233\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"E9\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Loads the value of HL into PC.\\",\\r\\n        \\"instruction\\": \\"jp (hl)\\"\\r\\n    }\\r\\n};\\r\\n// jp pe,nnnn\\r\\nconst variant_EA_nnnn = {\\r\\n    \\"mnemonic\\": \\"jp\\",\\r\\n    \\"params\\": [\\r\\n        \\"pe\\",\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"pe\\",\\r\\n        \\",\\",\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        234,\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"EA\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 10,\\r\\n        \\"without_jump_clock_count\\": 10,\\r\\n        \\"description\\": \\"If condition CC is true, ** is copied to PC.\\",\\r\\n        \\"instruction\\": \\"jp pe,**\\"\\r\\n    }\\r\\n};\\r\\n// jp p,nnnn\\r\\nconst variant_F2_nnnn = {\\r\\n    \\"mnemonic\\": \\"jp\\",\\r\\n    \\"params\\": [\\r\\n        \\"p\\",\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"p\\",\\r\\n        \\",\\",\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        242,\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"F2\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 10,\\r\\n        \\"without_jump_clock_count\\": 10,\\r\\n        \\"description\\": \\"If condition CC is true, ** is copied to PC.\\",\\r\\n        \\"instruction\\": \\"jp p,**\\"\\r\\n    }\\r\\n};\\r\\n// jp m,nnnn\\r\\nconst variant_FA_nnnn = {\\r\\n    \\"mnemonic\\": \\"jp\\",\\r\\n    \\"params\\": [\\r\\n        \\"m\\",\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"m\\",\\r\\n        \\",\\",\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        250,\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FA\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 10,\\r\\n        \\"without_jump_clock_count\\": 10,\\r\\n        \\"description\\": \\"If condition CC is true, ** is copied to PC.\\",\\r\\n        \\"instruction\\": \\"jp m,**\\"\\r\\n    }\\r\\n};\\r\\n// jp iy\\r\\nconst variant_FD_E9 = {\\r\\n    \\"mnemonic\\": \\"jp\\",\\r\\n    \\"params\\": [\\r\\n        \\"iy\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iy\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        233\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDE9\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Loads the value of IY into PC.\\",\\r\\n        \\"instruction\\": \\"jp (iy)\\"\\r\\n    }\\r\\n};\\r\\n// call nz,nnnn\\r\\nconst variant_C4_nnnn = {\\r\\n    \\"mnemonic\\": \\"call\\",\\r\\n    \\"params\\": [\\r\\n        \\"nz\\",\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"nz\\",\\r\\n        \\",\\",\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        196,\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"C4\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 17,\\r\\n        \\"without_jump_clock_count\\": 10,\\r\\n        \\"description\\": \\"If condition CC is true, the current PC value plus three is pushed onto the stack, then is loaded with **.\\",\\r\\n        \\"instruction\\": \\"call nz,**\\"\\r\\n    }\\r\\n};\\r\\n// call z,nnnn\\r\\nconst variant_CC_nnnn = {\\r\\n    \\"mnemonic\\": \\"call\\",\\r\\n    \\"params\\": [\\r\\n        \\"z\\",\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"z\\",\\r\\n        \\",\\",\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        204,\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CC\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 17,\\r\\n        \\"without_jump_clock_count\\": 10,\\r\\n        \\"description\\": \\"If condition CC is true, the current PC value plus three is pushed onto the stack, then is loaded with **.\\",\\r\\n        \\"instruction\\": \\"call z,**\\"\\r\\n    }\\r\\n};\\r\\n// call nnnn\\r\\nconst variant_CD_nnnn = {\\r\\n    \\"mnemonic\\": \\"call\\",\\r\\n    \\"params\\": [\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        205,\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CD\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 17,\\r\\n        \\"without_jump_clock_count\\": 17,\\r\\n        \\"description\\": \\"The current PC value plus three is pushed onto the stack, then is loaded with **.\\",\\r\\n        \\"instruction\\": \\"call **\\"\\r\\n    }\\r\\n};\\r\\n// call nc,nnnn\\r\\nconst variant_D4_nnnn = {\\r\\n    \\"mnemonic\\": \\"call\\",\\r\\n    \\"params\\": [\\r\\n        \\"nc\\",\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"nc\\",\\r\\n        \\",\\",\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        212,\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"D4\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 17,\\r\\n        \\"without_jump_clock_count\\": 10,\\r\\n        \\"description\\": \\"If condition CC is true, the current PC value plus three is pushed onto the stack, then is loaded with **.\\",\\r\\n        \\"instruction\\": \\"call nc,**\\"\\r\\n    }\\r\\n};\\r\\n// call c,nnnn\\r\\nconst variant_DC_nnnn = {\\r\\n    \\"mnemonic\\": \\"call\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        220,\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DC\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 17,\\r\\n        \\"without_jump_clock_count\\": 10,\\r\\n        \\"description\\": \\"If condition CC is true, the current PC value plus three is pushed onto the stack, then is loaded with **.\\",\\r\\n        \\"instruction\\": \\"call c,**\\"\\r\\n    }\\r\\n};\\r\\n// call po,nnnn\\r\\nconst variant_E4_nnnn = {\\r\\n    \\"mnemonic\\": \\"call\\",\\r\\n    \\"params\\": [\\r\\n        \\"po\\",\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"po\\",\\r\\n        \\",\\",\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        228,\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"E4\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 17,\\r\\n        \\"without_jump_clock_count\\": 10,\\r\\n        \\"description\\": \\"If condition CC is true, the current PC value plus three is pushed onto the stack, then is loaded with **.\\",\\r\\n        \\"instruction\\": \\"call po,**\\"\\r\\n    }\\r\\n};\\r\\n// call pe,nnnn\\r\\nconst variant_EC_nnnn = {\\r\\n    \\"mnemonic\\": \\"call\\",\\r\\n    \\"params\\": [\\r\\n        \\"pe\\",\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"pe\\",\\r\\n        \\",\\",\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        236,\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"EC\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 17,\\r\\n        \\"without_jump_clock_count\\": 10,\\r\\n        \\"description\\": \\"If condition CC is true, the current PC value plus three is pushed onto the stack, then is loaded with **.\\",\\r\\n        \\"instruction\\": \\"call pe,**\\"\\r\\n    }\\r\\n};\\r\\n// call p,nnnn\\r\\nconst variant_F4_nnnn = {\\r\\n    \\"mnemonic\\": \\"call\\",\\r\\n    \\"params\\": [\\r\\n        \\"p\\",\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"p\\",\\r\\n        \\",\\",\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        244,\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"F4\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 17,\\r\\n        \\"without_jump_clock_count\\": 10,\\r\\n        \\"description\\": \\"If condition CC is true, the current PC value plus three is pushed onto the stack, then is loaded with **.\\",\\r\\n        \\"instruction\\": \\"call p,**\\"\\r\\n    }\\r\\n};\\r\\n// call m,nnnn\\r\\nconst variant_FC_nnnn = {\\r\\n    \\"mnemonic\\": \\"call\\",\\r\\n    \\"params\\": [\\r\\n        \\"m\\",\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"m\\",\\r\\n        \\",\\",\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        252,\\r\\n        \\"nnnn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FC\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 3,\\r\\n        \\"with_jump_clock_count\\": 17,\\r\\n        \\"without_jump_clock_count\\": 10,\\r\\n        \\"description\\": \\"If condition CC is true, the current PC value plus three is pushed onto the stack, then is loaded with **.\\",\\r\\n        \\"instruction\\": \\"call m,**\\"\\r\\n    }\\r\\n};\\r\\n// push bc\\r\\nconst variant_C5 = {\\r\\n    \\"mnemonic\\": \\"push\\",\\r\\n    \\"params\\": [\\r\\n        \\"bc\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"bc\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        197\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"C5\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 11,\\r\\n        \\"without_jump_clock_count\\": 11,\\r\\n        \\"description\\": \\"SP is decremented and B is stored into the memory location pointed to by SP. SP is decremented again and C is stored into the memory location pointed to by SP.\\",\\r\\n        \\"instruction\\": \\"push bc\\"\\r\\n    }\\r\\n};\\r\\n// push de\\r\\nconst variant_D5 = {\\r\\n    \\"mnemonic\\": \\"push\\",\\r\\n    \\"params\\": [\\r\\n        \\"de\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"de\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        213\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"D5\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 11,\\r\\n        \\"without_jump_clock_count\\": 11,\\r\\n        \\"description\\": \\"SP is decremented and D is stored into the memory location pointed to by SP. SP is decremented again and E is stored into the memory location pointed to by SP.\\",\\r\\n        \\"instruction\\": \\"push de\\"\\r\\n    }\\r\\n};\\r\\n// push ix\\r\\nconst variant_DD_E5 = {\\r\\n    \\"mnemonic\\": \\"push\\",\\r\\n    \\"params\\": [\\r\\n        \\"ix\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"ix\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        229\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDE5\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 15,\\r\\n        \\"without_jump_clock_count\\": 15,\\r\\n        \\"description\\": \\"SP is decremented and IXH is stored into the memory location pointed to by SP. SP is decremented again and IXL is stored into the memory location pointed to by SP.\\",\\r\\n        \\"instruction\\": \\"push ix\\"\\r\\n    }\\r\\n};\\r\\n// push hl\\r\\nconst variant_E5 = {\\r\\n    \\"mnemonic\\": \\"push\\",\\r\\n    \\"params\\": [\\r\\n        \\"hl\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"hl\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        229\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"E5\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 11,\\r\\n        \\"without_jump_clock_count\\": 11,\\r\\n        \\"description\\": \\"SP is decremented and H is stored into the memory location pointed to by SP. SP is decremented again and L is stored into the memory location pointed to by SP.\\",\\r\\n        \\"instruction\\": \\"push hl\\"\\r\\n    }\\r\\n};\\r\\n// push af\\r\\nconst variant_F5 = {\\r\\n    \\"mnemonic\\": \\"push\\",\\r\\n    \\"params\\": [\\r\\n        \\"af\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"af\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        245\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"F5\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 11,\\r\\n        \\"without_jump_clock_count\\": 11,\\r\\n        \\"description\\": \\"SP is decremented and A is stored into the memory location pointed to by SP. SP is decremented again and F is stored into the memory location pointed to by SP.\\",\\r\\n        \\"instruction\\": \\"push af\\"\\r\\n    }\\r\\n};\\r\\n// push iy\\r\\nconst variant_FD_E5 = {\\r\\n    \\"mnemonic\\": \\"push\\",\\r\\n    \\"params\\": [\\r\\n        \\"iy\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"iy\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        229\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDE5\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 15,\\r\\n        \\"without_jump_clock_count\\": 15,\\r\\n        \\"description\\": \\"SP is decremented and IYH is stored into the memory location pointed to by SP. SP is decremented again and IYL is stored into the memory location pointed to by SP.\\",\\r\\n        \\"instruction\\": \\"push iy\\"\\r\\n    }\\r\\n};\\r\\n// rst 00\\r\\nconst variant_C7 = {\\r\\n    \\"mnemonic\\": \\"rst\\",\\r\\n    \\"params\\": [\\r\\n        \\"00\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        199\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"C7\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 11,\\r\\n        \\"without_jump_clock_count\\": 11,\\r\\n        \\"description\\": \\"The current PC value plus one is pushed onto the stack, then is loaded with 00h.\\",\\r\\n        \\"instruction\\": \\"rst 00h\\"\\r\\n    }\\r\\n};\\r\\n// rst 8\\r\\nconst variant_CF = {\\r\\n    \\"mnemonic\\": \\"rst\\",\\r\\n    \\"params\\": [\\r\\n        \\"8\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"8\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        207\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CF\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 11,\\r\\n        \\"without_jump_clock_count\\": 11,\\r\\n        \\"description\\": \\"The current PC value plus one is pushed onto the stack, then is loaded with 08h.\\",\\r\\n        \\"instruction\\": \\"rst 08h\\"\\r\\n    }\\r\\n};\\r\\n// rst 10\\r\\nconst variant_D7 = {\\r\\n    \\"mnemonic\\": \\"rst\\",\\r\\n    \\"params\\": [\\r\\n        \\"10\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"16\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        215\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"D7\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 11,\\r\\n        \\"without_jump_clock_count\\": 11,\\r\\n        \\"description\\": \\"The current PC value plus one is pushed onto the stack, then is loaded with 10h.\\",\\r\\n        \\"instruction\\": \\"rst 10h\\"\\r\\n    }\\r\\n};\\r\\n// rst 18\\r\\nconst variant_DF = {\\r\\n    \\"mnemonic\\": \\"rst\\",\\r\\n    \\"params\\": [\\r\\n        \\"18\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"24\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        223\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DF\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 11,\\r\\n        \\"without_jump_clock_count\\": 11,\\r\\n        \\"description\\": \\"The current PC value plus one is pushed onto the stack, then is loaded with 18h.\\",\\r\\n        \\"instruction\\": \\"rst 18h\\"\\r\\n    }\\r\\n};\\r\\n// rst 20\\r\\nconst variant_E7 = {\\r\\n    \\"mnemonic\\": \\"rst\\",\\r\\n    \\"params\\": [\\r\\n        \\"20\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"32\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        231\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"E7\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 11,\\r\\n        \\"without_jump_clock_count\\": 11,\\r\\n        \\"description\\": \\"The current PC value plus one is pushed onto the stack, then is loaded with 20h.\\",\\r\\n        \\"instruction\\": \\"rst 20h\\"\\r\\n    }\\r\\n};\\r\\n// rst 28\\r\\nconst variant_EF = {\\r\\n    \\"mnemonic\\": \\"rst\\",\\r\\n    \\"params\\": [\\r\\n        \\"28\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"40\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        239\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"EF\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 11,\\r\\n        \\"without_jump_clock_count\\": 11,\\r\\n        \\"description\\": \\"The current PC value plus one is pushed onto the stack, then is loaded with 28h.\\",\\r\\n        \\"instruction\\": \\"rst 28h\\"\\r\\n    }\\r\\n};\\r\\n// rst 30\\r\\nconst variant_F7 = {\\r\\n    \\"mnemonic\\": \\"rst\\",\\r\\n    \\"params\\": [\\r\\n        \\"30\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"48\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        247\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"F7\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 11,\\r\\n        \\"without_jump_clock_count\\": 11,\\r\\n        \\"description\\": \\"The current PC value plus one is pushed onto the stack, then is loaded with 30h.\\",\\r\\n        \\"instruction\\": \\"rst 30h\\"\\r\\n    }\\r\\n};\\r\\n// rst 38\\r\\nconst variant_FF = {\\r\\n    \\"mnemonic\\": \\"rst\\",\\r\\n    \\"params\\": [\\r\\n        \\"38\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"56\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        255\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FF\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 11,\\r\\n        \\"without_jump_clock_count\\": 11,\\r\\n        \\"description\\": \\"The current PC value plus one is pushed onto the stack, then is loaded with 38h.\\",\\r\\n        \\"instruction\\": \\"rst 38h\\"\\r\\n    }\\r\\n};\\r\\n// rlc b\\r\\nconst variant_CB_00 = {\\r\\n    \\"mnemonic\\": \\"rlc\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        0\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB00\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of B are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0.\\",\\r\\n        \\"instruction\\": \\"rlc b\\"\\r\\n    }\\r\\n};\\r\\n// rlc c\\r\\nconst variant_CB_01 = {\\r\\n    \\"mnemonic\\": \\"rlc\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        1\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB01\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of C are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0.\\",\\r\\n        \\"instruction\\": \\"rlc c\\"\\r\\n    }\\r\\n};\\r\\n// rlc d\\r\\nconst variant_CB_02 = {\\r\\n    \\"mnemonic\\": \\"rlc\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        2\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB02\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of D are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0.\\",\\r\\n        \\"instruction\\": \\"rlc d\\"\\r\\n    }\\r\\n};\\r\\n// rlc e\\r\\nconst variant_CB_03 = {\\r\\n    \\"mnemonic\\": \\"rlc\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        3\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB03\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of E are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0.\\",\\r\\n        \\"instruction\\": \\"rlc e\\"\\r\\n    }\\r\\n};\\r\\n// rlc h\\r\\nconst variant_CB_04 = {\\r\\n    \\"mnemonic\\": \\"rlc\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        4\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB04\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of H are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0.\\",\\r\\n        \\"instruction\\": \\"rlc h\\"\\r\\n    }\\r\\n};\\r\\n// rlc l\\r\\nconst variant_CB_05 = {\\r\\n    \\"mnemonic\\": \\"rlc\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        5\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB05\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of L are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0.\\",\\r\\n        \\"instruction\\": \\"rlc l\\"\\r\\n    }\\r\\n};\\r\\n// rlc (hl)\\r\\nconst variant_CB_06 = {\\r\\n    \\"mnemonic\\": \\"rlc\\",\\r\\n    \\"params\\": [\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        6\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB06\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 15,\\r\\n        \\"without_jump_clock_count\\": 15,\\r\\n        \\"description\\": \\"The contents of (HL) are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0.\\",\\r\\n        \\"instruction\\": \\"rlc (hl)\\"\\r\\n    }\\r\\n};\\r\\n// rlc a\\r\\nconst variant_CB_07 = {\\r\\n    \\"mnemonic\\": \\"rlc\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        7\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB07\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of A are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0.\\",\\r\\n        \\"instruction\\": \\"rlc a\\"\\r\\n    }\\r\\n};\\r\\n// rlc (ix+dd)\\r\\nconst variant_DD_CB_dd_06 = {\\r\\n    \\"mnemonic\\": \\"rlc\\",\\r\\n    \\"params\\": [\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        6\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**06\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0.\\",\\r\\n        \\"instruction\\": \\"rlc (ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// rlc (iy+dd)\\r\\nconst variant_FD_CB_dd_06 = {\\r\\n    \\"mnemonic\\": \\"rlc\\",\\r\\n    \\"params\\": [\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        6\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**06\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are rotated left one bit position. The contents of bit 7 are copied to the carry flag and bit 0.\\",\\r\\n        \\"instruction\\": \\"rlc (iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// rrc b\\r\\nconst variant_CB_08 = {\\r\\n    \\"mnemonic\\": \\"rrc\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        8\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB08\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of B are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7.\\",\\r\\n        \\"instruction\\": \\"rrc b\\"\\r\\n    }\\r\\n};\\r\\n// rrc c\\r\\nconst variant_CB_09 = {\\r\\n    \\"mnemonic\\": \\"rrc\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        9\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB09\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of C are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7.\\",\\r\\n        \\"instruction\\": \\"rrc c\\"\\r\\n    }\\r\\n};\\r\\n// rrc d\\r\\nconst variant_CB_0A = {\\r\\n    \\"mnemonic\\": \\"rrc\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        10\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB0A\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of D are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7.\\",\\r\\n        \\"instruction\\": \\"rrc d\\"\\r\\n    }\\r\\n};\\r\\n// rrc e\\r\\nconst variant_CB_0B = {\\r\\n    \\"mnemonic\\": \\"rrc\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        11\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB0B\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of E are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7.\\",\\r\\n        \\"instruction\\": \\"rrc e\\"\\r\\n    }\\r\\n};\\r\\n// rrc h\\r\\nconst variant_CB_0C = {\\r\\n    \\"mnemonic\\": \\"rrc\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        12\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB0C\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of H are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7.\\",\\r\\n        \\"instruction\\": \\"rrc h\\"\\r\\n    }\\r\\n};\\r\\n// rrc l\\r\\nconst variant_CB_0D = {\\r\\n    \\"mnemonic\\": \\"rrc\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        13\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB0D\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of L are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7.\\",\\r\\n        \\"instruction\\": \\"rrc l\\"\\r\\n    }\\r\\n};\\r\\n// rrc (hl)\\r\\nconst variant_CB_0E = {\\r\\n    \\"mnemonic\\": \\"rrc\\",\\r\\n    \\"params\\": [\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        14\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB0E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 15,\\r\\n        \\"without_jump_clock_count\\": 15,\\r\\n        \\"description\\": \\"The contents of (HL) are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7.\\",\\r\\n        \\"instruction\\": \\"rrc (hl)\\"\\r\\n    }\\r\\n};\\r\\n// rrc a\\r\\nconst variant_CB_0F = {\\r\\n    \\"mnemonic\\": \\"rrc\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        15\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB0F\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of A are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7.\\",\\r\\n        \\"instruction\\": \\"rrc a\\"\\r\\n    }\\r\\n};\\r\\n// rrc (ix+dd)\\r\\nconst variant_DD_CB_dd_0E = {\\r\\n    \\"mnemonic\\": \\"rrc\\",\\r\\n    \\"params\\": [\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        14\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**0E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7.\\",\\r\\n        \\"instruction\\": \\"rrc (ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// rrc (iy+dd)\\r\\nconst variant_FD_CB_dd_0E = {\\r\\n    \\"mnemonic\\": \\"rrc\\",\\r\\n    \\"params\\": [\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        14\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**0E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are rotated right one bit position. The contents of bit 0 are copied to the carry flag and bit 7.\\",\\r\\n        \\"instruction\\": \\"rrc (iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// rl b\\r\\nconst variant_CB_10 = {\\r\\n    \\"mnemonic\\": \\"rl\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        16\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB10\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of B are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0.\\",\\r\\n        \\"instruction\\": \\"rl b\\"\\r\\n    }\\r\\n};\\r\\n// rl c\\r\\nconst variant_CB_11 = {\\r\\n    \\"mnemonic\\": \\"rl\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        17\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB11\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of C are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0.\\",\\r\\n        \\"instruction\\": \\"rl c\\"\\r\\n    }\\r\\n};\\r\\n// rl d\\r\\nconst variant_CB_12 = {\\r\\n    \\"mnemonic\\": \\"rl\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        18\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB12\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of D are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0.\\",\\r\\n        \\"instruction\\": \\"rl d\\"\\r\\n    }\\r\\n};\\r\\n// rl e\\r\\nconst variant_CB_13 = {\\r\\n    \\"mnemonic\\": \\"rl\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        19\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB13\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of E are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0.\\",\\r\\n        \\"instruction\\": \\"rl e\\"\\r\\n    }\\r\\n};\\r\\n// rl h\\r\\nconst variant_CB_14 = {\\r\\n    \\"mnemonic\\": \\"rl\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        20\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB14\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of H are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0.\\",\\r\\n        \\"instruction\\": \\"rl h\\"\\r\\n    }\\r\\n};\\r\\n// rl l\\r\\nconst variant_CB_15 = {\\r\\n    \\"mnemonic\\": \\"rl\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        21\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB15\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of L are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0.\\",\\r\\n        \\"instruction\\": \\"rl l\\"\\r\\n    }\\r\\n};\\r\\n// rl (hl)\\r\\nconst variant_CB_16 = {\\r\\n    \\"mnemonic\\": \\"rl\\",\\r\\n    \\"params\\": [\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        22\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB16\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 15,\\r\\n        \\"without_jump_clock_count\\": 15,\\r\\n        \\"description\\": \\"The contents of (HL) are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0.\\",\\r\\n        \\"instruction\\": \\"rl (hl)\\"\\r\\n    }\\r\\n};\\r\\n// rl a\\r\\nconst variant_CB_17 = {\\r\\n    \\"mnemonic\\": \\"rl\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        23\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB17\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of A are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0.\\",\\r\\n        \\"instruction\\": \\"rl a\\"\\r\\n    }\\r\\n};\\r\\n// rl (ix+dd)\\r\\nconst variant_DD_CB_dd_16 = {\\r\\n    \\"mnemonic\\": \\"rl\\",\\r\\n    \\"params\\": [\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        22\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**16\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0.\\",\\r\\n        \\"instruction\\": \\"rl (ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// rl (iy+dd)\\r\\nconst variant_FD_CB_dd_16 = {\\r\\n    \\"mnemonic\\": \\"rl\\",\\r\\n    \\"params\\": [\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        22\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**16\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are rotated left one bit position. The contents of bit 7 are copied to the carry flag and the previous contents of the carry flag are copied to bit 0.\\",\\r\\n        \\"instruction\\": \\"rl (iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// rr b\\r\\nconst variant_CB_18 = {\\r\\n    \\"mnemonic\\": \\"rr\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        24\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB18\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of B are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7.\\",\\r\\n        \\"instruction\\": \\"rr b\\"\\r\\n    }\\r\\n};\\r\\n// rr c\\r\\nconst variant_CB_19 = {\\r\\n    \\"mnemonic\\": \\"rr\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        25\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB19\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of C are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7.\\",\\r\\n        \\"instruction\\": \\"rr c\\"\\r\\n    }\\r\\n};\\r\\n// rr d\\r\\nconst variant_CB_1A = {\\r\\n    \\"mnemonic\\": \\"rr\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        26\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB1A\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of D are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7.\\",\\r\\n        \\"instruction\\": \\"rr d\\"\\r\\n    }\\r\\n};\\r\\n// rr e\\r\\nconst variant_CB_1B = {\\r\\n    \\"mnemonic\\": \\"rr\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        27\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB1B\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of E are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7.\\",\\r\\n        \\"instruction\\": \\"rr e\\"\\r\\n    }\\r\\n};\\r\\n// rr h\\r\\nconst variant_CB_1C = {\\r\\n    \\"mnemonic\\": \\"rr\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        28\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB1C\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of H are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7.\\",\\r\\n        \\"instruction\\": \\"rr h\\"\\r\\n    }\\r\\n};\\r\\n// rr l\\r\\nconst variant_CB_1D = {\\r\\n    \\"mnemonic\\": \\"rr\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        29\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB1D\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of L are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7.\\",\\r\\n        \\"instruction\\": \\"rr l\\"\\r\\n    }\\r\\n};\\r\\n// rr (hl)\\r\\nconst variant_CB_1E = {\\r\\n    \\"mnemonic\\": \\"rr\\",\\r\\n    \\"params\\": [\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        30\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB1E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 15,\\r\\n        \\"without_jump_clock_count\\": 15,\\r\\n        \\"description\\": \\"The contents of (HL) are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7.\\",\\r\\n        \\"instruction\\": \\"rr (hl)\\"\\r\\n    }\\r\\n};\\r\\n// rr a\\r\\nconst variant_CB_1F = {\\r\\n    \\"mnemonic\\": \\"rr\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        31\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB1F\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of A are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7.\\",\\r\\n        \\"instruction\\": \\"rr a\\"\\r\\n    }\\r\\n};\\r\\n// rr (ix+dd)\\r\\nconst variant_DD_CB_dd_1E = {\\r\\n    \\"mnemonic\\": \\"rr\\",\\r\\n    \\"params\\": [\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        30\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**1E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7.\\",\\r\\n        \\"instruction\\": \\"rr (ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// rr (iy+dd)\\r\\nconst variant_FD_CB_dd_1E = {\\r\\n    \\"mnemonic\\": \\"rr\\",\\r\\n    \\"params\\": [\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        30\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**1E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are rotated right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of the carry flag are copied to bit 7.\\",\\r\\n        \\"instruction\\": \\"rr (iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// sla b\\r\\nconst variant_CB_20 = {\\r\\n    \\"mnemonic\\": \\"sla\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        32\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB20\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of B are shifted left one bit position. The contents of bit 7 are copied to the carry flag and a zero is put into bit 0.\\",\\r\\n        \\"instruction\\": \\"sla b\\"\\r\\n    }\\r\\n};\\r\\n// sla c\\r\\nconst variant_CB_21 = {\\r\\n    \\"mnemonic\\": \\"sla\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        33\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB21\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of C are shifted left one bit position. The contents of bit 7 are copied to the carry flag and a zero is put into bit 0.\\",\\r\\n        \\"instruction\\": \\"sla c\\"\\r\\n    }\\r\\n};\\r\\n// sla d\\r\\nconst variant_CB_22 = {\\r\\n    \\"mnemonic\\": \\"sla\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        34\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB22\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of D are shifted left one bit position. The contents of bit 7 are copied to the carry flag and a zero is put into bit 0.\\",\\r\\n        \\"instruction\\": \\"sla d\\"\\r\\n    }\\r\\n};\\r\\n// sla e\\r\\nconst variant_CB_23 = {\\r\\n    \\"mnemonic\\": \\"sla\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        35\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB23\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of E are shifted left one bit position. The contents of bit 7 are copied to the carry flag and a zero is put into bit 0.\\",\\r\\n        \\"instruction\\": \\"sla e\\"\\r\\n    }\\r\\n};\\r\\n// sla h\\r\\nconst variant_CB_24 = {\\r\\n    \\"mnemonic\\": \\"sla\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        36\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB24\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of H are shifted left one bit position. The contents of bit 7 are copied to the carry flag and a zero is put into bit 0.\\",\\r\\n        \\"instruction\\": \\"sla h\\"\\r\\n    }\\r\\n};\\r\\n// sla l\\r\\nconst variant_CB_25 = {\\r\\n    \\"mnemonic\\": \\"sla\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        37\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB25\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of L are shifted left one bit position. The contents of bit 7 are copied to the carry flag and a zero is put into bit 0.\\",\\r\\n        \\"instruction\\": \\"sla l\\"\\r\\n    }\\r\\n};\\r\\n// sla (hl)\\r\\nconst variant_CB_26 = {\\r\\n    \\"mnemonic\\": \\"sla\\",\\r\\n    \\"params\\": [\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        38\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB26\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 15,\\r\\n        \\"without_jump_clock_count\\": 15,\\r\\n        \\"description\\": \\"The contents of (HL) are shifted left one bit position. The contents of bit 7 are copied to the carry flag and a zero is put into bit 0.\\",\\r\\n        \\"instruction\\": \\"sla (hl)\\"\\r\\n    }\\r\\n};\\r\\n// sla a\\r\\nconst variant_CB_27 = {\\r\\n    \\"mnemonic\\": \\"sla\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        39\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB27\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of A are shifted left one bit position. The contents of bit 7 are copied to the carry flag and a zero is put into bit 0.\\",\\r\\n        \\"instruction\\": \\"sla a\\"\\r\\n    }\\r\\n};\\r\\n// sla (ix+dd)\\r\\nconst variant_DD_CB_dd_26 = {\\r\\n    \\"mnemonic\\": \\"sla\\",\\r\\n    \\"params\\": [\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        38\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**26\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are shifted left one bit position. The contents of bit 7 are copied to the carry flag and a zero is put into bit 0.\\",\\r\\n        \\"instruction\\": \\"sla (ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// sla (iy+dd)\\r\\nconst variant_FD_CB_dd_26 = {\\r\\n    \\"mnemonic\\": \\"sla\\",\\r\\n    \\"params\\": [\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        38\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**26\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are shifted left one bit position. The contents of bit 7 are copied to the carry flag and a zero is put into bit 0.\\",\\r\\n        \\"instruction\\": \\"sla (iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// sra b\\r\\nconst variant_CB_28 = {\\r\\n    \\"mnemonic\\": \\"sra\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        40\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB28\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of B are shifted right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of bit 7 are unchanged.\\",\\r\\n        \\"instruction\\": \\"sra b\\"\\r\\n    }\\r\\n};\\r\\n// sra c\\r\\nconst variant_CB_29 = {\\r\\n    \\"mnemonic\\": \\"sra\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        41\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB29\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of C are shifted right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of bit 7 are unchanged.\\",\\r\\n        \\"instruction\\": \\"sra c\\"\\r\\n    }\\r\\n};\\r\\n// sra d\\r\\nconst variant_CB_2A = {\\r\\n    \\"mnemonic\\": \\"sra\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        42\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB2A\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of D are shifted right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of bit 7 are unchanged.\\",\\r\\n        \\"instruction\\": \\"sra d\\"\\r\\n    }\\r\\n};\\r\\n// sra e\\r\\nconst variant_CB_2B = {\\r\\n    \\"mnemonic\\": \\"sra\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        43\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB2B\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of E are shifted right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of bit 7 are unchanged.\\",\\r\\n        \\"instruction\\": \\"sra e\\"\\r\\n    }\\r\\n};\\r\\n// sra h\\r\\nconst variant_CB_2C = {\\r\\n    \\"mnemonic\\": \\"sra\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        44\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB2C\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of H are shifted right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of bit 7 are unchanged.\\",\\r\\n        \\"instruction\\": \\"sra h\\"\\r\\n    }\\r\\n};\\r\\n// sra l\\r\\nconst variant_CB_2D = {\\r\\n    \\"mnemonic\\": \\"sra\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        45\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB2D\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of L are shifted right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of bit 7 are unchanged.\\",\\r\\n        \\"instruction\\": \\"sra l\\"\\r\\n    }\\r\\n};\\r\\n// sra (hl)\\r\\nconst variant_CB_2E = {\\r\\n    \\"mnemonic\\": \\"sra\\",\\r\\n    \\"params\\": [\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        46\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB2E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 15,\\r\\n        \\"without_jump_clock_count\\": 15,\\r\\n        \\"description\\": \\"The contents of (HL) are shifted right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of bit 7 are unchanged.\\",\\r\\n        \\"instruction\\": \\"sra (hl)\\"\\r\\n    }\\r\\n};\\r\\n// sra a\\r\\nconst variant_CB_2F = {\\r\\n    \\"mnemonic\\": \\"sra\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        47\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB2F\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of A are shifted right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of bit 7 are unchanged.\\",\\r\\n        \\"instruction\\": \\"sra a\\"\\r\\n    }\\r\\n};\\r\\n// sra (ix+dd)\\r\\nconst variant_DD_CB_dd_2E = {\\r\\n    \\"mnemonic\\": \\"sra\\",\\r\\n    \\"params\\": [\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        46\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**2E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are shifted right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of bit 7 are unchanged.\\",\\r\\n        \\"instruction\\": \\"sra (ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// sra (iy+dd)\\r\\nconst variant_FD_CB_dd_2E = {\\r\\n    \\"mnemonic\\": \\"sra\\",\\r\\n    \\"params\\": [\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        46\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**2E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are shifted right one bit position. The contents of bit 0 are copied to the carry flag and the previous contents of bit 7 are unchanged.\\",\\r\\n        \\"instruction\\": \\"sra (iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// sll b\\r\\nconst variant_CB_30 = {\\r\\n    \\"mnemonic\\": \\"sll\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        48\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB30\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of B are shifted left one bit position. The contents of bit 7 are put into the carry flag and a one is put into bit 0.\\",\\r\\n        \\"instruction\\": \\"sll b\\"\\r\\n    }\\r\\n};\\r\\n// sll c\\r\\nconst variant_CB_31 = {\\r\\n    \\"mnemonic\\": \\"sll\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        49\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB31\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of C are shifted left one bit position. The contents of bit 7 are put into the carry flag and a one is put into bit 0.\\",\\r\\n        \\"instruction\\": \\"sll c\\"\\r\\n    }\\r\\n};\\r\\n// sll d\\r\\nconst variant_CB_32 = {\\r\\n    \\"mnemonic\\": \\"sll\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        50\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB32\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of D are shifted left one bit position. The contents of bit 7 are put into the carry flag and a one is put into bit 0.\\",\\r\\n        \\"instruction\\": \\"sll d\\"\\r\\n    }\\r\\n};\\r\\n// sll e\\r\\nconst variant_CB_33 = {\\r\\n    \\"mnemonic\\": \\"sll\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        51\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB33\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of E are shifted left one bit position. The contents of bit 7 are put into the carry flag and a one is put into bit 0.\\",\\r\\n        \\"instruction\\": \\"sll e\\"\\r\\n    }\\r\\n};\\r\\n// sll h\\r\\nconst variant_CB_34 = {\\r\\n    \\"mnemonic\\": \\"sll\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        52\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB34\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of H are shifted left one bit position. The contents of bit 7 are put into the carry flag and a one is put into bit 0.\\",\\r\\n        \\"instruction\\": \\"sll h\\"\\r\\n    }\\r\\n};\\r\\n// sll l\\r\\nconst variant_CB_35 = {\\r\\n    \\"mnemonic\\": \\"sll\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        53\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB35\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of L are shifted left one bit position. The contents of bit 7 are put into the carry flag and a one is put into bit 0.\\",\\r\\n        \\"instruction\\": \\"sll l\\"\\r\\n    }\\r\\n};\\r\\n// sll (hl)\\r\\nconst variant_CB_36 = {\\r\\n    \\"mnemonic\\": \\"sll\\",\\r\\n    \\"params\\": [\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        54\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB36\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 15,\\r\\n        \\"without_jump_clock_count\\": 15,\\r\\n        \\"description\\": \\"The contents of (HL) are shifted left one bit position. The contents of bit 7 are put into the carry flag and a one is put into bit 0.\\",\\r\\n        \\"instruction\\": \\"sll (hl)\\"\\r\\n    }\\r\\n};\\r\\n// sll a\\r\\nconst variant_CB_37 = {\\r\\n    \\"mnemonic\\": \\"sll\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        55\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB37\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of A are shifted left one bit position. The contents of bit 7 are put into the carry flag and a one is put into bit 0.\\",\\r\\n        \\"instruction\\": \\"sll a\\"\\r\\n    }\\r\\n};\\r\\n// sll (ix+dd)\\r\\nconst variant_DD_CB_dd_36 = {\\r\\n    \\"mnemonic\\": \\"sll\\",\\r\\n    \\"params\\": [\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        54\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**36\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are shifted left one bit position. The contents of bit 7 are put into the carry flag and a one is put into bit 0.\\",\\r\\n        \\"instruction\\": \\"sll (ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// sll (iy+dd)\\r\\nconst variant_FD_CB_dd_36 = {\\r\\n    \\"mnemonic\\": \\"sll\\",\\r\\n    \\"params\\": [\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        54\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**36\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are shifted left one bit position. The contents of bit 7 are put into the carry flag and a one is put into bit 0.\\",\\r\\n        \\"instruction\\": \\"sll (iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// srl b\\r\\nconst variant_CB_38 = {\\r\\n    \\"mnemonic\\": \\"srl\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        56\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB38\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of B are shifted right one bit position. The contents of bit 0 are copied to the carry flag and a zero is put into bit 7.\\",\\r\\n        \\"instruction\\": \\"srl b\\"\\r\\n    }\\r\\n};\\r\\n// srl c\\r\\nconst variant_CB_39 = {\\r\\n    \\"mnemonic\\": \\"srl\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        57\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB39\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of C are shifted right one bit position. The contents of bit 0 are copied to the carry flag and a zero is put into bit 7.\\",\\r\\n        \\"instruction\\": \\"srl c\\"\\r\\n    }\\r\\n};\\r\\n// srl d\\r\\nconst variant_CB_3A = {\\r\\n    \\"mnemonic\\": \\"srl\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        58\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB3A\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of D are shifted right one bit position. The contents of bit 0 are copied to the carry flag and a zero is put into bit 7.\\",\\r\\n        \\"instruction\\": \\"srl d\\"\\r\\n    }\\r\\n};\\r\\n// srl e\\r\\nconst variant_CB_3B = {\\r\\n    \\"mnemonic\\": \\"srl\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        59\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB3B\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of E are shifted right one bit position. The contents of bit 0 are copied to the carry flag and a zero is put into bit 7.\\",\\r\\n        \\"instruction\\": \\"srl e\\"\\r\\n    }\\r\\n};\\r\\n// srl h\\r\\nconst variant_CB_3C = {\\r\\n    \\"mnemonic\\": \\"srl\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        60\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB3C\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of H are shifted right one bit position. The contents of bit 0 are copied to the carry flag and a zero is put into bit 7.\\",\\r\\n        \\"instruction\\": \\"srl h\\"\\r\\n    }\\r\\n};\\r\\n// srl l\\r\\nconst variant_CB_3D = {\\r\\n    \\"mnemonic\\": \\"srl\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        61\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB3D\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of L are shifted right one bit position. The contents of bit 0 are copied to the carry flag and a zero is put into bit 7.\\",\\r\\n        \\"instruction\\": \\"srl l\\"\\r\\n    }\\r\\n};\\r\\n// srl (hl)\\r\\nconst variant_CB_3E = {\\r\\n    \\"mnemonic\\": \\"srl\\",\\r\\n    \\"params\\": [\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        62\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB3E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 15,\\r\\n        \\"without_jump_clock_count\\": 15,\\r\\n        \\"description\\": \\"The contents of (HL) are shifted right one bit position. The contents of bit 0 are copied to the carry flag and a zero is put into bit 7.\\",\\r\\n        \\"instruction\\": \\"srl (hl)\\"\\r\\n    }\\r\\n};\\r\\n// srl a\\r\\nconst variant_CB_3F = {\\r\\n    \\"mnemonic\\": \\"srl\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        63\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB3F\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of A are shifted right one bit position. The contents of bit 0 are copied to the carry flag and a zero is put into bit 7.\\",\\r\\n        \\"instruction\\": \\"srl a\\"\\r\\n    }\\r\\n};\\r\\n// srl (ix+dd)\\r\\nconst variant_DD_CB_dd_3E = {\\r\\n    \\"mnemonic\\": \\"srl\\",\\r\\n    \\"params\\": [\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        62\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**3E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IX plus * are shifted right one bit position. The contents of bit 0 are copied to the carry flag and a zero is put into bit 7.\\",\\r\\n        \\"instruction\\": \\"srl (ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// srl (iy+dd)\\r\\nconst variant_FD_CB_dd_3E = {\\r\\n    \\"mnemonic\\": \\"srl\\",\\r\\n    \\"params\\": [\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        62\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**3E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"+0P0++\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"The contents of the memory location pointed to by IY plus * are shifted right one bit position. The contents of bit 0 are copied to the carry flag and a zero is put into bit 7.\\",\\r\\n        \\"instruction\\": \\"srl (iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 0,b\\r\\nconst variant_CB_40 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        64\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB40\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 0 of B.\\",\\r\\n        \\"instruction\\": \\"bit 0,b\\"\\r\\n    }\\r\\n};\\r\\n// bit 0,c\\r\\nconst variant_CB_41 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        65\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB41\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 0 of C.\\",\\r\\n        \\"instruction\\": \\"bit 0,c\\"\\r\\n    }\\r\\n};\\r\\n// bit 0,d\\r\\nconst variant_CB_42 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        66\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB42\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 0 of D.\\",\\r\\n        \\"instruction\\": \\"bit 0,d\\"\\r\\n    }\\r\\n};\\r\\n// bit 0,e\\r\\nconst variant_CB_43 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        67\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB43\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 0 of E.\\",\\r\\n        \\"instruction\\": \\"bit 0,e\\"\\r\\n    }\\r\\n};\\r\\n// bit 0,h\\r\\nconst variant_CB_44 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        68\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB44\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 0 of H.\\",\\r\\n        \\"instruction\\": \\"bit 0,h\\"\\r\\n    }\\r\\n};\\r\\n// bit 0,l\\r\\nconst variant_CB_45 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        69\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB45\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 0 of L.\\",\\r\\n        \\"instruction\\": \\"bit 0,l\\"\\r\\n    }\\r\\n};\\r\\n// bit 0,(hl)\\r\\nconst variant_CB_46 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\",\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        70\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB46\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 12,\\r\\n        \\"without_jump_clock_count\\": 12,\\r\\n        \\"description\\": \\"Tests bit 0 of (HL).\\",\\r\\n        \\"instruction\\": \\"bit 0,(hl)\\"\\r\\n    }\\r\\n};\\r\\n// bit 0,a\\r\\nconst variant_CB_47 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        71\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB47\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 0 of A.\\",\\r\\n        \\"instruction\\": \\"bit 0,a\\"\\r\\n    }\\r\\n};\\r\\n// bit 1,b\\r\\nconst variant_CB_48 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"1\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        72\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB48\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 1 of B.\\",\\r\\n        \\"instruction\\": \\"bit 1,b\\"\\r\\n    }\\r\\n};\\r\\n// bit 1,c\\r\\nconst variant_CB_49 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"1\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        73\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB49\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 1 of C.\\",\\r\\n        \\"instruction\\": \\"bit 1,c\\"\\r\\n    }\\r\\n};\\r\\n// bit 1,d\\r\\nconst variant_CB_4A = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"1\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        74\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB4A\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 1 of D.\\",\\r\\n        \\"instruction\\": \\"bit 1,d\\"\\r\\n    }\\r\\n};\\r\\n// bit 1,e\\r\\nconst variant_CB_4B = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"1\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        75\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB4B\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 1 of E.\\",\\r\\n        \\"instruction\\": \\"bit 1,e\\"\\r\\n    }\\r\\n};\\r\\n// bit 1,h\\r\\nconst variant_CB_4C = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"1\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        76\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB4C\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 1 of H.\\",\\r\\n        \\"instruction\\": \\"bit 1,h\\"\\r\\n    }\\r\\n};\\r\\n// bit 1,l\\r\\nconst variant_CB_4D = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"1\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        77\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB4D\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 1 of L.\\",\\r\\n        \\"instruction\\": \\"bit 1,l\\"\\r\\n    }\\r\\n};\\r\\n// bit 1,(hl)\\r\\nconst variant_CB_4E = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"1\\",\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        78\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB4E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 12,\\r\\n        \\"without_jump_clock_count\\": 12,\\r\\n        \\"description\\": \\"Tests bit 1 of (HL).\\",\\r\\n        \\"instruction\\": \\"bit 1,(hl)\\"\\r\\n    }\\r\\n};\\r\\n// bit 1,a\\r\\nconst variant_CB_4F = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"1\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        79\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB4F\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 1 of A.\\",\\r\\n        \\"instruction\\": \\"bit 1,a\\"\\r\\n    }\\r\\n};\\r\\n// bit 2,b\\r\\nconst variant_CB_50 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"2\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        80\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB50\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 2 of B.\\",\\r\\n        \\"instruction\\": \\"bit 2,b\\"\\r\\n    }\\r\\n};\\r\\n// bit 2,c\\r\\nconst variant_CB_51 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"2\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        81\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB51\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 2 of C.\\",\\r\\n        \\"instruction\\": \\"bit 2,c\\"\\r\\n    }\\r\\n};\\r\\n// bit 2,d\\r\\nconst variant_CB_52 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"2\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        82\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB52\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 2 of D.\\",\\r\\n        \\"instruction\\": \\"bit 2,d\\"\\r\\n    }\\r\\n};\\r\\n// bit 2,e\\r\\nconst variant_CB_53 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"2\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        83\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB53\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 2 of E.\\",\\r\\n        \\"instruction\\": \\"bit 2,e\\"\\r\\n    }\\r\\n};\\r\\n// bit 2,h\\r\\nconst variant_CB_54 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"2\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        84\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB54\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 2 of H.\\",\\r\\n        \\"instruction\\": \\"bit 2,h\\"\\r\\n    }\\r\\n};\\r\\n// bit 2,l\\r\\nconst variant_CB_55 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"2\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        85\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB55\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 2 of L.\\",\\r\\n        \\"instruction\\": \\"bit 2,l\\"\\r\\n    }\\r\\n};\\r\\n// bit 2,(hl)\\r\\nconst variant_CB_56 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"2\\",\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        86\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB56\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 12,\\r\\n        \\"without_jump_clock_count\\": 12,\\r\\n        \\"description\\": \\"Tests bit 2 of (HL).\\",\\r\\n        \\"instruction\\": \\"bit 2,(hl)\\"\\r\\n    }\\r\\n};\\r\\n// bit 2,a\\r\\nconst variant_CB_57 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"2\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        87\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB57\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 2 of A.\\",\\r\\n        \\"instruction\\": \\"bit 2,a\\"\\r\\n    }\\r\\n};\\r\\n// bit 3,b\\r\\nconst variant_CB_58 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"3\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        88\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB58\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 3 of B.\\",\\r\\n        \\"instruction\\": \\"bit 3,b\\"\\r\\n    }\\r\\n};\\r\\n// bit 3,c\\r\\nconst variant_CB_59 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"3\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        89\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB59\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 3 of C.\\",\\r\\n        \\"instruction\\": \\"bit 3,c\\"\\r\\n    }\\r\\n};\\r\\n// bit 3,d\\r\\nconst variant_CB_5A = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"3\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        90\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB5A\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 3 of D.\\",\\r\\n        \\"instruction\\": \\"bit 3,d\\"\\r\\n    }\\r\\n};\\r\\n// bit 3,e\\r\\nconst variant_CB_5B = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"3\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        91\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB5B\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 3 of E.\\",\\r\\n        \\"instruction\\": \\"bit 3,e\\"\\r\\n    }\\r\\n};\\r\\n// bit 3,h\\r\\nconst variant_CB_5C = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"3\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        92\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB5C\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 3 of H.\\",\\r\\n        \\"instruction\\": \\"bit 3,h\\"\\r\\n    }\\r\\n};\\r\\n// bit 3,l\\r\\nconst variant_CB_5D = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"3\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        93\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB5D\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 3 of L.\\",\\r\\n        \\"instruction\\": \\"bit 3,l\\"\\r\\n    }\\r\\n};\\r\\n// bit 3,(hl)\\r\\nconst variant_CB_5E = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"3\\",\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        94\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB5E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 12,\\r\\n        \\"without_jump_clock_count\\": 12,\\r\\n        \\"description\\": \\"Tests bit 3 of (HL).\\",\\r\\n        \\"instruction\\": \\"bit 3,(hl)\\"\\r\\n    }\\r\\n};\\r\\n// bit 3,a\\r\\nconst variant_CB_5F = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"3\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        95\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB5F\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 3 of A.\\",\\r\\n        \\"instruction\\": \\"bit 3,a\\"\\r\\n    }\\r\\n};\\r\\n// bit 4,b\\r\\nconst variant_CB_60 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"4\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        96\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB60\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 4 of B.\\",\\r\\n        \\"instruction\\": \\"bit 4,b\\"\\r\\n    }\\r\\n};\\r\\n// bit 4,c\\r\\nconst variant_CB_61 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"4\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        97\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB61\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 4 of C.\\",\\r\\n        \\"instruction\\": \\"bit 4,c\\"\\r\\n    }\\r\\n};\\r\\n// bit 4,d\\r\\nconst variant_CB_62 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"4\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        98\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB62\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 4 of D.\\",\\r\\n        \\"instruction\\": \\"bit 4,d\\"\\r\\n    }\\r\\n};\\r\\n// bit 4,e\\r\\nconst variant_CB_63 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"4\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        99\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB63\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 4 of E.\\",\\r\\n        \\"instruction\\": \\"bit 4,e\\"\\r\\n    }\\r\\n};\\r\\n// bit 4,h\\r\\nconst variant_CB_64 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"4\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        100\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB64\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 4 of H.\\",\\r\\n        \\"instruction\\": \\"bit 4,h\\"\\r\\n    }\\r\\n};\\r\\n// bit 4,l\\r\\nconst variant_CB_65 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"4\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        101\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB65\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 4 of L.\\",\\r\\n        \\"instruction\\": \\"bit 4,l\\"\\r\\n    }\\r\\n};\\r\\n// bit 4,(hl)\\r\\nconst variant_CB_66 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"4\\",\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        102\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB66\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 12,\\r\\n        \\"without_jump_clock_count\\": 12,\\r\\n        \\"description\\": \\"Tests bit 4 of (HL).\\",\\r\\n        \\"instruction\\": \\"bit 4,(hl)\\"\\r\\n    }\\r\\n};\\r\\n// bit 4,a\\r\\nconst variant_CB_67 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"4\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        103\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB67\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 4 of A.\\",\\r\\n        \\"instruction\\": \\"bit 4,a\\"\\r\\n    }\\r\\n};\\r\\n// bit 5,b\\r\\nconst variant_CB_68 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"5\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        104\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB68\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 5 of B.\\",\\r\\n        \\"instruction\\": \\"bit 5,b\\"\\r\\n    }\\r\\n};\\r\\n// bit 5,c\\r\\nconst variant_CB_69 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"5\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        105\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB69\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 5 of C.\\",\\r\\n        \\"instruction\\": \\"bit 5,c\\"\\r\\n    }\\r\\n};\\r\\n// bit 5,d\\r\\nconst variant_CB_6A = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"5\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        106\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB6A\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 5 of D.\\",\\r\\n        \\"instruction\\": \\"bit 5,d\\"\\r\\n    }\\r\\n};\\r\\n// bit 5,e\\r\\nconst variant_CB_6B = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"5\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        107\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB6B\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 5 of E.\\",\\r\\n        \\"instruction\\": \\"bit 5,e\\"\\r\\n    }\\r\\n};\\r\\n// bit 5,h\\r\\nconst variant_CB_6C = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"5\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        108\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB6C\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 5 of H.\\",\\r\\n        \\"instruction\\": \\"bit 5,h\\"\\r\\n    }\\r\\n};\\r\\n// bit 5,l\\r\\nconst variant_CB_6D = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"5\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        109\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB6D\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 5 of L.\\",\\r\\n        \\"instruction\\": \\"bit 5,l\\"\\r\\n    }\\r\\n};\\r\\n// bit 5,(hl)\\r\\nconst variant_CB_6E = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"5\\",\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        110\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB6E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 12,\\r\\n        \\"without_jump_clock_count\\": 12,\\r\\n        \\"description\\": \\"Tests bit 5 of (HL).\\",\\r\\n        \\"instruction\\": \\"bit 5,(hl)\\"\\r\\n    }\\r\\n};\\r\\n// bit 5,a\\r\\nconst variant_CB_6F = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"5\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        111\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB6F\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 5 of A.\\",\\r\\n        \\"instruction\\": \\"bit 5,a\\"\\r\\n    }\\r\\n};\\r\\n// bit 6,b\\r\\nconst variant_CB_70 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"6\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        112\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB70\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 6 of B.\\",\\r\\n        \\"instruction\\": \\"bit 6,b\\"\\r\\n    }\\r\\n};\\r\\n// bit 6,c\\r\\nconst variant_CB_71 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"6\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        113\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB71\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 6 of C.\\",\\r\\n        \\"instruction\\": \\"bit 6,c\\"\\r\\n    }\\r\\n};\\r\\n// bit 6,d\\r\\nconst variant_CB_72 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"6\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        114\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB72\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 6 of D.\\",\\r\\n        \\"instruction\\": \\"bit 6,d\\"\\r\\n    }\\r\\n};\\r\\n// bit 6,e\\r\\nconst variant_CB_73 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"6\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        115\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB73\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 6 of E.\\",\\r\\n        \\"instruction\\": \\"bit 6,e\\"\\r\\n    }\\r\\n};\\r\\n// bit 6,h\\r\\nconst variant_CB_74 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"6\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        116\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB74\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 6 of H.\\",\\r\\n        \\"instruction\\": \\"bit 6,h\\"\\r\\n    }\\r\\n};\\r\\n// bit 6,l\\r\\nconst variant_CB_75 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"6\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        117\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB75\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 6 of L.\\",\\r\\n        \\"instruction\\": \\"bit 6,l\\"\\r\\n    }\\r\\n};\\r\\n// bit 6,(hl)\\r\\nconst variant_CB_76 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"6\\",\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        118\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB76\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 12,\\r\\n        \\"without_jump_clock_count\\": 12,\\r\\n        \\"description\\": \\"Tests bit 6 of (HL).\\",\\r\\n        \\"instruction\\": \\"bit 6,(hl)\\"\\r\\n    }\\r\\n};\\r\\n// bit 6,a\\r\\nconst variant_CB_77 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"6\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        119\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB77\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 6 of A.\\",\\r\\n        \\"instruction\\": \\"bit 6,a\\"\\r\\n    }\\r\\n};\\r\\n// bit 7,b\\r\\nconst variant_CB_78 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"7\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        120\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB78\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 7 of B.\\",\\r\\n        \\"instruction\\": \\"bit 7,b\\"\\r\\n    }\\r\\n};\\r\\n// bit 7,c\\r\\nconst variant_CB_79 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"7\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        121\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB79\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 7 of C.\\",\\r\\n        \\"instruction\\": \\"bit 7,c\\"\\r\\n    }\\r\\n};\\r\\n// bit 7,d\\r\\nconst variant_CB_7A = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"7\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        122\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB7A\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 7 of D.\\",\\r\\n        \\"instruction\\": \\"bit 7,d\\"\\r\\n    }\\r\\n};\\r\\n// bit 7,e\\r\\nconst variant_CB_7B = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"7\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        123\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB7B\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 7 of E.\\",\\r\\n        \\"instruction\\": \\"bit 7,e\\"\\r\\n    }\\r\\n};\\r\\n// bit 7,h\\r\\nconst variant_CB_7C = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"7\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        124\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB7C\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 7 of H.\\",\\r\\n        \\"instruction\\": \\"bit 7,h\\"\\r\\n    }\\r\\n};\\r\\n// bit 7,l\\r\\nconst variant_CB_7D = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"7\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        125\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB7D\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 7 of L.\\",\\r\\n        \\"instruction\\": \\"bit 7,l\\"\\r\\n    }\\r\\n};\\r\\n// bit 7,(hl)\\r\\nconst variant_CB_7E = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"7\\",\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        126\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB7E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 12,\\r\\n        \\"without_jump_clock_count\\": 12,\\r\\n        \\"description\\": \\"Tests bit 7 of (HL).\\",\\r\\n        \\"instruction\\": \\"bit 7,(hl)\\"\\r\\n    }\\r\\n};\\r\\n// bit 7,a\\r\\nconst variant_CB_7F = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"7\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        127\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB7F\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Tests bit 7 of A.\\",\\r\\n        \\"instruction\\": \\"bit 7,a\\"\\r\\n    }\\r\\n};\\r\\n// bit 0,(ix+dd)\\r\\nconst variant_DD_CB_dd_47 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        71\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**47\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 0 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 0,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 0,(ix+dd)\\r\\nconst variant_DD_CB_dd_40 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        64\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**47\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 0 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 0,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 0,(ix+dd)\\r\\nconst variant_DD_CB_dd_41 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        65\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**47\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 0 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 0,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 0,(ix+dd)\\r\\nconst variant_DD_CB_dd_42 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        66\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**47\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 0 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 0,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 0,(ix+dd)\\r\\nconst variant_DD_CB_dd_43 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        67\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**47\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 0 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 0,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 0,(ix+dd)\\r\\nconst variant_DD_CB_dd_44 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        68\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**47\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 0 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 0,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 0,(ix+dd)\\r\\nconst variant_DD_CB_dd_45 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        69\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**47\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 0 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 0,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 0,(ix+dd)\\r\\nconst variant_DD_CB_dd_46 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        70\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**47\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 0 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 0,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 1,(ix+dd)\\r\\nconst variant_DD_CB_dd_4F = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"1\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        79\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**4F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 1 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 1,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 1,(ix+dd)\\r\\nconst variant_DD_CB_dd_48 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"1\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        72\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**4F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 1 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 1,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 1,(ix+dd)\\r\\nconst variant_DD_CB_dd_49 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"1\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        73\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**4F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 1 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 1,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 1,(ix+dd)\\r\\nconst variant_DD_CB_dd_4A = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"1\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        74\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**4F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 1 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 1,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 1,(ix+dd)\\r\\nconst variant_DD_CB_dd_4B = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"1\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        75\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**4F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 1 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 1,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 1,(ix+dd)\\r\\nconst variant_DD_CB_dd_4C = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"1\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        76\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**4F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 1 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 1,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 1,(ix+dd)\\r\\nconst variant_DD_CB_dd_4D = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"1\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        77\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**4F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 1 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 1,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 1,(ix+dd)\\r\\nconst variant_DD_CB_dd_4E = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"1\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        78\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**4F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 1 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 1,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 2,(ix+dd)\\r\\nconst variant_DD_CB_dd_57 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"2\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        87\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**57\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 2 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 2,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 2,(ix+dd)\\r\\nconst variant_DD_CB_dd_50 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"2\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        80\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**57\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 2 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 2,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 2,(ix+dd)\\r\\nconst variant_DD_CB_dd_51 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"2\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        81\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**57\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 2 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 2,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 2,(ix+dd)\\r\\nconst variant_DD_CB_dd_52 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"2\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        82\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**57\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 2 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 2,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 2,(ix+dd)\\r\\nconst variant_DD_CB_dd_53 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"2\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        83\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**57\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 2 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 2,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 2,(ix+dd)\\r\\nconst variant_DD_CB_dd_54 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"2\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        84\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**57\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 2 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 2,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 2,(ix+dd)\\r\\nconst variant_DD_CB_dd_55 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"2\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        85\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**57\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 2 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 2,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 2,(ix+dd)\\r\\nconst variant_DD_CB_dd_56 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"2\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        86\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**57\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 2 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 2,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 3,(ix+dd)\\r\\nconst variant_DD_CB_dd_5F = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"3\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        95\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**5F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 3 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 3,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 3,(ix+dd)\\r\\nconst variant_DD_CB_dd_58 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"3\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        88\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**5F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 3 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 3,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 3,(ix+dd)\\r\\nconst variant_DD_CB_dd_59 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"3\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        89\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**5F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 3 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 3,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 3,(ix+dd)\\r\\nconst variant_DD_CB_dd_5A = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"3\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        90\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**5F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 3 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 3,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 3,(ix+dd)\\r\\nconst variant_DD_CB_dd_5B = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"3\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        91\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**5F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 3 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 3,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 3,(ix+dd)\\r\\nconst variant_DD_CB_dd_5C = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"3\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        92\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**5F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 3 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 3,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 3,(ix+dd)\\r\\nconst variant_DD_CB_dd_5D = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"3\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        93\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**5F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 3 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 3,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 3,(ix+dd)\\r\\nconst variant_DD_CB_dd_5E = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"3\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        94\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**5F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 3 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 3,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 4,(ix+dd)\\r\\nconst variant_DD_CB_dd_67 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"4\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        103\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**67\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 4 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 4,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 4,(ix+dd)\\r\\nconst variant_DD_CB_dd_60 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"4\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        96\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**67\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 4 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 4,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 4,(ix+dd)\\r\\nconst variant_DD_CB_dd_61 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"4\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        97\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**67\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 4 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 4,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 4,(ix+dd)\\r\\nconst variant_DD_CB_dd_62 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"4\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        98\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**67\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 4 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 4,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 4,(ix+dd)\\r\\nconst variant_DD_CB_dd_63 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"4\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        99\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**67\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 4 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 4,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 4,(ix+dd)\\r\\nconst variant_DD_CB_dd_64 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"4\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        100\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**67\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 4 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 4,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 4,(ix+dd)\\r\\nconst variant_DD_CB_dd_65 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"4\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        101\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**67\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 4 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 4,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 4,(ix+dd)\\r\\nconst variant_DD_CB_dd_66 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"4\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        102\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**67\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 4 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 4,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 5,(ix+dd)\\r\\nconst variant_DD_CB_dd_6F = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"5\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        111\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**6F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 5 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 5,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 5,(ix+dd)\\r\\nconst variant_DD_CB_dd_68 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"5\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        104\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**6F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 5 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 5,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 5,(ix+dd)\\r\\nconst variant_DD_CB_dd_69 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"5\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        105\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**6F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 5 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 5,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 5,(ix+dd)\\r\\nconst variant_DD_CB_dd_6A = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"5\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        106\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**6F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 5 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 5,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 5,(ix+dd)\\r\\nconst variant_DD_CB_dd_6B = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"5\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        107\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**6F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 5 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 5,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 5,(ix+dd)\\r\\nconst variant_DD_CB_dd_6C = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"5\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        108\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**6F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 5 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 5,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 5,(ix+dd)\\r\\nconst variant_DD_CB_dd_6D = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"5\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        109\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**6F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 5 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 5,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 5,(ix+dd)\\r\\nconst variant_DD_CB_dd_6E = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"5\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        110\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**6F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 5 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 5,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 6,(ix+dd)\\r\\nconst variant_DD_CB_dd_77 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"6\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        119\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**77\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 6 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 6,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 6,(ix+dd)\\r\\nconst variant_DD_CB_dd_70 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"6\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        112\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**77\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 6 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 6,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 6,(ix+dd)\\r\\nconst variant_DD_CB_dd_71 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"6\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        113\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**77\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 6 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 6,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 6,(ix+dd)\\r\\nconst variant_DD_CB_dd_72 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"6\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        114\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**77\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 6 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 6,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 6,(ix+dd)\\r\\nconst variant_DD_CB_dd_73 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"6\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        115\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**77\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 6 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 6,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 6,(ix+dd)\\r\\nconst variant_DD_CB_dd_74 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"6\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        116\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**77\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 6 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 6,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 6,(ix+dd)\\r\\nconst variant_DD_CB_dd_75 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"6\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        117\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**77\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 6 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 6,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 6,(ix+dd)\\r\\nconst variant_DD_CB_dd_76 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"6\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        118\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**77\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 6 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 6,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 7,(ix+dd)\\r\\nconst variant_DD_CB_dd_7F = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"7\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        127\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**7F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 7 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 7,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 7,(ix+dd)\\r\\nconst variant_DD_CB_dd_78 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"7\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        120\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**7F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 7 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 7,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 7,(ix+dd)\\r\\nconst variant_DD_CB_dd_79 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"7\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        121\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**7F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 7 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 7,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 7,(ix+dd)\\r\\nconst variant_DD_CB_dd_7A = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"7\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        122\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**7F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 7 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 7,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 7,(ix+dd)\\r\\nconst variant_DD_CB_dd_7B = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"7\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        123\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**7F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 7 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 7,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 7,(ix+dd)\\r\\nconst variant_DD_CB_dd_7C = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"7\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        124\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**7F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 7 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 7,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 7,(ix+dd)\\r\\nconst variant_DD_CB_dd_7D = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"7\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        125\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**7F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 7 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 7,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 7,(ix+dd)\\r\\nconst variant_DD_CB_dd_7E = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"7\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        126\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**7F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 7 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"bit 7,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 0,(iy+dd)\\r\\nconst variant_FD_CB_dd_47 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        71\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**47\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 0 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 0,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 0,(iy+dd)\\r\\nconst variant_FD_CB_dd_40 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        64\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**47\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 0 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 0,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 0,(iy+dd)\\r\\nconst variant_FD_CB_dd_41 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        65\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**47\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 0 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 0,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 0,(iy+dd)\\r\\nconst variant_FD_CB_dd_42 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        66\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**47\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 0 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 0,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 0,(iy+dd)\\r\\nconst variant_FD_CB_dd_43 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        67\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**47\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 0 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 0,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 0,(iy+dd)\\r\\nconst variant_FD_CB_dd_44 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        68\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**47\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 0 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 0,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 0,(iy+dd)\\r\\nconst variant_FD_CB_dd_45 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        69\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**47\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 0 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 0,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 0,(iy+dd)\\r\\nconst variant_FD_CB_dd_46 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        70\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**47\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 0 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 0,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 1,(iy+dd)\\r\\nconst variant_FD_CB_dd_4F = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"1\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        79\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**4F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 1 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 1,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 1,(iy+dd)\\r\\nconst variant_FD_CB_dd_48 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"1\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        72\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**4F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 1 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 1,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 1,(iy+dd)\\r\\nconst variant_FD_CB_dd_49 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"1\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        73\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**4F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 1 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 1,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 1,(iy+dd)\\r\\nconst variant_FD_CB_dd_4A = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"1\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        74\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**4F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 1 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 1,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 1,(iy+dd)\\r\\nconst variant_FD_CB_dd_4B = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"1\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        75\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**4F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 1 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 1,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 1,(iy+dd)\\r\\nconst variant_FD_CB_dd_4C = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"1\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        76\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**4F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 1 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 1,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 1,(iy+dd)\\r\\nconst variant_FD_CB_dd_4D = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"1\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        77\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**4F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 1 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 1,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 1,(iy+dd)\\r\\nconst variant_FD_CB_dd_4E = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"1\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        78\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**4F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 1 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 1,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 2,(iy+dd)\\r\\nconst variant_FD_CB_dd_57 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"2\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        87\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**57\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 2 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 2,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 2,(iy+dd)\\r\\nconst variant_FD_CB_dd_50 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"2\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        80\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**57\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 2 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 2,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 2,(iy+dd)\\r\\nconst variant_FD_CB_dd_51 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"2\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        81\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**57\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 2 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 2,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 2,(iy+dd)\\r\\nconst variant_FD_CB_dd_52 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"2\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        82\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**57\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 2 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 2,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 2,(iy+dd)\\r\\nconst variant_FD_CB_dd_53 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"2\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        83\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**57\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 2 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 2,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 2,(iy+dd)\\r\\nconst variant_FD_CB_dd_54 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"2\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        84\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**57\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 2 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 2,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 2,(iy+dd)\\r\\nconst variant_FD_CB_dd_55 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"2\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        85\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**57\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 2 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 2,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 2,(iy+dd)\\r\\nconst variant_FD_CB_dd_56 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"2\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        86\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**57\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 2 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 2,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 3,(iy+dd)\\r\\nconst variant_FD_CB_dd_5F = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"3\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        95\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**5F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 3 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 3,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 3,(iy+dd)\\r\\nconst variant_FD_CB_dd_58 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"3\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        88\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**5F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 3 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 3,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 3,(iy+dd)\\r\\nconst variant_FD_CB_dd_59 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"3\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        89\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**5F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 3 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 3,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 3,(iy+dd)\\r\\nconst variant_FD_CB_dd_5A = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"3\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        90\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**5F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 3 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 3,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 3,(iy+dd)\\r\\nconst variant_FD_CB_dd_5B = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"3\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        91\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**5F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 3 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 3,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 3,(iy+dd)\\r\\nconst variant_FD_CB_dd_5C = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"3\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        92\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**5F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 3 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 3,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 3,(iy+dd)\\r\\nconst variant_FD_CB_dd_5D = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"3\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        93\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**5F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 3 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 3,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 3,(iy+dd)\\r\\nconst variant_FD_CB_dd_5E = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"3\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        94\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**5F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 3 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 3,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 4,(iy+dd)\\r\\nconst variant_FD_CB_dd_67 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"4\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        103\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**67\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 4 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 4,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 4,(iy+dd)\\r\\nconst variant_FD_CB_dd_60 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"4\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        96\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**67\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 4 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 4,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 4,(iy+dd)\\r\\nconst variant_FD_CB_dd_61 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"4\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        97\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**67\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 4 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 4,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 4,(iy+dd)\\r\\nconst variant_FD_CB_dd_62 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"4\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        98\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**67\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 4 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 4,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 4,(iy+dd)\\r\\nconst variant_FD_CB_dd_63 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"4\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        99\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**67\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 4 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 4,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 4,(iy+dd)\\r\\nconst variant_FD_CB_dd_64 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"4\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        100\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**67\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 4 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 4,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 4,(iy+dd)\\r\\nconst variant_FD_CB_dd_65 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"4\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        101\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**67\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 4 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 4,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 4,(iy+dd)\\r\\nconst variant_FD_CB_dd_66 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"4\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        102\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**67\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 4 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 4,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 5,(iy+dd)\\r\\nconst variant_FD_CB_dd_6F = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"5\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        111\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**6F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 5 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 5,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 5,(iy+dd)\\r\\nconst variant_FD_CB_dd_68 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"5\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        104\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**6F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 5 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 5,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 5,(iy+dd)\\r\\nconst variant_FD_CB_dd_69 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"5\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        105\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**6F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 5 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 5,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 5,(iy+dd)\\r\\nconst variant_FD_CB_dd_6A = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"5\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        106\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**6F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 5 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 5,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 5,(iy+dd)\\r\\nconst variant_FD_CB_dd_6B = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"5\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        107\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**6F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 5 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 5,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 5,(iy+dd)\\r\\nconst variant_FD_CB_dd_6C = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"5\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        108\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**6F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 5 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 5,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 5,(iy+dd)\\r\\nconst variant_FD_CB_dd_6D = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"5\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        109\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**6F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 5 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 5,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 5,(iy+dd)\\r\\nconst variant_FD_CB_dd_6E = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"5\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        110\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**6F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 5 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 5,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 6,(iy+dd)\\r\\nconst variant_FD_CB_dd_77 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"6\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        119\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**77\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 6 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 6,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 6,(iy+dd)\\r\\nconst variant_FD_CB_dd_70 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"6\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        112\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**77\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 6 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 6,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 6,(iy+dd)\\r\\nconst variant_FD_CB_dd_71 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"6\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        113\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**77\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 6 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 6,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 6,(iy+dd)\\r\\nconst variant_FD_CB_dd_72 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"6\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        114\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**77\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 6 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 6,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 6,(iy+dd)\\r\\nconst variant_FD_CB_dd_73 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"6\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        115\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**77\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 6 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 6,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 6,(iy+dd)\\r\\nconst variant_FD_CB_dd_74 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"6\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        116\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**77\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 6 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 6,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 6,(iy+dd)\\r\\nconst variant_FD_CB_dd_75 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"6\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        117\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**77\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 6 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 6,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 6,(iy+dd)\\r\\nconst variant_FD_CB_dd_76 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"6\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        118\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**77\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 6 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 6,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 7,(iy+dd)\\r\\nconst variant_FD_CB_dd_7F = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"7\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        127\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**7F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 7 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 7,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 7,(iy+dd)\\r\\nconst variant_FD_CB_dd_78 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"7\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        120\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**7F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 7 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 7,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 7,(iy+dd)\\r\\nconst variant_FD_CB_dd_79 = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"7\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        121\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**7F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 7 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 7,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 7,(iy+dd)\\r\\nconst variant_FD_CB_dd_7A = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"7\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        122\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**7F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 7 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 7,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 7,(iy+dd)\\r\\nconst variant_FD_CB_dd_7B = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"7\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        123\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**7F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 7 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 7,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 7,(iy+dd)\\r\\nconst variant_FD_CB_dd_7C = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"7\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        124\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**7F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 7 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 7,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 7,(iy+dd)\\r\\nconst variant_FD_CB_dd_7D = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"7\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        125\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**7F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 7 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 7,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// bit 7,(iy+dd)\\r\\nconst variant_FD_CB_dd_7E = {\\r\\n    \\"mnemonic\\": \\"bit\\",\\r\\n    \\"params\\": [\\r\\n        \\"7\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        126\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**7F\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0 1+ \\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 20,\\r\\n        \\"without_jump_clock_count\\": 20,\\r\\n        \\"description\\": \\"Tests bit 7 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"bit 7,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// res 0,b\\r\\nconst variant_CB_80 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        128\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB80\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 0 of B.\\",\\r\\n        \\"instruction\\": \\"res 0,b\\"\\r\\n    }\\r\\n};\\r\\n// res 0,c\\r\\nconst variant_CB_81 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        129\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB81\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 0 of C.\\",\\r\\n        \\"instruction\\": \\"res 0,c\\"\\r\\n    }\\r\\n};\\r\\n// res 0,d\\r\\nconst variant_CB_82 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        130\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB82\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 0 of D.\\",\\r\\n        \\"instruction\\": \\"res 0,d\\"\\r\\n    }\\r\\n};\\r\\n// res 0,e\\r\\nconst variant_CB_83 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        131\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB83\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 0 of E.\\",\\r\\n        \\"instruction\\": \\"res 0,e\\"\\r\\n    }\\r\\n};\\r\\n// res 0,h\\r\\nconst variant_CB_84 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        132\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB84\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 0 of H.\\",\\r\\n        \\"instruction\\": \\"res 0,h\\"\\r\\n    }\\r\\n};\\r\\n// res 0,l\\r\\nconst variant_CB_85 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        133\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB85\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 0 of L.\\",\\r\\n        \\"instruction\\": \\"res 0,l\\"\\r\\n    }\\r\\n};\\r\\n// res 0,(hl)\\r\\nconst variant_CB_86 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\",\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        134\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB86\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 15,\\r\\n        \\"without_jump_clock_count\\": 15,\\r\\n        \\"description\\": \\"Resets bit 0 of (HL).\\",\\r\\n        \\"instruction\\": \\"res 0,(hl)\\"\\r\\n    }\\r\\n};\\r\\n// res 0,a\\r\\nconst variant_CB_87 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        135\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB87\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 0 of A.\\",\\r\\n        \\"instruction\\": \\"res 0,a\\"\\r\\n    }\\r\\n};\\r\\n// res 1,b\\r\\nconst variant_CB_88 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"1\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        136\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB88\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 1 of B.\\",\\r\\n        \\"instruction\\": \\"res 1,b\\"\\r\\n    }\\r\\n};\\r\\n// res 1,c\\r\\nconst variant_CB_89 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"1\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        137\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB89\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 1 of C.\\",\\r\\n        \\"instruction\\": \\"res 1,c\\"\\r\\n    }\\r\\n};\\r\\n// res 1,d\\r\\nconst variant_CB_8A = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"1\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        138\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB8A\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 1 of D.\\",\\r\\n        \\"instruction\\": \\"res 1,d\\"\\r\\n    }\\r\\n};\\r\\n// res 1,e\\r\\nconst variant_CB_8B = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"1\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        139\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB8B\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 1 of E.\\",\\r\\n        \\"instruction\\": \\"res 1,e\\"\\r\\n    }\\r\\n};\\r\\n// res 1,h\\r\\nconst variant_CB_8C = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"1\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        140\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB8C\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 1 of H.\\",\\r\\n        \\"instruction\\": \\"res 1,h\\"\\r\\n    }\\r\\n};\\r\\n// res 1,l\\r\\nconst variant_CB_8D = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"1\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        141\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB8D\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 1 of L.\\",\\r\\n        \\"instruction\\": \\"res 1,l\\"\\r\\n    }\\r\\n};\\r\\n// res 1,(hl)\\r\\nconst variant_CB_8E = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"1\\",\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        142\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB8E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 15,\\r\\n        \\"without_jump_clock_count\\": 15,\\r\\n        \\"description\\": \\"Resets bit 1 of (HL).\\",\\r\\n        \\"instruction\\": \\"res 1,(hl)\\"\\r\\n    }\\r\\n};\\r\\n// res 1,a\\r\\nconst variant_CB_8F = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"1\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        143\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB8F\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 1 of A.\\",\\r\\n        \\"instruction\\": \\"res 1,a\\"\\r\\n    }\\r\\n};\\r\\n// res 2,b\\r\\nconst variant_CB_90 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"2\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        144\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB90\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 2 of B.\\",\\r\\n        \\"instruction\\": \\"res 2,b\\"\\r\\n    }\\r\\n};\\r\\n// res 2,c\\r\\nconst variant_CB_91 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"2\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        145\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB91\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 2 of C.\\",\\r\\n        \\"instruction\\": \\"res 2,c\\"\\r\\n    }\\r\\n};\\r\\n// res 2,d\\r\\nconst variant_CB_92 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"2\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        146\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB92\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 2 of D.\\",\\r\\n        \\"instruction\\": \\"res 2,d\\"\\r\\n    }\\r\\n};\\r\\n// res 2,e\\r\\nconst variant_CB_93 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"2\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        147\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB93\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 2 of E.\\",\\r\\n        \\"instruction\\": \\"res 2,e\\"\\r\\n    }\\r\\n};\\r\\n// res 2,h\\r\\nconst variant_CB_94 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"2\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        148\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB94\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 2 of H.\\",\\r\\n        \\"instruction\\": \\"res 2,h\\"\\r\\n    }\\r\\n};\\r\\n// res 2,l\\r\\nconst variant_CB_95 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"2\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        149\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB95\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 2 of L.\\",\\r\\n        \\"instruction\\": \\"res 2,l\\"\\r\\n    }\\r\\n};\\r\\n// res 2,(hl)\\r\\nconst variant_CB_96 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"2\\",\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        150\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB96\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 15,\\r\\n        \\"without_jump_clock_count\\": 15,\\r\\n        \\"description\\": \\"Resets bit 2 of (HL).\\",\\r\\n        \\"instruction\\": \\"res 2,(hl)\\"\\r\\n    }\\r\\n};\\r\\n// res 2,a\\r\\nconst variant_CB_97 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"2\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        151\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB97\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 2 of A.\\",\\r\\n        \\"instruction\\": \\"res 2,a\\"\\r\\n    }\\r\\n};\\r\\n// res 3,b\\r\\nconst variant_CB_98 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"3\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        152\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB98\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 3 of B.\\",\\r\\n        \\"instruction\\": \\"res 3,b\\"\\r\\n    }\\r\\n};\\r\\n// res 3,c\\r\\nconst variant_CB_99 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"3\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        153\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB99\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 3 of C.\\",\\r\\n        \\"instruction\\": \\"res 3,c\\"\\r\\n    }\\r\\n};\\r\\n// res 3,d\\r\\nconst variant_CB_9A = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"3\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        154\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB9A\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 3 of D.\\",\\r\\n        \\"instruction\\": \\"res 3,d\\"\\r\\n    }\\r\\n};\\r\\n// res 3,e\\r\\nconst variant_CB_9B = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"3\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        155\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB9B\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 3 of E.\\",\\r\\n        \\"instruction\\": \\"res 3,e\\"\\r\\n    }\\r\\n};\\r\\n// res 3,h\\r\\nconst variant_CB_9C = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"3\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        156\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB9C\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 3 of H.\\",\\r\\n        \\"instruction\\": \\"res 3,h\\"\\r\\n    }\\r\\n};\\r\\n// res 3,l\\r\\nconst variant_CB_9D = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"3\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        157\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB9D\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 3 of L.\\",\\r\\n        \\"instruction\\": \\"res 3,l\\"\\r\\n    }\\r\\n};\\r\\n// res 3,(hl)\\r\\nconst variant_CB_9E = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"3\\",\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        158\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB9E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 15,\\r\\n        \\"without_jump_clock_count\\": 15,\\r\\n        \\"description\\": \\"Resets bit 3 of (HL).\\",\\r\\n        \\"instruction\\": \\"res 3,(hl)\\"\\r\\n    }\\r\\n};\\r\\n// res 3,a\\r\\nconst variant_CB_9F = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"3\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        159\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CB9F\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 3 of A.\\",\\r\\n        \\"instruction\\": \\"res 3,a\\"\\r\\n    }\\r\\n};\\r\\n// res 4,b\\r\\nconst variant_CB_A0 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"4\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        160\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBA0\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 4 of B.\\",\\r\\n        \\"instruction\\": \\"res 4,b\\"\\r\\n    }\\r\\n};\\r\\n// res 4,c\\r\\nconst variant_CB_A1 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"4\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        161\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBA1\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 4 of C.\\",\\r\\n        \\"instruction\\": \\"res 4,c\\"\\r\\n    }\\r\\n};\\r\\n// res 4,d\\r\\nconst variant_CB_A2 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"4\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        162\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBA2\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 4 of D.\\",\\r\\n        \\"instruction\\": \\"res 4,d\\"\\r\\n    }\\r\\n};\\r\\n// res 4,e\\r\\nconst variant_CB_A3 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"4\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        163\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBA3\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 4 of E.\\",\\r\\n        \\"instruction\\": \\"res 4,e\\"\\r\\n    }\\r\\n};\\r\\n// res 4,h\\r\\nconst variant_CB_A4 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"4\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        164\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBA4\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 4 of H.\\",\\r\\n        \\"instruction\\": \\"res 4,h\\"\\r\\n    }\\r\\n};\\r\\n// res 4,l\\r\\nconst variant_CB_A5 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"4\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        165\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBA5\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 4 of L.\\",\\r\\n        \\"instruction\\": \\"res 4,l\\"\\r\\n    }\\r\\n};\\r\\n// res 4,(hl)\\r\\nconst variant_CB_A6 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"4\\",\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        166\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBA6\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 15,\\r\\n        \\"without_jump_clock_count\\": 15,\\r\\n        \\"description\\": \\"Resets bit 4 of (HL).\\",\\r\\n        \\"instruction\\": \\"res 4,(hl)\\"\\r\\n    }\\r\\n};\\r\\n// res 4,a\\r\\nconst variant_CB_A7 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"4\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        167\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBA7\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 4 of A.\\",\\r\\n        \\"instruction\\": \\"res 4,a\\"\\r\\n    }\\r\\n};\\r\\n// res 5,b\\r\\nconst variant_CB_A8 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"5\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        168\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBA8\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 5 of B.\\",\\r\\n        \\"instruction\\": \\"res 5,b\\"\\r\\n    }\\r\\n};\\r\\n// res 5,c\\r\\nconst variant_CB_A9 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"5\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        169\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBA9\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 5 of C.\\",\\r\\n        \\"instruction\\": \\"res 5,c\\"\\r\\n    }\\r\\n};\\r\\n// res 5,d\\r\\nconst variant_CB_AA = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"5\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        170\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBAA\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 5 of D.\\",\\r\\n        \\"instruction\\": \\"res 5,d\\"\\r\\n    }\\r\\n};\\r\\n// res 5,e\\r\\nconst variant_CB_AB = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"5\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        171\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBAB\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 5 of E.\\",\\r\\n        \\"instruction\\": \\"res 5,e\\"\\r\\n    }\\r\\n};\\r\\n// res 5,h\\r\\nconst variant_CB_AC = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"5\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        172\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBAC\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 5 of H.\\",\\r\\n        \\"instruction\\": \\"res 5,h\\"\\r\\n    }\\r\\n};\\r\\n// res 5,l\\r\\nconst variant_CB_AD = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"5\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        173\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBAD\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 5 of L.\\",\\r\\n        \\"instruction\\": \\"res 5,l\\"\\r\\n    }\\r\\n};\\r\\n// res 5,(hl)\\r\\nconst variant_CB_AE = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"5\\",\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        174\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBAE\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 15,\\r\\n        \\"without_jump_clock_count\\": 15,\\r\\n        \\"description\\": \\"Resets bit 5 of (HL).\\",\\r\\n        \\"instruction\\": \\"res 5,(hl)\\"\\r\\n    }\\r\\n};\\r\\n// res 5,a\\r\\nconst variant_CB_AF = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"5\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        175\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBAF\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 5 of A.\\",\\r\\n        \\"instruction\\": \\"res 5,a\\"\\r\\n    }\\r\\n};\\r\\n// res 6,b\\r\\nconst variant_CB_B0 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"6\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        176\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBB0\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 6 of B.\\",\\r\\n        \\"instruction\\": \\"res 6,b\\"\\r\\n    }\\r\\n};\\r\\n// res 6,c\\r\\nconst variant_CB_B1 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"6\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        177\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBB1\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 6 of C.\\",\\r\\n        \\"instruction\\": \\"res 6,c\\"\\r\\n    }\\r\\n};\\r\\n// res 6,d\\r\\nconst variant_CB_B2 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"6\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        178\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBB2\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 6 of D.\\",\\r\\n        \\"instruction\\": \\"res 6,d\\"\\r\\n    }\\r\\n};\\r\\n// res 6,e\\r\\nconst variant_CB_B3 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"6\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        179\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBB3\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 6 of E.\\",\\r\\n        \\"instruction\\": \\"res 6,e\\"\\r\\n    }\\r\\n};\\r\\n// res 6,h\\r\\nconst variant_CB_B4 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"6\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        180\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBB4\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 6 of H.\\",\\r\\n        \\"instruction\\": \\"res 6,h\\"\\r\\n    }\\r\\n};\\r\\n// res 6,l\\r\\nconst variant_CB_B5 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"6\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        181\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBB5\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 6 of L.\\",\\r\\n        \\"instruction\\": \\"res 6,l\\"\\r\\n    }\\r\\n};\\r\\n// res 6,(hl)\\r\\nconst variant_CB_B6 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"6\\",\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        182\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBB6\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 15,\\r\\n        \\"without_jump_clock_count\\": 15,\\r\\n        \\"description\\": \\"Resets bit 6 of (HL).\\",\\r\\n        \\"instruction\\": \\"res 6,(hl)\\"\\r\\n    }\\r\\n};\\r\\n// res 6,a\\r\\nconst variant_CB_B7 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"6\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        183\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBB7\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 6 of A.\\",\\r\\n        \\"instruction\\": \\"res 6,a\\"\\r\\n    }\\r\\n};\\r\\n// res 7,b\\r\\nconst variant_CB_B8 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"7\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        184\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBB8\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 7 of B.\\",\\r\\n        \\"instruction\\": \\"res 7,b\\"\\r\\n    }\\r\\n};\\r\\n// res 7,c\\r\\nconst variant_CB_B9 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"7\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        185\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBB9\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 7 of C.\\",\\r\\n        \\"instruction\\": \\"res 7,c\\"\\r\\n    }\\r\\n};\\r\\n// res 7,d\\r\\nconst variant_CB_BA = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"7\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        186\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBBA\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 7 of D.\\",\\r\\n        \\"instruction\\": \\"res 7,d\\"\\r\\n    }\\r\\n};\\r\\n// res 7,e\\r\\nconst variant_CB_BB = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"7\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        187\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBBB\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 7 of E.\\",\\r\\n        \\"instruction\\": \\"res 7,e\\"\\r\\n    }\\r\\n};\\r\\n// res 7,h\\r\\nconst variant_CB_BC = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"7\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        188\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBBC\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 7 of H.\\",\\r\\n        \\"instruction\\": \\"res 7,h\\"\\r\\n    }\\r\\n};\\r\\n// res 7,l\\r\\nconst variant_CB_BD = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"7\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        189\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBBD\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 7 of L.\\",\\r\\n        \\"instruction\\": \\"res 7,l\\"\\r\\n    }\\r\\n};\\r\\n// res 7,(hl)\\r\\nconst variant_CB_BE = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"7\\",\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        190\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBBE\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 15,\\r\\n        \\"without_jump_clock_count\\": 15,\\r\\n        \\"description\\": \\"Resets bit 7 of (HL).\\",\\r\\n        \\"instruction\\": \\"res 7,(hl)\\"\\r\\n    }\\r\\n};\\r\\n// res 7,a\\r\\nconst variant_CB_BF = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"7\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        191\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBBF\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Resets bit 7 of A.\\",\\r\\n        \\"instruction\\": \\"res 7,a\\"\\r\\n    }\\r\\n};\\r\\n// res 0,(ix+dd)\\r\\nconst variant_DD_CB_dd_86 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        134\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**86\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 0 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 0,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// res 1,(ix+dd)\\r\\nconst variant_DD_CB_dd_8E = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"1\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        142\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**8E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 1 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 1,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// res 2,(ix+dd)\\r\\nconst variant_DD_CB_dd_96 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"2\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        150\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**96\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 2 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 2,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// res 3,(ix+dd)\\r\\nconst variant_DD_CB_dd_9E = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"3\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        158\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**9E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 3 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 3,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// res 4,(ix+dd)\\r\\nconst variant_DD_CB_dd_A6 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"4\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        166\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**A6\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 4 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 4,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// res 5,(ix+dd)\\r\\nconst variant_DD_CB_dd_AE = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"5\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        174\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**AE\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 5 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 5,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// res 6,(ix+dd)\\r\\nconst variant_DD_CB_dd_B6 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"6\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        182\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**B6\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 6 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 6,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// res 7,(ix+dd)\\r\\nconst variant_DD_CB_dd_BE = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"7\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        190\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**BE\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 7 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"res 7,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// res 0,(iy+dd)\\r\\nconst variant_FD_CB_dd_86 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        134\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**86\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 0 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 0,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// res 1,(iy+dd)\\r\\nconst variant_FD_CB_dd_8E = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"1\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        142\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**8E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 1 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 1,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// res 2,(iy+dd)\\r\\nconst variant_FD_CB_dd_96 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"2\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        150\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**96\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 2 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 2,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// res 3,(iy+dd)\\r\\nconst variant_FD_CB_dd_9E = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"3\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        158\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**9E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 3 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 3,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// res 4,(iy+dd)\\r\\nconst variant_FD_CB_dd_A6 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"4\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        166\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**A6\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 4 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 4,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// res 5,(iy+dd)\\r\\nconst variant_FD_CB_dd_AE = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"5\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        174\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**AE\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 5 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 5,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// res 6,(iy+dd)\\r\\nconst variant_FD_CB_dd_B6 = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"6\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        182\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**B6\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 6 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 6,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// res 7,(iy+dd)\\r\\nconst variant_FD_CB_dd_BE = {\\r\\n    \\"mnemonic\\": \\"res\\",\\r\\n    \\"params\\": [\\r\\n        \\"7\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        190\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**BE\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Resets bit 7 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"res 7,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// set 0,b\\r\\nconst variant_CB_C0 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        192\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBC0\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 0 of B.\\",\\r\\n        \\"instruction\\": \\"set 0,b\\"\\r\\n    }\\r\\n};\\r\\n// set 0,c\\r\\nconst variant_CB_C1 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        193\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBC1\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 0 of C.\\",\\r\\n        \\"instruction\\": \\"set 0,c\\"\\r\\n    }\\r\\n};\\r\\n// set 0,d\\r\\nconst variant_CB_C2 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        194\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBC2\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 0 of D.\\",\\r\\n        \\"instruction\\": \\"set 0,d\\"\\r\\n    }\\r\\n};\\r\\n// set 0,e\\r\\nconst variant_CB_C3 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        195\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBC3\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 0 of E.\\",\\r\\n        \\"instruction\\": \\"set 0,e\\"\\r\\n    }\\r\\n};\\r\\n// set 0,h\\r\\nconst variant_CB_C4 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        196\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBC4\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 0 of H.\\",\\r\\n        \\"instruction\\": \\"set 0,h\\"\\r\\n    }\\r\\n};\\r\\n// set 0,l\\r\\nconst variant_CB_C5 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        197\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBC5\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 0 of L.\\",\\r\\n        \\"instruction\\": \\"set 0,l\\"\\r\\n    }\\r\\n};\\r\\n// set 0,(hl)\\r\\nconst variant_CB_C6 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\",\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        198\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBC6\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 15,\\r\\n        \\"without_jump_clock_count\\": 15,\\r\\n        \\"description\\": \\"Sets bit 0 of (HL).\\",\\r\\n        \\"instruction\\": \\"set 0,(hl)\\"\\r\\n    }\\r\\n};\\r\\n// set 0,a\\r\\nconst variant_CB_C7 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        199\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBC7\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 0 of A.\\",\\r\\n        \\"instruction\\": \\"set 0,a\\"\\r\\n    }\\r\\n};\\r\\n// set 1,b\\r\\nconst variant_CB_C8 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"1\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        200\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBC8\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 1 of B.\\",\\r\\n        \\"instruction\\": \\"set 1,b\\"\\r\\n    }\\r\\n};\\r\\n// set 1,c\\r\\nconst variant_CB_C9 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"1\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        201\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBC9\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 1 of C.\\",\\r\\n        \\"instruction\\": \\"set 1,c\\"\\r\\n    }\\r\\n};\\r\\n// set 1,d\\r\\nconst variant_CB_CA = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"1\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        202\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBCA\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 1 of D.\\",\\r\\n        \\"instruction\\": \\"set 1,d\\"\\r\\n    }\\r\\n};\\r\\n// set 1,e\\r\\nconst variant_CB_CB = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"1\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        203\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBCB\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 1 of E.\\",\\r\\n        \\"instruction\\": \\"set 1,e\\"\\r\\n    }\\r\\n};\\r\\n// set 1,h\\r\\nconst variant_CB_CC = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"1\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        204\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBCC\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 1 of H.\\",\\r\\n        \\"instruction\\": \\"set 1,h\\"\\r\\n    }\\r\\n};\\r\\n// set 1,l\\r\\nconst variant_CB_CD = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"1\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        205\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBCD\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 1 of L.\\",\\r\\n        \\"instruction\\": \\"set 1,l\\"\\r\\n    }\\r\\n};\\r\\n// set 1,(hl)\\r\\nconst variant_CB_CE = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"1\\",\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        206\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBCE\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 15,\\r\\n        \\"without_jump_clock_count\\": 15,\\r\\n        \\"description\\": \\"Sets bit 1 of (HL).\\",\\r\\n        \\"instruction\\": \\"set 1,(hl)\\"\\r\\n    }\\r\\n};\\r\\n// set 1,a\\r\\nconst variant_CB_CF = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"1\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        207\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBCF\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 1 of A.\\",\\r\\n        \\"instruction\\": \\"set 1,a\\"\\r\\n    }\\r\\n};\\r\\n// set 2,b\\r\\nconst variant_CB_D0 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"2\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        208\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBD0\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 2 of B.\\",\\r\\n        \\"instruction\\": \\"set 2,b\\"\\r\\n    }\\r\\n};\\r\\n// set 2,c\\r\\nconst variant_CB_D1 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"2\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        209\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBD1\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 2 of C.\\",\\r\\n        \\"instruction\\": \\"set 2,c\\"\\r\\n    }\\r\\n};\\r\\n// set 2,d\\r\\nconst variant_CB_D2 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"2\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        210\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBD2\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 2 of D.\\",\\r\\n        \\"instruction\\": \\"set 2,d\\"\\r\\n    }\\r\\n};\\r\\n// set 2,e\\r\\nconst variant_CB_D3 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"2\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        211\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBD3\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 2 of E.\\",\\r\\n        \\"instruction\\": \\"set 2,e\\"\\r\\n    }\\r\\n};\\r\\n// set 2,h\\r\\nconst variant_CB_D4 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"2\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        212\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBD4\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 2 of H.\\",\\r\\n        \\"instruction\\": \\"set 2,h\\"\\r\\n    }\\r\\n};\\r\\n// set 2,l\\r\\nconst variant_CB_D5 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"2\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        213\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBD5\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 2 of L.\\",\\r\\n        \\"instruction\\": \\"set 2,l\\"\\r\\n    }\\r\\n};\\r\\n// set 2,(hl)\\r\\nconst variant_CB_D6 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"2\\",\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        214\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBD6\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 15,\\r\\n        \\"without_jump_clock_count\\": 15,\\r\\n        \\"description\\": \\"Sets bit 2 of (HL).\\",\\r\\n        \\"instruction\\": \\"set 2,(hl)\\"\\r\\n    }\\r\\n};\\r\\n// set 2,a\\r\\nconst variant_CB_D7 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"2\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        215\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBD7\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 2 of A.\\",\\r\\n        \\"instruction\\": \\"set 2,a\\"\\r\\n    }\\r\\n};\\r\\n// set 3,b\\r\\nconst variant_CB_D8 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"3\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        216\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBD8\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 3 of B.\\",\\r\\n        \\"instruction\\": \\"set 3,b\\"\\r\\n    }\\r\\n};\\r\\n// set 3,c\\r\\nconst variant_CB_D9 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"3\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        217\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBD9\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 3 of C.\\",\\r\\n        \\"instruction\\": \\"set 3,c\\"\\r\\n    }\\r\\n};\\r\\n// set 3,d\\r\\nconst variant_CB_DA = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"3\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        218\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBDA\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 3 of D.\\",\\r\\n        \\"instruction\\": \\"set 3,d\\"\\r\\n    }\\r\\n};\\r\\n// set 3,e\\r\\nconst variant_CB_DB = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"3\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        219\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBDB\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 3 of E.\\",\\r\\n        \\"instruction\\": \\"set 3,e\\"\\r\\n    }\\r\\n};\\r\\n// set 3,h\\r\\nconst variant_CB_DC = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"3\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        220\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBDC\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 3 of H.\\",\\r\\n        \\"instruction\\": \\"set 3,h\\"\\r\\n    }\\r\\n};\\r\\n// set 3,l\\r\\nconst variant_CB_DD = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"3\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        221\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBDD\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 3 of L.\\",\\r\\n        \\"instruction\\": \\"set 3,l\\"\\r\\n    }\\r\\n};\\r\\n// set 3,(hl)\\r\\nconst variant_CB_DE = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"3\\",\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        222\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBDE\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 15,\\r\\n        \\"without_jump_clock_count\\": 15,\\r\\n        \\"description\\": \\"Sets bit 3 of (HL).\\",\\r\\n        \\"instruction\\": \\"set 3,(hl)\\"\\r\\n    }\\r\\n};\\r\\n// set 3,a\\r\\nconst variant_CB_DF = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"3\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        223\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBDF\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 3 of A.\\",\\r\\n        \\"instruction\\": \\"set 3,a\\"\\r\\n    }\\r\\n};\\r\\n// set 4,b\\r\\nconst variant_CB_E0 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"4\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        224\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBE0\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 4 of B.\\",\\r\\n        \\"instruction\\": \\"set 4,b\\"\\r\\n    }\\r\\n};\\r\\n// set 4,c\\r\\nconst variant_CB_E1 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"4\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        225\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBE1\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 4 of C.\\",\\r\\n        \\"instruction\\": \\"set 4,c\\"\\r\\n    }\\r\\n};\\r\\n// set 4,d\\r\\nconst variant_CB_E2 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"4\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        226\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBE2\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 4 of D.\\",\\r\\n        \\"instruction\\": \\"set 4,d\\"\\r\\n    }\\r\\n};\\r\\n// set 4,e\\r\\nconst variant_CB_E3 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"4\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        227\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBE3\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 4 of E.\\",\\r\\n        \\"instruction\\": \\"set 4,e\\"\\r\\n    }\\r\\n};\\r\\n// set 4,h\\r\\nconst variant_CB_E4 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"4\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        228\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBE4\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 4 of H.\\",\\r\\n        \\"instruction\\": \\"set 4,h\\"\\r\\n    }\\r\\n};\\r\\n// set 4,l\\r\\nconst variant_CB_E5 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"4\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        229\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBE5\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 4 of L.\\",\\r\\n        \\"instruction\\": \\"set 4,l\\"\\r\\n    }\\r\\n};\\r\\n// set 4,(hl)\\r\\nconst variant_CB_E6 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"4\\",\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        230\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBE6\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 15,\\r\\n        \\"without_jump_clock_count\\": 15,\\r\\n        \\"description\\": \\"Sets bit 4 of (HL).\\",\\r\\n        \\"instruction\\": \\"set 4,(hl)\\"\\r\\n    }\\r\\n};\\r\\n// set 4,a\\r\\nconst variant_CB_E7 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"4\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        231\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBE7\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 4 of A.\\",\\r\\n        \\"instruction\\": \\"set 4,a\\"\\r\\n    }\\r\\n};\\r\\n// set 5,b\\r\\nconst variant_CB_E8 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"5\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        232\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBE8\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 5 of B.\\",\\r\\n        \\"instruction\\": \\"set 5,b\\"\\r\\n    }\\r\\n};\\r\\n// set 5,c\\r\\nconst variant_CB_E9 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"5\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        233\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBE9\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 5 of C.\\",\\r\\n        \\"instruction\\": \\"set 5,c\\"\\r\\n    }\\r\\n};\\r\\n// set 5,d\\r\\nconst variant_CB_EA = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"5\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        234\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBEA\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 5 of D.\\",\\r\\n        \\"instruction\\": \\"set 5,d\\"\\r\\n    }\\r\\n};\\r\\n// set 5,e\\r\\nconst variant_CB_EB = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"5\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        235\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBEB\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 5 of E.\\",\\r\\n        \\"instruction\\": \\"set 5,e\\"\\r\\n    }\\r\\n};\\r\\n// set 5,h\\r\\nconst variant_CB_EC = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"5\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        236\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBEC\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 5 of H.\\",\\r\\n        \\"instruction\\": \\"set 5,h\\"\\r\\n    }\\r\\n};\\r\\n// set 5,l\\r\\nconst variant_CB_ED = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"5\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        237\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBED\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 5 of L.\\",\\r\\n        \\"instruction\\": \\"set 5,l\\"\\r\\n    }\\r\\n};\\r\\n// set 5,(hl)\\r\\nconst variant_CB_EE = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"5\\",\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        238\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBEE\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 15,\\r\\n        \\"without_jump_clock_count\\": 15,\\r\\n        \\"description\\": \\"Sets bit 5 of (HL).\\",\\r\\n        \\"instruction\\": \\"set 5,(hl)\\"\\r\\n    }\\r\\n};\\r\\n// set 5,a\\r\\nconst variant_CB_EF = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"5\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        239\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBEF\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 5 of A.\\",\\r\\n        \\"instruction\\": \\"set 5,a\\"\\r\\n    }\\r\\n};\\r\\n// set 6,b\\r\\nconst variant_CB_F0 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"6\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        240\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBF0\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 6 of B.\\",\\r\\n        \\"instruction\\": \\"set 6,b\\"\\r\\n    }\\r\\n};\\r\\n// set 6,c\\r\\nconst variant_CB_F1 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"6\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        241\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBF1\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 6 of C.\\",\\r\\n        \\"instruction\\": \\"set 6,c\\"\\r\\n    }\\r\\n};\\r\\n// set 6,d\\r\\nconst variant_CB_F2 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"6\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        242\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBF2\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 6 of D.\\",\\r\\n        \\"instruction\\": \\"set 6,d\\"\\r\\n    }\\r\\n};\\r\\n// set 6,e\\r\\nconst variant_CB_F3 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"6\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        243\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBF3\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 6 of E.\\",\\r\\n        \\"instruction\\": \\"set 6,e\\"\\r\\n    }\\r\\n};\\r\\n// set 6,h\\r\\nconst variant_CB_F4 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"6\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        244\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBF4\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 6 of H.\\",\\r\\n        \\"instruction\\": \\"set 6,h\\"\\r\\n    }\\r\\n};\\r\\n// set 6,l\\r\\nconst variant_CB_F5 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"6\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        245\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBF5\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 6 of L.\\",\\r\\n        \\"instruction\\": \\"set 6,l\\"\\r\\n    }\\r\\n};\\r\\n// set 6,(hl)\\r\\nconst variant_CB_F6 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"6\\",\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        246\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBF6\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 15,\\r\\n        \\"without_jump_clock_count\\": 15,\\r\\n        \\"description\\": \\"Sets bit 6 of (HL).\\",\\r\\n        \\"instruction\\": \\"set 6,(hl)\\"\\r\\n    }\\r\\n};\\r\\n// set 6,a\\r\\nconst variant_CB_F7 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"6\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        247\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBF7\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 6 of A.\\",\\r\\n        \\"instruction\\": \\"set 6,a\\"\\r\\n    }\\r\\n};\\r\\n// set 7,b\\r\\nconst variant_CB_F8 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"7\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        248\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBF8\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 7 of B.\\",\\r\\n        \\"instruction\\": \\"set 7,b\\"\\r\\n    }\\r\\n};\\r\\n// set 7,c\\r\\nconst variant_CB_F9 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"7\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        249\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBF9\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 7 of C.\\",\\r\\n        \\"instruction\\": \\"set 7,c\\"\\r\\n    }\\r\\n};\\r\\n// set 7,d\\r\\nconst variant_CB_FA = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"7\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        250\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBFA\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 7 of D.\\",\\r\\n        \\"instruction\\": \\"set 7,d\\"\\r\\n    }\\r\\n};\\r\\n// set 7,e\\r\\nconst variant_CB_FB = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"7\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        251\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBFB\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 7 of E.\\",\\r\\n        \\"instruction\\": \\"set 7,e\\"\\r\\n    }\\r\\n};\\r\\n// set 7,h\\r\\nconst variant_CB_FC = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"7\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        252\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBFC\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 7 of H.\\",\\r\\n        \\"instruction\\": \\"set 7,h\\"\\r\\n    }\\r\\n};\\r\\n// set 7,l\\r\\nconst variant_CB_FD = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"7\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        253\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBFD\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 7 of L.\\",\\r\\n        \\"instruction\\": \\"set 7,l\\"\\r\\n    }\\r\\n};\\r\\n// set 7,(hl)\\r\\nconst variant_CB_FE = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"7\\",\\r\\n        \\"(hl)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"hl\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        254\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBFE\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 15,\\r\\n        \\"without_jump_clock_count\\": 15,\\r\\n        \\"description\\": \\"Sets bit 7 of (HL).\\",\\r\\n        \\"instruction\\": \\"set 7,(hl)\\"\\r\\n    }\\r\\n};\\r\\n// set 7,a\\r\\nconst variant_CB_FF = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"7\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        203,\\r\\n        255\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"CBFF\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets bit 7 of A.\\",\\r\\n        \\"instruction\\": \\"set 7,a\\"\\r\\n    }\\r\\n};\\r\\n// set 0,(ix+dd)\\r\\nconst variant_DD_CB_dd_C6 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        198\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**C6\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 0 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 0,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// set 1,(ix+dd)\\r\\nconst variant_DD_CB_dd_CE = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"1\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        206\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**CE\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 1 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 1,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// set 2,(ix+dd)\\r\\nconst variant_DD_CB_dd_D6 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"2\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        214\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**D6\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 2 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 2,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// set 3,(ix+dd)\\r\\nconst variant_DD_CB_dd_DE = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"3\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        222\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**DE\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 3 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 3,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// set 4,(ix+dd)\\r\\nconst variant_DD_CB_dd_E6 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"4\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        230\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**E6\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 4 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 4,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// set 5,(ix+dd)\\r\\nconst variant_DD_CB_dd_EE = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"5\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        238\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**EE\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 5 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 5,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// set 6,(ix+dd)\\r\\nconst variant_DD_CB_dd_F6 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"6\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        246\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**F6\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 6 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 6,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// set 7,(ix+dd)\\r\\nconst variant_DD_CB_dd_FE = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"7\\",\\r\\n        \\"(ix+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"ix\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        221,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        254\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DDCB**FE\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 7 of the memory location pointed to by IX plus *.\\",\\r\\n        \\"instruction\\": \\"set 7,(ix+*)\\"\\r\\n    }\\r\\n};\\r\\n// set 0,(iy+dd)\\r\\nconst variant_FD_CB_dd_C6 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        198\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**C6\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 0 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 0,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// set 1,(iy+dd)\\r\\nconst variant_FD_CB_dd_CE = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"1\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"1\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        206\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**CE\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 1 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 1,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// set 2,(iy+dd)\\r\\nconst variant_FD_CB_dd_D6 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"2\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"2\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        214\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**D6\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 2 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 2,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// set 3,(iy+dd)\\r\\nconst variant_FD_CB_dd_DE = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"3\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"3\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        222\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**DE\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 3 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 3,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// set 4,(iy+dd)\\r\\nconst variant_FD_CB_dd_E6 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"4\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"4\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        230\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**E6\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 4 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 4,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// set 5,(iy+dd)\\r\\nconst variant_FD_CB_dd_EE = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"5\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"5\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        238\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**EE\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 5 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 5,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// set 6,(iy+dd)\\r\\nconst variant_FD_CB_dd_F6 = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"6\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"6\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        246\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**F6\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 6 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 6,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// set 7,(iy+dd)\\r\\nconst variant_FD_CB_dd_FE = {\\r\\n    \\"mnemonic\\": \\"set\\",\\r\\n    \\"params\\": [\\r\\n        \\"7\\",\\r\\n        \\"(iy+dd)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"7\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"iy\\",\\r\\n        \\"+\\",\\r\\n        \\"dd\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        253,\\r\\n        203,\\r\\n        \\"dd\\",\\r\\n        254\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FDCB**FE\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 4,\\r\\n        \\"with_jump_clock_count\\": 23,\\r\\n        \\"without_jump_clock_count\\": 23,\\r\\n        \\"description\\": \\"Sets bit 7 of the memory location pointed to by IY plus *.\\",\\r\\n        \\"instruction\\": \\"set 7,(iy+*)\\"\\r\\n    }\\r\\n};\\r\\n// out (nn),a\\r\\nconst variant_D3_nn = {\\r\\n    \\"mnemonic\\": \\"out\\",\\r\\n    \\"params\\": [\\r\\n        \\"(nn)\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"nn\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        211,\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"D3\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 11,\\r\\n        \\"without_jump_clock_count\\": 11,\\r\\n        \\"description\\": \\"The value of A is written to port *.\\",\\r\\n        \\"instruction\\": \\"out (*),a\\"\\r\\n    }\\r\\n};\\r\\n// out (c),b\\r\\nconst variant_ED_41 = {\\r\\n    \\"mnemonic\\": \\"out\\",\\r\\n    \\"params\\": [\\r\\n        \\"(c)\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"c\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"b\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        65\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED41\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 12,\\r\\n        \\"without_jump_clock_count\\": 12,\\r\\n        \\"description\\": \\"The value of B is written to port C.\\",\\r\\n        \\"instruction\\": \\"out (c),b\\"\\r\\n    }\\r\\n};\\r\\n// out (c),c\\r\\nconst variant_ED_49 = {\\r\\n    \\"mnemonic\\": \\"out\\",\\r\\n    \\"params\\": [\\r\\n        \\"(c)\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"c\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"c\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        73\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED49\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 12,\\r\\n        \\"without_jump_clock_count\\": 12,\\r\\n        \\"description\\": \\"The value of C is written to port C.\\",\\r\\n        \\"instruction\\": \\"out (c),c\\"\\r\\n    }\\r\\n};\\r\\n// out (c),d\\r\\nconst variant_ED_51 = {\\r\\n    \\"mnemonic\\": \\"out\\",\\r\\n    \\"params\\": [\\r\\n        \\"(c)\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"c\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"d\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        81\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED51\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 12,\\r\\n        \\"without_jump_clock_count\\": 12,\\r\\n        \\"description\\": \\"The value of C is written to port C.\\",\\r\\n        \\"instruction\\": \\"out (c),d\\"\\r\\n    }\\r\\n};\\r\\n// out (c),e\\r\\nconst variant_ED_59 = {\\r\\n    \\"mnemonic\\": \\"out\\",\\r\\n    \\"params\\": [\\r\\n        \\"(c)\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"c\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"e\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        89\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED59\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 12,\\r\\n        \\"without_jump_clock_count\\": 12,\\r\\n        \\"description\\": \\"The value of E is written to port C.\\",\\r\\n        \\"instruction\\": \\"out (c),e\\"\\r\\n    }\\r\\n};\\r\\n// out (c),h\\r\\nconst variant_ED_61 = {\\r\\n    \\"mnemonic\\": \\"out\\",\\r\\n    \\"params\\": [\\r\\n        \\"(c)\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"c\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"h\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        97\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED61\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 12,\\r\\n        \\"without_jump_clock_count\\": 12,\\r\\n        \\"description\\": \\"The value of H is written to port C.\\",\\r\\n        \\"instruction\\": \\"out (c),h\\"\\r\\n    }\\r\\n};\\r\\n// out (c),l\\r\\nconst variant_ED_69 = {\\r\\n    \\"mnemonic\\": \\"out\\",\\r\\n    \\"params\\": [\\r\\n        \\"(c)\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"c\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"l\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        105\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED69\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 12,\\r\\n        \\"without_jump_clock_count\\": 12,\\r\\n        \\"description\\": \\"The value of L is written to port C.\\",\\r\\n        \\"instruction\\": \\"out (c),l\\"\\r\\n    }\\r\\n};\\r\\n// out (c),0\\r\\nconst variant_ED_71 = {\\r\\n    \\"mnemonic\\": \\"out\\",\\r\\n    \\"params\\": [\\r\\n        \\"(c)\\",\\r\\n        \\"0\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"c\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"0\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        113\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED71\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 12,\\r\\n        \\"without_jump_clock_count\\": 12,\\r\\n        \\"description\\": \\"Outputs a zero to port C.\\",\\r\\n        \\"instruction\\": \\"out (c),0\\"\\r\\n    }\\r\\n};\\r\\n// out (c),a\\r\\nconst variant_ED_79 = {\\r\\n    \\"mnemonic\\": \\"out\\",\\r\\n    \\"params\\": [\\r\\n        \\"(c)\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"c\\",\\r\\n        \\")\\",\\r\\n        \\",\\",\\r\\n        \\"a\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        121\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED79\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 12,\\r\\n        \\"without_jump_clock_count\\": 12,\\r\\n        \\"description\\": \\"The value of A is written to port C.\\",\\r\\n        \\"instruction\\": \\"out (c),a\\"\\r\\n    }\\r\\n};\\r\\n// exx\\r\\nconst variant_D9 = {\\r\\n    \\"mnemonic\\": \\"exx\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        217\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"D9\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Exchanges the 16-bit contents of BC, DE, and HL with BC\', DE\', and HL\'.\\",\\r\\n        \\"instruction\\": \\"exx\\"\\r\\n    }\\r\\n};\\r\\n// in a,(nn)\\r\\nconst variant_DB_nn = {\\r\\n    \\"mnemonic\\": \\"in\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"(nn)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"nn\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        219,\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DB\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 11,\\r\\n        \\"without_jump_clock_count\\": 11,\\r\\n        \\"description\\": \\"a byte from port * is written to A.\\",\\r\\n        \\"instruction\\": \\"in a,(*)\\"\\r\\n    }\\r\\n};\\r\\n// in (nn)\\r\\nconst variant_DB_nn_pseudo = {\\r\\n    \\"mnemonic\\": \\"in\\",\\r\\n    \\"params\\": [\\r\\n        \\"(nn)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"nn\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        219,\\r\\n        \\"nn\\"\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"DB\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 11,\\r\\n        \\"without_jump_clock_count\\": 11,\\r\\n        \\"description\\": \\"a byte from port * is written to A.\\",\\r\\n        \\"instruction\\": \\"in a,(*)\\"\\r\\n    }\\r\\n};\\r\\n// in b,(c)\\r\\nconst variant_ED_40 = {\\r\\n    \\"mnemonic\\": \\"in\\",\\r\\n    \\"params\\": [\\r\\n        \\"b\\",\\r\\n        \\"(c)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"b\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"c\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        64\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED40\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 12,\\r\\n        \\"without_jump_clock_count\\": 12,\\r\\n        \\"description\\": \\"a byte from port C is written to B.\\",\\r\\n        \\"instruction\\": \\"in b,(c)\\"\\r\\n    }\\r\\n};\\r\\n// in c,(c)\\r\\nconst variant_ED_48 = {\\r\\n    \\"mnemonic\\": \\"in\\",\\r\\n    \\"params\\": [\\r\\n        \\"c\\",\\r\\n        \\"(c)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"c\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"c\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        72\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED48\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 12,\\r\\n        \\"without_jump_clock_count\\": 12,\\r\\n        \\"description\\": \\"a byte from port C is written to C.\\",\\r\\n        \\"instruction\\": \\"in c,(c)\\"\\r\\n    }\\r\\n};\\r\\n// in d,(c)\\r\\nconst variant_ED_50 = {\\r\\n    \\"mnemonic\\": \\"in\\",\\r\\n    \\"params\\": [\\r\\n        \\"d\\",\\r\\n        \\"(c)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"d\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"c\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        80\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED50\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 12,\\r\\n        \\"without_jump_clock_count\\": 12,\\r\\n        \\"description\\": \\"a byte from port C is written to C.\\",\\r\\n        \\"instruction\\": \\"in d,(c)\\"\\r\\n    }\\r\\n};\\r\\n// in e,(c)\\r\\nconst variant_ED_58 = {\\r\\n    \\"mnemonic\\": \\"in\\",\\r\\n    \\"params\\": [\\r\\n        \\"e\\",\\r\\n        \\"(c)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"e\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"c\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        88\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED58\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 12,\\r\\n        \\"without_jump_clock_count\\": 12,\\r\\n        \\"description\\": \\"a byte from port C is written to E.\\",\\r\\n        \\"instruction\\": \\"in e,(c)\\"\\r\\n    }\\r\\n};\\r\\n// in h,(c)\\r\\nconst variant_ED_60 = {\\r\\n    \\"mnemonic\\": \\"in\\",\\r\\n    \\"params\\": [\\r\\n        \\"h\\",\\r\\n        \\"(c)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"h\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"c\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        96\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED60\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 12,\\r\\n        \\"without_jump_clock_count\\": 12,\\r\\n        \\"description\\": \\"a byte from port C is written to H.\\",\\r\\n        \\"instruction\\": \\"in h,(c)\\"\\r\\n    }\\r\\n};\\r\\n// in l,(c)\\r\\nconst variant_ED_68 = {\\r\\n    \\"mnemonic\\": \\"in\\",\\r\\n    \\"params\\": [\\r\\n        \\"l\\",\\r\\n        \\"(c)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"l\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"c\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        104\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED68\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 12,\\r\\n        \\"without_jump_clock_count\\": 12,\\r\\n        \\"description\\": \\"a byte from port C is written to L.\\",\\r\\n        \\"instruction\\": \\"in l,(c)\\"\\r\\n    }\\r\\n};\\r\\n// in f,(c)\\r\\nconst variant_ED_70 = {\\r\\n    \\"mnemonic\\": \\"in\\",\\r\\n    \\"params\\": [\\r\\n        \\"f\\",\\r\\n        \\"(c)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"f\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"c\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        112\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED70\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"-0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 12,\\r\\n        \\"without_jump_clock_count\\": 12,\\r\\n        \\"description\\": \\"Inputs a byte from port C and affects flags only.\\",\\r\\n        \\"instruction\\": \\"in (c)\\"\\r\\n    }\\r\\n};\\r\\n// in a,(c)\\r\\nconst variant_ED_78 = {\\r\\n    \\"mnemonic\\": \\"in\\",\\r\\n    \\"params\\": [\\r\\n        \\"a\\",\\r\\n        \\"(c)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"a\\",\\r\\n        \\",\\",\\r\\n        \\"(\\",\\r\\n        \\"c\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        120\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED78\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 12,\\r\\n        \\"without_jump_clock_count\\": 12,\\r\\n        \\"description\\": \\"a byte from port C is written to A.\\",\\r\\n        \\"instruction\\": \\"in a,(c)\\"\\r\\n    }\\r\\n};\\r\\n// in (c)\\r\\nconst variant_ED_78_pseudo = {\\r\\n    \\"mnemonic\\": \\"in\\",\\r\\n    \\"params\\": [\\r\\n        \\"(c)\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"(\\",\\r\\n        \\"c\\",\\r\\n        \\")\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        120\\r\\n    ],\\r\\n    \\"isPseudo\\": true,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED78\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 12,\\r\\n        \\"without_jump_clock_count\\": 12,\\r\\n        \\"description\\": \\"a byte from port C is written to A.\\",\\r\\n        \\"instruction\\": \\"in a,(c)\\"\\r\\n    }\\r\\n};\\r\\n// neg\\r\\nconst variant_ED_7C = {\\r\\n    \\"mnemonic\\": \\"neg\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        124\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED7C\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of A are negated (two\'s complement). Operation is the same as subtracting A from zero.\\",\\r\\n        \\"instruction\\": \\"neg\\"\\r\\n    }\\r\\n};\\r\\n// neg\\r\\nconst variant_ED_44 = {\\r\\n    \\"mnemonic\\": \\"neg\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        68\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED7C\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of A are negated (two\'s complement). Operation is the same as subtracting A from zero.\\",\\r\\n        \\"instruction\\": \\"neg\\"\\r\\n    }\\r\\n};\\r\\n// neg\\r\\nconst variant_ED_4C = {\\r\\n    \\"mnemonic\\": \\"neg\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        76\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED7C\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of A are negated (two\'s complement). Operation is the same as subtracting A from zero.\\",\\r\\n        \\"instruction\\": \\"neg\\"\\r\\n    }\\r\\n};\\r\\n// neg\\r\\nconst variant_ED_54 = {\\r\\n    \\"mnemonic\\": \\"neg\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        84\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED7C\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of A are negated (two\'s complement). Operation is the same as subtracting A from zero.\\",\\r\\n        \\"instruction\\": \\"neg\\"\\r\\n    }\\r\\n};\\r\\n// neg\\r\\nconst variant_ED_5C = {\\r\\n    \\"mnemonic\\": \\"neg\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        92\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED7C\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of A are negated (two\'s complement). Operation is the same as subtracting A from zero.\\",\\r\\n        \\"instruction\\": \\"neg\\"\\r\\n    }\\r\\n};\\r\\n// neg\\r\\nconst variant_ED_64 = {\\r\\n    \\"mnemonic\\": \\"neg\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        100\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED7C\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of A are negated (two\'s complement). Operation is the same as subtracting A from zero.\\",\\r\\n        \\"instruction\\": \\"neg\\"\\r\\n    }\\r\\n};\\r\\n// neg\\r\\nconst variant_ED_6C = {\\r\\n    \\"mnemonic\\": \\"neg\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        108\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED7C\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of A are negated (two\'s complement). Operation is the same as subtracting A from zero.\\",\\r\\n        \\"instruction\\": \\"neg\\"\\r\\n    }\\r\\n};\\r\\n// neg\\r\\nconst variant_ED_74 = {\\r\\n    \\"mnemonic\\": \\"neg\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        116\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED7C\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"++V+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"The contents of A are negated (two\'s complement). Operation is the same as subtracting A from zero.\\",\\r\\n        \\"instruction\\": \\"neg\\"\\r\\n    }\\r\\n};\\r\\n// retn\\r\\nconst variant_ED_7D = {\\r\\n    \\"mnemonic\\": \\"retn\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        125\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED7D\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 14,\\r\\n        \\"without_jump_clock_count\\": 14,\\r\\n        \\"description\\": \\"Used at the end of a non-maskable interrupt service routine (located at $0066) to pop the top stack entry into PC. The value of IFF2 is copied to IFF1 so that maskable interrupts are allowed to continue as before. NMIs are not enabled on the TI.\\",\\r\\n        \\"instruction\\": \\"retn\\"\\r\\n    }\\r\\n};\\r\\n// retn\\r\\nconst variant_ED_45 = {\\r\\n    \\"mnemonic\\": \\"retn\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        69\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED7D\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 14,\\r\\n        \\"without_jump_clock_count\\": 14,\\r\\n        \\"description\\": \\"Used at the end of a non-maskable interrupt service routine (located at $0066) to pop the top stack entry into PC. The value of IFF2 is copied to IFF1 so that maskable interrupts are allowed to continue as before. NMIs are not enabled on the TI.\\",\\r\\n        \\"instruction\\": \\"retn\\"\\r\\n    }\\r\\n};\\r\\n// retn\\r\\nconst variant_ED_55 = {\\r\\n    \\"mnemonic\\": \\"retn\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        85\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED7D\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 14,\\r\\n        \\"without_jump_clock_count\\": 14,\\r\\n        \\"description\\": \\"Used at the end of a non-maskable interrupt service routine (located at $0066) to pop the top stack entry into PC. The value of IFF2 is copied to IFF1 so that maskable interrupts are allowed to continue as before. NMIs are not enabled on the TI.\\",\\r\\n        \\"instruction\\": \\"retn\\"\\r\\n    }\\r\\n};\\r\\n// retn\\r\\nconst variant_ED_5D = {\\r\\n    \\"mnemonic\\": \\"retn\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        93\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED7D\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 14,\\r\\n        \\"without_jump_clock_count\\": 14,\\r\\n        \\"description\\": \\"Used at the end of a non-maskable interrupt service routine (located at $0066) to pop the top stack entry into PC. The value of IFF2 is copied to IFF1 so that maskable interrupts are allowed to continue as before. NMIs are not enabled on the TI.\\",\\r\\n        \\"instruction\\": \\"retn\\"\\r\\n    }\\r\\n};\\r\\n// retn\\r\\nconst variant_ED_65 = {\\r\\n    \\"mnemonic\\": \\"retn\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        101\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED7D\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 14,\\r\\n        \\"without_jump_clock_count\\": 14,\\r\\n        \\"description\\": \\"Used at the end of a non-maskable interrupt service routine (located at $0066) to pop the top stack entry into PC. The value of IFF2 is copied to IFF1 so that maskable interrupts are allowed to continue as before. NMIs are not enabled on the TI.\\",\\r\\n        \\"instruction\\": \\"retn\\"\\r\\n    }\\r\\n};\\r\\n// retn\\r\\nconst variant_ED_6D = {\\r\\n    \\"mnemonic\\": \\"retn\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        109\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED7D\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 14,\\r\\n        \\"without_jump_clock_count\\": 14,\\r\\n        \\"description\\": \\"Used at the end of a non-maskable interrupt service routine (located at $0066) to pop the top stack entry into PC. The value of IFF2 is copied to IFF1 so that maskable interrupts are allowed to continue as before. NMIs are not enabled on the TI.\\",\\r\\n        \\"instruction\\": \\"retn\\"\\r\\n    }\\r\\n};\\r\\n// retn\\r\\nconst variant_ED_75 = {\\r\\n    \\"mnemonic\\": \\"retn\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        117\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED7D\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 14,\\r\\n        \\"without_jump_clock_count\\": 14,\\r\\n        \\"description\\": \\"Used at the end of a non-maskable interrupt service routine (located at $0066) to pop the top stack entry into PC. The value of IFF2 is copied to IFF1 so that maskable interrupts are allowed to continue as before. NMIs are not enabled on the TI.\\",\\r\\n        \\"instruction\\": \\"retn\\"\\r\\n    }\\r\\n};\\r\\n// im 0\\r\\nconst variant_ED_6E = {\\r\\n    \\"mnemonic\\": \\"im\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        110\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED6E\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets undefined interrupt mode 0/1.\\",\\r\\n        \\"instruction\\": \\"im 0/1\\"\\r\\n    }\\r\\n};\\r\\n// im 0\\r\\nconst variant_ED_46 = {\\r\\n    \\"mnemonic\\": \\"im\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        70\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED6E\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets undefined interrupt mode 0/1.\\",\\r\\n        \\"instruction\\": \\"im 0/1\\"\\r\\n    }\\r\\n};\\r\\n// im 0\\r\\nconst variant_ED_4E = {\\r\\n    \\"mnemonic\\": \\"im\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        78\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED6E\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets undefined interrupt mode 0/1.\\",\\r\\n        \\"instruction\\": \\"im 0/1\\"\\r\\n    }\\r\\n};\\r\\n// im 0\\r\\nconst variant_ED_66 = {\\r\\n    \\"mnemonic\\": \\"im\\",\\r\\n    \\"params\\": [\\r\\n        \\"0\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"0\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        102\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED6E\\",\\r\\n        \\"undocumented\\": true,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets undefined interrupt mode 0/1.\\",\\r\\n        \\"instruction\\": \\"im 0/1\\"\\r\\n    }\\r\\n};\\r\\n// im 1\\r\\nconst variant_ED_76 = {\\r\\n    \\"mnemonic\\": \\"im\\",\\r\\n    \\"params\\": [\\r\\n        \\"1\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"1\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        118\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED76\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets interrupt mode 1.\\",\\r\\n        \\"instruction\\": \\"im 1\\"\\r\\n    }\\r\\n};\\r\\n// im 1\\r\\nconst variant_ED_56 = {\\r\\n    \\"mnemonic\\": \\"im\\",\\r\\n    \\"params\\": [\\r\\n        \\"1\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"1\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        86\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED76\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets interrupt mode 1.\\",\\r\\n        \\"instruction\\": \\"im 1\\"\\r\\n    }\\r\\n};\\r\\n// im 2\\r\\nconst variant_ED_7E = {\\r\\n    \\"mnemonic\\": \\"im\\",\\r\\n    \\"params\\": [\\r\\n        \\"2\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"2\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        126\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED7E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets interrupt mode 2.\\",\\r\\n        \\"instruction\\": \\"im 2\\"\\r\\n    }\\r\\n};\\r\\n// im 2\\r\\nconst variant_ED_5E = {\\r\\n    \\"mnemonic\\": \\"im\\",\\r\\n    \\"params\\": [\\r\\n        \\"2\\"\\r\\n    ],\\r\\n    \\"tokens\\": [\\r\\n        \\"2\\"\\r\\n    ],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        94\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": true,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED7E\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 8,\\r\\n        \\"without_jump_clock_count\\": 8,\\r\\n        \\"description\\": \\"Sets interrupt mode 2.\\",\\r\\n        \\"instruction\\": \\"im 2\\"\\r\\n    }\\r\\n};\\r\\n// reti\\r\\nconst variant_ED_4D = {\\r\\n    \\"mnemonic\\": \\"reti\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        77\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED4D\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 14,\\r\\n        \\"without_jump_clock_count\\": 14,\\r\\n        \\"description\\": \\"Used at the end of A maskable interrupt service routine. The top stack entry is popped into PC, and signals an I/O device that the interrupt has finished, allowing nested interrupts (not A consideration on the TI).\\",\\r\\n        \\"instruction\\": \\"reti\\"\\r\\n    }\\r\\n};\\r\\n// rrd\\r\\nconst variant_ED_67 = {\\r\\n    \\"mnemonic\\": \\"rrd\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        103\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED67\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 18,\\r\\n        \\"without_jump_clock_count\\": 18,\\r\\n        \\"description\\": \\"The contents of the low-order nibble of (HL) are copied to the low-order nibble of A. The previous contents are copied to the high-order nibble of (HL). The previous contents are copied to the low-order nibble of (HL).\\",\\r\\n        \\"instruction\\": \\"rrd\\"\\r\\n    }\\r\\n};\\r\\n// rld\\r\\nconst variant_ED_6F = {\\r\\n    \\"mnemonic\\": \\"rld\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        111\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"ED6F\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0P0++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 18,\\r\\n        \\"without_jump_clock_count\\": 18,\\r\\n        \\"description\\": \\"The contents of the low-order nibble of (HL) are copied to the high-order nibble of (HL). The previous contents are copied to the low-order nibble of A. The previous contents are copied to the low-order nibble of (HL).\\",\\r\\n        \\"instruction\\": \\"rld\\"\\r\\n    }\\r\\n};\\r\\n// ldi\\r\\nconst variant_ED_A0 = {\\r\\n    \\"mnemonic\\": \\"ldi\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        160\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"EDA0\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0*0--\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 16,\\r\\n        \\"without_jump_clock_count\\": 16,\\r\\n        \\"description\\": \\"Transfers a byte of data from the memory location pointed to by HL to the memory location pointed to by DE. Then HL and DE are incremented and BC is decremented.\\",\\r\\n        \\"instruction\\": \\"ldi\\"\\r\\n    }\\r\\n};\\r\\n// cpi\\r\\nconst variant_ED_A1 = {\\r\\n    \\"mnemonic\\": \\"cpi\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        161\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"EDA1\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-1*+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 16,\\r\\n        \\"without_jump_clock_count\\": 16,\\r\\n        \\"description\\": \\"Compares the value of the memory location pointed to by HL with A. Then HL is incremented and BC is decremented.\\",\\r\\n        \\"instruction\\": \\"cpi\\"\\r\\n    }\\r\\n};\\r\\n// ini\\r\\nconst variant_ED_A2 = {\\r\\n    \\"mnemonic\\": \\"ini\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        162\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"EDA2\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-1  * \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 16,\\r\\n        \\"without_jump_clock_count\\": 16,\\r\\n        \\"description\\": \\"a byte from port C is written to the memory location pointed to by HL. Then HL is incremented and B is decremented.\\",\\r\\n        \\"instruction\\": \\"ini\\"\\r\\n    }\\r\\n};\\r\\n// outi\\r\\nconst variant_ED_A3 = {\\r\\n    \\"mnemonic\\": \\"outi\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        163\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"EDA3\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-1  * \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 16,\\r\\n        \\"without_jump_clock_count\\": 16,\\r\\n        \\"description\\": \\"a byte from the memory location pointed to by HL is written to port C. Then HL is incremented and B is decremented.\\",\\r\\n        \\"instruction\\": \\"outi\\"\\r\\n    }\\r\\n};\\r\\n// ldd\\r\\nconst variant_ED_A8 = {\\r\\n    \\"mnemonic\\": \\"ldd\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        168\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"EDA8\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-0*0--\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 16,\\r\\n        \\"without_jump_clock_count\\": 16,\\r\\n        \\"description\\": \\"Transfers a byte of data from the memory location pointed to by HL to the memory location pointed to by DE. Then HL, DE, and BC are decremented.\\",\\r\\n        \\"instruction\\": \\"ldd\\"\\r\\n    }\\r\\n};\\r\\n// cpd\\r\\nconst variant_ED_A9 = {\\r\\n    \\"mnemonic\\": \\"cpd\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        169\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"EDA9\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-1*+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 16,\\r\\n        \\"without_jump_clock_count\\": 16,\\r\\n        \\"description\\": \\"Compares the value of the memory location pointed to by HL with A. Then HL and BC are decremented.\\",\\r\\n        \\"instruction\\": \\"cpd\\"\\r\\n    }\\r\\n};\\r\\n// ind\\r\\nconst variant_ED_AA = {\\r\\n    \\"mnemonic\\": \\"ind\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        170\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"EDAA\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-1  * \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 16,\\r\\n        \\"without_jump_clock_count\\": 16,\\r\\n        \\"description\\": \\"a byte from port C is written to the memory location pointed to by HL. Then HL and B are decremented.\\",\\r\\n        \\"instruction\\": \\"ind\\"\\r\\n    }\\r\\n};\\r\\n// outd\\r\\nconst variant_ED_AB = {\\r\\n    \\"mnemonic\\": \\"outd\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        171\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"EDAB\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-1  * \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 16,\\r\\n        \\"without_jump_clock_count\\": 16,\\r\\n        \\"description\\": \\"a byte from the memory location pointed to by HL is written to port C. Then HL and B are decremented.\\",\\r\\n        \\"instruction\\": \\"outd\\"\\r\\n    }\\r\\n};\\r\\n// ldir\\r\\nconst variant_ED_B0 = {\\r\\n    \\"mnemonic\\": \\"ldir\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        176\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"EDB0\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-000--\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 21,\\r\\n        \\"without_jump_clock_count\\": 16,\\r\\n        \\"description\\": \\"Transfers a byte of data from the memory location pointed to by HL to the memory location pointed to by DE. Then HL and DE are incremented and BC is decremented. If BC is not zero, this operation is repeated. Interrupts can trigger while this instruction is processing.\\",\\r\\n        \\"instruction\\": \\"ldir\\"\\r\\n    }\\r\\n};\\r\\n// cpir\\r\\nconst variant_ED_B1 = {\\r\\n    \\"mnemonic\\": \\"cpir\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        177\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"EDB1\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-10+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 21,\\r\\n        \\"without_jump_clock_count\\": 16,\\r\\n        \\"description\\": \\"Compares the value of the memory location pointed to by HL with A. Then HL is incremented and BC is decremented. If BC is not zero and Z is not set, this operation is repeated. Interrupts can trigger while this instruction is processing.\\",\\r\\n        \\"instruction\\": \\"cpir\\"\\r\\n    }\\r\\n};\\r\\n// inir\\r\\nconst variant_ED_B2 = {\\r\\n    \\"mnemonic\\": \\"inir\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        178\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"EDB2\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-1  1 \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 21,\\r\\n        \\"without_jump_clock_count\\": 16,\\r\\n        \\"description\\": \\"a byte from port C is written to the memory location pointed to by HL. Then HL is incremented and B is decremented. If B is not zero, this operation is repeated. Interrupts can trigger while this instruction is processing.\\",\\r\\n        \\"instruction\\": \\"inir\\"\\r\\n    }\\r\\n};\\r\\n// otir\\r\\nconst variant_ED_B3 = {\\r\\n    \\"mnemonic\\": \\"otir\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        179\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"EDB3\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-1  1 \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 21,\\r\\n        \\"without_jump_clock_count\\": 16,\\r\\n        \\"description\\": \\"a byte from the memory location pointed to by HL is written to port C. Then HL is incremented and B is decremented. If B is not zero, this operation is repeated. Interrupts can trigger while this instruction is processing.\\",\\r\\n        \\"instruction\\": \\"otir\\"\\r\\n    }\\r\\n};\\r\\n// lddr\\r\\nconst variant_ED_B8 = {\\r\\n    \\"mnemonic\\": \\"lddr\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        184\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"EDB8\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-000--\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 21,\\r\\n        \\"without_jump_clock_count\\": 16,\\r\\n        \\"description\\": \\"Transfers a byte of data from the memory location pointed to by HL to the memory location pointed to by DE. Then HL, DE, and BC are decremented. If BC is not zero, this operation is repeated. Interrupts can trigger while this instruction is processing.\\",\\r\\n        \\"instruction\\": \\"lddr\\"\\r\\n    }\\r\\n};\\r\\n// cpdr\\r\\nconst variant_ED_B9 = {\\r\\n    \\"mnemonic\\": \\"cpdr\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        185\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"EDB9\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-10+++\\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 21,\\r\\n        \\"without_jump_clock_count\\": 16,\\r\\n        \\"description\\": \\"Compares the value of the memory location pointed to by HL with A. Then HL and BC are decremented. If BC is not zero and Z is not set, this operation is repeated. Interrupts can trigger while this instruction is processing.\\",\\r\\n        \\"instruction\\": \\"cpdr\\"\\r\\n    }\\r\\n};\\r\\n// indr\\r\\nconst variant_ED_BA = {\\r\\n    \\"mnemonic\\": \\"indr\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        186\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"EDBA\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-1  1 \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 21,\\r\\n        \\"without_jump_clock_count\\": 16,\\r\\n        \\"description\\": \\"a byte from port C is written to the memory location pointed to by HL. Then HL and B are decremented. If B is not zero, this operation is repeated. Interrupts can trigger while this instruction is processing.\\",\\r\\n        \\"instruction\\": \\"indr\\"\\r\\n    }\\r\\n};\\r\\n// otdr\\r\\nconst variant_ED_BB = {\\r\\n    \\"mnemonic\\": \\"otdr\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        237,\\r\\n        187\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"EDBB\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"-1  1 \\",\\r\\n        \\"byte_count\\": 2,\\r\\n        \\"with_jump_clock_count\\": 21,\\r\\n        \\"without_jump_clock_count\\": 16,\\r\\n        \\"description\\": \\"a byte from the memory location pointed to by HL is written to port C. Then HL and B are decremented. If B is not zero, this operation is repeated. Interrupts can trigger while this instruction is processing.\\",\\r\\n        \\"instruction\\": \\"otdr\\"\\r\\n    }\\r\\n};\\r\\n// di\\r\\nconst variant_F3 = {\\r\\n    \\"mnemonic\\": \\"di\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        243\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"F3\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Resets both interrupt flip-flops, thus prenting maskable interrupts from triggering.\\",\\r\\n        \\"instruction\\": \\"di\\"\\r\\n    }\\r\\n};\\r\\n// ei\\r\\nconst variant_FB = {\\r\\n    \\"mnemonic\\": \\"ei\\",\\r\\n    \\"params\\": [],\\r\\n    \\"tokens\\": [],\\r\\n    \\"opcodes\\": [\\r\\n        251\\r\\n    ],\\r\\n    \\"isPseudo\\": false,\\r\\n    \\"isAlias\\": false,\\r\\n    \\"clr\\": {\\r\\n        \\"opcodes\\": \\"FB\\",\\r\\n        \\"undocumented\\": false,\\r\\n        \\"flags\\": \\"------\\",\\r\\n        \\"byte_count\\": 1,\\r\\n        \\"with_jump_clock_count\\": 4,\\r\\n        \\"without_jump_clock_count\\": 4,\\r\\n        \\"description\\": \\"Sets both interrupt flip-flops, thus allowing maskable interrupts to occur. An interrupt will not occur until after the immediatedly following instruction.\\",\\r\\n        \\"instruction\\": \\"ei\\"\\r\\n    }\\r\\n};\\r\\n// Map from mnemonic to array of variants.\\r\\nconst mnemonicMap = new Map([\\r\\n    [\\r\\n        \\"nop\\",\\r\\n        [\\r\\n            variant_00, // nop\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"ld\\",\\r\\n        [\\r\\n            variant_01_nnnn,\\r\\n            variant_02,\\r\\n            variant_06_nn,\\r\\n            variant_0A,\\r\\n            variant_0A_pseudo,\\r\\n            variant_0E_nn,\\r\\n            variant_11_nnnn,\\r\\n            variant_12,\\r\\n            variant_16_nn,\\r\\n            variant_1A,\\r\\n            variant_1A_pseudo,\\r\\n            variant_1E_nn,\\r\\n            variant_21_nnnn,\\r\\n            variant_22_nnnn,\\r\\n            variant_26_nn,\\r\\n            variant_2A_nnnn,\\r\\n            variant_2E_nn,\\r\\n            variant_31_nnnn,\\r\\n            variant_32_nnnn,\\r\\n            variant_36_nn,\\r\\n            variant_3A_nnnn,\\r\\n            variant_3A_nnnn_pseudo,\\r\\n            variant_3E_nn,\\r\\n            variant_3E_nn_pseudo,\\r\\n            variant_40,\\r\\n            variant_41,\\r\\n            variant_42,\\r\\n            variant_43,\\r\\n            variant_44,\\r\\n            variant_45,\\r\\n            variant_46,\\r\\n            variant_47,\\r\\n            variant_48,\\r\\n            variant_49,\\r\\n            variant_4A,\\r\\n            variant_4B,\\r\\n            variant_4C,\\r\\n            variant_4D,\\r\\n            variant_4E,\\r\\n            variant_4F,\\r\\n            variant_50,\\r\\n            variant_51,\\r\\n            variant_52,\\r\\n            variant_53,\\r\\n            variant_54,\\r\\n            variant_55,\\r\\n            variant_56,\\r\\n            variant_57,\\r\\n            variant_58,\\r\\n            variant_59,\\r\\n            variant_5A,\\r\\n            variant_5B,\\r\\n            variant_5C,\\r\\n            variant_5D,\\r\\n            variant_5E,\\r\\n            variant_5F,\\r\\n            variant_60,\\r\\n            variant_61,\\r\\n            variant_62,\\r\\n            variant_63,\\r\\n            variant_64,\\r\\n            variant_65,\\r\\n            variant_66,\\r\\n            variant_67,\\r\\n            variant_68,\\r\\n            variant_69,\\r\\n            variant_6A,\\r\\n            variant_6B,\\r\\n            variant_6C,\\r\\n            variant_6D,\\r\\n            variant_6E,\\r\\n            variant_6F,\\r\\n            variant_70,\\r\\n            variant_71,\\r\\n            variant_72,\\r\\n            variant_73,\\r\\n            variant_74,\\r\\n            variant_75,\\r\\n            variant_77,\\r\\n            variant_78,\\r\\n            variant_78_pseudo,\\r\\n            variant_79,\\r\\n            variant_79_pseudo,\\r\\n            variant_7A,\\r\\n            variant_7A_pseudo,\\r\\n            variant_7B,\\r\\n            variant_7B_pseudo,\\r\\n            variant_7C,\\r\\n            variant_7C_pseudo,\\r\\n            variant_7D,\\r\\n            variant_7D_pseudo,\\r\\n            variant_7E,\\r\\n            variant_7E_pseudo,\\r\\n            variant_7F,\\r\\n            variant_7F_pseudo,\\r\\n            variant_DD_21_nnnn,\\r\\n            variant_DD_22_nnnn,\\r\\n            variant_DD_26_nn,\\r\\n            variant_DD_2A_nnnn,\\r\\n            variant_DD_2E_nn,\\r\\n            variant_DD_36_dd_nn,\\r\\n            variant_DD_44,\\r\\n            variant_DD_45,\\r\\n            variant_DD_46_dd,\\r\\n            variant_DD_4C,\\r\\n            variant_DD_4D,\\r\\n            variant_DD_4E_dd,\\r\\n            variant_DD_54,\\r\\n            variant_DD_55,\\r\\n            variant_DD_56_dd,\\r\\n            variant_DD_5C,\\r\\n            variant_DD_5D,\\r\\n            variant_DD_5E_dd,\\r\\n            variant_DD_60,\\r\\n            variant_DD_61,\\r\\n            variant_DD_62,\\r\\n            variant_DD_63,\\r\\n            variant_DD_64,\\r\\n            variant_DD_65,\\r\\n            variant_DD_66_dd,\\r\\n            variant_DD_67,\\r\\n            variant_DD_68,\\r\\n            variant_DD_69,\\r\\n            variant_DD_6A,\\r\\n            variant_DD_6B,\\r\\n            variant_DD_6C,\\r\\n            variant_DD_6D,\\r\\n            variant_DD_6E_dd,\\r\\n            variant_DD_6F,\\r\\n            variant_DD_70_dd,\\r\\n            variant_DD_71_dd,\\r\\n            variant_DD_72_dd,\\r\\n            variant_DD_73_dd,\\r\\n            variant_DD_74_dd,\\r\\n            variant_DD_75_dd,\\r\\n            variant_DD_77_dd,\\r\\n            variant_DD_7C,\\r\\n            variant_DD_7C_pseudo,\\r\\n            variant_DD_7D,\\r\\n            variant_DD_7D_pseudo,\\r\\n            variant_DD_7E_dd,\\r\\n            variant_DD_7E_dd_pseudo,\\r\\n            variant_DD_CB_dd_00,\\r\\n            variant_DD_CB_dd_01,\\r\\n            variant_DD_CB_dd_02,\\r\\n            variant_DD_CB_dd_03,\\r\\n            variant_DD_CB_dd_04,\\r\\n            variant_DD_CB_dd_05,\\r\\n            variant_DD_CB_dd_07,\\r\\n            variant_DD_CB_dd_07_pseudo,\\r\\n            variant_DD_CB_dd_08,\\r\\n            variant_DD_CB_dd_09,\\r\\n            variant_DD_CB_dd_0A,\\r\\n            variant_DD_CB_dd_0B,\\r\\n            variant_DD_CB_dd_0C,\\r\\n            variant_DD_CB_dd_0D,\\r\\n            variant_DD_CB_dd_0F,\\r\\n            variant_DD_CB_dd_0F_pseudo,\\r\\n            variant_DD_CB_dd_10,\\r\\n            variant_DD_CB_dd_11,\\r\\n            variant_DD_CB_dd_12,\\r\\n            variant_DD_CB_dd_13,\\r\\n            variant_DD_CB_dd_14,\\r\\n            variant_DD_CB_dd_15,\\r\\n            variant_DD_CB_dd_17,\\r\\n            variant_DD_CB_dd_17_pseudo,\\r\\n            variant_DD_CB_dd_18,\\r\\n            variant_DD_CB_dd_19,\\r\\n            variant_DD_CB_dd_1A,\\r\\n            variant_DD_CB_dd_1B,\\r\\n            variant_DD_CB_dd_1C,\\r\\n            variant_DD_CB_dd_1D,\\r\\n            variant_DD_CB_dd_1F,\\r\\n            variant_DD_CB_dd_1F_pseudo,\\r\\n            variant_DD_CB_dd_20,\\r\\n            variant_DD_CB_dd_21,\\r\\n            variant_DD_CB_dd_22,\\r\\n            variant_DD_CB_dd_23,\\r\\n            variant_DD_CB_dd_24,\\r\\n            variant_DD_CB_dd_25,\\r\\n            variant_DD_CB_dd_27,\\r\\n            variant_DD_CB_dd_27_pseudo,\\r\\n            variant_DD_CB_dd_28,\\r\\n            variant_DD_CB_dd_29,\\r\\n            variant_DD_CB_dd_2A,\\r\\n            variant_DD_CB_dd_2B,\\r\\n            variant_DD_CB_dd_2C,\\r\\n            variant_DD_CB_dd_2D,\\r\\n            variant_DD_CB_dd_2F,\\r\\n            variant_DD_CB_dd_2F_pseudo,\\r\\n            variant_DD_CB_dd_30,\\r\\n            variant_DD_CB_dd_31,\\r\\n            variant_DD_CB_dd_32,\\r\\n            variant_DD_CB_dd_33,\\r\\n            variant_DD_CB_dd_34,\\r\\n            variant_DD_CB_dd_35,\\r\\n            variant_DD_CB_dd_37,\\r\\n            variant_DD_CB_dd_37_pseudo,\\r\\n            variant_DD_CB_dd_38,\\r\\n            variant_DD_CB_dd_39,\\r\\n            variant_DD_CB_dd_3A,\\r\\n            variant_DD_CB_dd_3B,\\r\\n            variant_DD_CB_dd_3C,\\r\\n            variant_DD_CB_dd_3D,\\r\\n            variant_DD_CB_dd_3F,\\r\\n            variant_DD_CB_dd_3F_pseudo,\\r\\n            variant_DD_CB_dd_80,\\r\\n            variant_DD_CB_dd_81,\\r\\n            variant_DD_CB_dd_82,\\r\\n            variant_DD_CB_dd_83,\\r\\n            variant_DD_CB_dd_84,\\r\\n            variant_DD_CB_dd_85,\\r\\n            variant_DD_CB_dd_87,\\r\\n            variant_DD_CB_dd_87_pseudo,\\r\\n            variant_DD_CB_dd_88,\\r\\n            variant_DD_CB_dd_89,\\r\\n            variant_DD_CB_dd_8A,\\r\\n            variant_DD_CB_dd_8B,\\r\\n            variant_DD_CB_dd_8C,\\r\\n            variant_DD_CB_dd_8D,\\r\\n            variant_DD_CB_dd_8F,\\r\\n            variant_DD_CB_dd_8F_pseudo,\\r\\n            variant_DD_CB_dd_90,\\r\\n            variant_DD_CB_dd_91,\\r\\n            variant_DD_CB_dd_92,\\r\\n            variant_DD_CB_dd_93,\\r\\n            variant_DD_CB_dd_94,\\r\\n            variant_DD_CB_dd_95,\\r\\n            variant_DD_CB_dd_97,\\r\\n            variant_DD_CB_dd_97_pseudo,\\r\\n            variant_DD_CB_dd_98,\\r\\n            variant_DD_CB_dd_99,\\r\\n            variant_DD_CB_dd_9A,\\r\\n            variant_DD_CB_dd_9B,\\r\\n            variant_DD_CB_dd_9C,\\r\\n            variant_DD_CB_dd_9D,\\r\\n            variant_DD_CB_dd_9F,\\r\\n            variant_DD_CB_dd_9F_pseudo,\\r\\n            variant_DD_CB_dd_A0,\\r\\n            variant_DD_CB_dd_A1,\\r\\n            variant_DD_CB_dd_A2,\\r\\n            variant_DD_CB_dd_A3,\\r\\n            variant_DD_CB_dd_A4,\\r\\n            variant_DD_CB_dd_A5,\\r\\n            variant_DD_CB_dd_A7,\\r\\n            variant_DD_CB_dd_A7_pseudo,\\r\\n            variant_DD_CB_dd_A8,\\r\\n            variant_DD_CB_dd_A9,\\r\\n            variant_DD_CB_dd_AA,\\r\\n            variant_DD_CB_dd_AB,\\r\\n            variant_DD_CB_dd_AC,\\r\\n            variant_DD_CB_dd_AD,\\r\\n            variant_DD_CB_dd_AF,\\r\\n            variant_DD_CB_dd_AF_pseudo,\\r\\n            variant_DD_CB_dd_B0,\\r\\n            variant_DD_CB_dd_B1,\\r\\n            variant_DD_CB_dd_B2,\\r\\n            variant_DD_CB_dd_B3,\\r\\n            variant_DD_CB_dd_B4,\\r\\n            variant_DD_CB_dd_B5,\\r\\n            variant_DD_CB_dd_B7,\\r\\n            variant_DD_CB_dd_B7_pseudo,\\r\\n            variant_DD_CB_dd_B8,\\r\\n            variant_DD_CB_dd_B9,\\r\\n            variant_DD_CB_dd_BA,\\r\\n            variant_DD_CB_dd_BB,\\r\\n            variant_DD_CB_dd_BC,\\r\\n            variant_DD_CB_dd_BD,\\r\\n            variant_DD_CB_dd_BF,\\r\\n            variant_DD_CB_dd_BF_pseudo,\\r\\n            variant_DD_CB_dd_C0,\\r\\n            variant_DD_CB_dd_C1,\\r\\n            variant_DD_CB_dd_C2,\\r\\n            variant_DD_CB_dd_C3,\\r\\n            variant_DD_CB_dd_C4,\\r\\n            variant_DD_CB_dd_C5,\\r\\n            variant_DD_CB_dd_C7,\\r\\n            variant_DD_CB_dd_C7_pseudo,\\r\\n            variant_DD_CB_dd_C8,\\r\\n            variant_DD_CB_dd_C9,\\r\\n            variant_DD_CB_dd_CA,\\r\\n            variant_DD_CB_dd_CB,\\r\\n            variant_DD_CB_dd_CC,\\r\\n            variant_DD_CB_dd_CD,\\r\\n            variant_DD_CB_dd_CF,\\r\\n            variant_DD_CB_dd_CF_pseudo,\\r\\n            variant_DD_CB_dd_D0,\\r\\n            variant_DD_CB_dd_D1,\\r\\n            variant_DD_CB_dd_D2,\\r\\n            variant_DD_CB_dd_D3,\\r\\n            variant_DD_CB_dd_D4,\\r\\n            variant_DD_CB_dd_D5,\\r\\n            variant_DD_CB_dd_D7,\\r\\n            variant_DD_CB_dd_D7_pseudo,\\r\\n            variant_DD_CB_dd_D8,\\r\\n            variant_DD_CB_dd_D9,\\r\\n            variant_DD_CB_dd_DA,\\r\\n            variant_DD_CB_dd_DB,\\r\\n            variant_DD_CB_dd_DC,\\r\\n            variant_DD_CB_dd_DD,\\r\\n            variant_DD_CB_dd_DF,\\r\\n            variant_DD_CB_dd_DF_pseudo,\\r\\n            variant_DD_CB_dd_E0,\\r\\n            variant_DD_CB_dd_E1,\\r\\n            variant_DD_CB_dd_E2,\\r\\n            variant_DD_CB_dd_E3,\\r\\n            variant_DD_CB_dd_E4,\\r\\n            variant_DD_CB_dd_E5,\\r\\n            variant_DD_CB_dd_E7,\\r\\n            variant_DD_CB_dd_E7_pseudo,\\r\\n            variant_DD_CB_dd_E8,\\r\\n            variant_DD_CB_dd_E9,\\r\\n            variant_DD_CB_dd_EA,\\r\\n            variant_DD_CB_dd_EB,\\r\\n            variant_DD_CB_dd_EC,\\r\\n            variant_DD_CB_dd_ED,\\r\\n            variant_DD_CB_dd_EF,\\r\\n            variant_DD_CB_dd_EF_pseudo,\\r\\n            variant_DD_CB_dd_F0,\\r\\n            variant_DD_CB_dd_F1,\\r\\n            variant_DD_CB_dd_F2,\\r\\n            variant_DD_CB_dd_F3,\\r\\n            variant_DD_CB_dd_F4,\\r\\n            variant_DD_CB_dd_F5,\\r\\n            variant_DD_CB_dd_F7,\\r\\n            variant_DD_CB_dd_F7_pseudo,\\r\\n            variant_DD_CB_dd_F8,\\r\\n            variant_DD_CB_dd_F9,\\r\\n            variant_DD_CB_dd_FA,\\r\\n            variant_DD_CB_dd_FB,\\r\\n            variant_DD_CB_dd_FC,\\r\\n            variant_DD_CB_dd_FD,\\r\\n            variant_DD_CB_dd_FF,\\r\\n            variant_DD_CB_dd_FF_pseudo,\\r\\n            variant_DD_F9,\\r\\n            variant_ED_43_nnnn,\\r\\n            variant_ED_47,\\r\\n            variant_ED_4B_nnnn,\\r\\n            variant_ED_4F,\\r\\n            variant_ED_53_nnnn,\\r\\n            variant_ED_57,\\r\\n            variant_ED_57_pseudo,\\r\\n            variant_ED_5B_nnnn,\\r\\n            variant_ED_5F,\\r\\n            variant_ED_5F_pseudo,\\r\\n            variant_ED_63_nnnn,\\r\\n            variant_ED_6B_nnnn,\\r\\n            variant_ED_73_nnnn,\\r\\n            variant_ED_7B_nnnn,\\r\\n            variant_F9,\\r\\n            variant_FD_21_nnnn,\\r\\n            variant_FD_22_nnnn,\\r\\n            variant_FD_26_nn,\\r\\n            variant_FD_2A_nnnn,\\r\\n            variant_FD_2E_nn,\\r\\n            variant_FD_36_dd_nn,\\r\\n            variant_FD_44,\\r\\n            variant_FD_45,\\r\\n            variant_FD_46_dd,\\r\\n            variant_FD_4C,\\r\\n            variant_FD_4D,\\r\\n            variant_FD_4E_dd,\\r\\n            variant_FD_54,\\r\\n            variant_FD_55,\\r\\n            variant_FD_56_dd,\\r\\n            variant_FD_5C,\\r\\n            variant_FD_5D,\\r\\n            variant_FD_5E_dd,\\r\\n            variant_FD_60,\\r\\n            variant_FD_61,\\r\\n            variant_FD_62,\\r\\n            variant_FD_63,\\r\\n            variant_FD_64,\\r\\n            variant_FD_65,\\r\\n            variant_FD_66_dd,\\r\\n            variant_FD_67,\\r\\n            variant_FD_68,\\r\\n            variant_FD_69,\\r\\n            variant_FD_6A,\\r\\n            variant_FD_6B,\\r\\n            variant_FD_6C,\\r\\n            variant_FD_6D,\\r\\n            variant_FD_6E_dd,\\r\\n            variant_FD_6F,\\r\\n            variant_FD_70_dd,\\r\\n            variant_FD_71_dd,\\r\\n            variant_FD_72_dd,\\r\\n            variant_FD_73_dd,\\r\\n            variant_FD_74_dd,\\r\\n            variant_FD_75_dd,\\r\\n            variant_FD_77_dd,\\r\\n            variant_FD_7C,\\r\\n            variant_FD_7C_pseudo,\\r\\n            variant_FD_7D,\\r\\n            variant_FD_7D_pseudo,\\r\\n            variant_FD_7E_dd,\\r\\n            variant_FD_7E_dd_pseudo,\\r\\n            variant_FD_CB_dd_00,\\r\\n            variant_FD_CB_dd_01,\\r\\n            variant_FD_CB_dd_02,\\r\\n            variant_FD_CB_dd_03,\\r\\n            variant_FD_CB_dd_04,\\r\\n            variant_FD_CB_dd_05,\\r\\n            variant_FD_CB_dd_07,\\r\\n            variant_FD_CB_dd_07_pseudo,\\r\\n            variant_FD_CB_dd_08,\\r\\n            variant_FD_CB_dd_09,\\r\\n            variant_FD_CB_dd_0A,\\r\\n            variant_FD_CB_dd_0B,\\r\\n            variant_FD_CB_dd_0C,\\r\\n            variant_FD_CB_dd_0D,\\r\\n            variant_FD_CB_dd_0F,\\r\\n            variant_FD_CB_dd_0F_pseudo,\\r\\n            variant_FD_CB_dd_10,\\r\\n            variant_FD_CB_dd_11,\\r\\n            variant_FD_CB_dd_12,\\r\\n            variant_FD_CB_dd_13,\\r\\n            variant_FD_CB_dd_14,\\r\\n            variant_FD_CB_dd_15,\\r\\n            variant_FD_CB_dd_17,\\r\\n            variant_FD_CB_dd_17_pseudo,\\r\\n            variant_FD_CB_dd_18,\\r\\n            variant_FD_CB_dd_19,\\r\\n            variant_FD_CB_dd_1A,\\r\\n            variant_FD_CB_dd_1B,\\r\\n            variant_FD_CB_dd_1C,\\r\\n            variant_FD_CB_dd_1D,\\r\\n            variant_FD_CB_dd_1F,\\r\\n            variant_FD_CB_dd_1F_pseudo,\\r\\n            variant_FD_CB_dd_20,\\r\\n            variant_FD_CB_dd_21,\\r\\n            variant_FD_CB_dd_22,\\r\\n            variant_FD_CB_dd_23,\\r\\n            variant_FD_CB_dd_24,\\r\\n            variant_FD_CB_dd_25,\\r\\n            variant_FD_CB_dd_27,\\r\\n            variant_FD_CB_dd_27_pseudo,\\r\\n            variant_FD_CB_dd_28,\\r\\n            variant_FD_CB_dd_29,\\r\\n            variant_FD_CB_dd_2A,\\r\\n            variant_FD_CB_dd_2B,\\r\\n            variant_FD_CB_dd_2C,\\r\\n            variant_FD_CB_dd_2D,\\r\\n            variant_FD_CB_dd_2F,\\r\\n            variant_FD_CB_dd_2F_pseudo,\\r\\n            variant_FD_CB_dd_30,\\r\\n            variant_FD_CB_dd_31,\\r\\n            variant_FD_CB_dd_32,\\r\\n            variant_FD_CB_dd_33,\\r\\n            variant_FD_CB_dd_34,\\r\\n            variant_FD_CB_dd_35,\\r\\n            variant_FD_CB_dd_37,\\r\\n            variant_FD_CB_dd_37_pseudo,\\r\\n            variant_FD_CB_dd_38,\\r\\n            variant_FD_CB_dd_39,\\r\\n            variant_FD_CB_dd_3A,\\r\\n            variant_FD_CB_dd_3B,\\r\\n            variant_FD_CB_dd_3C,\\r\\n            variant_FD_CB_dd_3D,\\r\\n            variant_FD_CB_dd_3F,\\r\\n            variant_FD_CB_dd_3F_pseudo,\\r\\n            variant_FD_CB_dd_80,\\r\\n            variant_FD_CB_dd_81,\\r\\n            variant_FD_CB_dd_82,\\r\\n            variant_FD_CB_dd_83,\\r\\n            variant_FD_CB_dd_84,\\r\\n            variant_FD_CB_dd_85,\\r\\n            variant_FD_CB_dd_87,\\r\\n            variant_FD_CB_dd_87_pseudo,\\r\\n            variant_FD_CB_dd_88,\\r\\n            variant_FD_CB_dd_89,\\r\\n            variant_FD_CB_dd_8A,\\r\\n            variant_FD_CB_dd_8B,\\r\\n            variant_FD_CB_dd_8C,\\r\\n            variant_FD_CB_dd_8D,\\r\\n            variant_FD_CB_dd_8F,\\r\\n            variant_FD_CB_dd_8F_pseudo,\\r\\n            variant_FD_CB_dd_90,\\r\\n            variant_FD_CB_dd_91,\\r\\n            variant_FD_CB_dd_92,\\r\\n            variant_FD_CB_dd_93,\\r\\n            variant_FD_CB_dd_94,\\r\\n            variant_FD_CB_dd_95,\\r\\n            variant_FD_CB_dd_97,\\r\\n            variant_FD_CB_dd_97_pseudo,\\r\\n            variant_FD_CB_dd_98,\\r\\n            variant_FD_CB_dd_99,\\r\\n            variant_FD_CB_dd_9A,\\r\\n            variant_FD_CB_dd_9B,\\r\\n            variant_FD_CB_dd_9C,\\r\\n            variant_FD_CB_dd_9D,\\r\\n            variant_FD_CB_dd_9F,\\r\\n            variant_FD_CB_dd_9F_pseudo,\\r\\n            variant_FD_CB_dd_A0,\\r\\n            variant_FD_CB_dd_A1,\\r\\n            variant_FD_CB_dd_A2,\\r\\n            variant_FD_CB_dd_A3,\\r\\n            variant_FD_CB_dd_A4,\\r\\n            variant_FD_CB_dd_A5,\\r\\n            variant_FD_CB_dd_A7,\\r\\n            variant_FD_CB_dd_A7_pseudo,\\r\\n            variant_FD_CB_dd_A8,\\r\\n            variant_FD_CB_dd_A9,\\r\\n            variant_FD_CB_dd_AA,\\r\\n            variant_FD_CB_dd_AB,\\r\\n            variant_FD_CB_dd_AC,\\r\\n            variant_FD_CB_dd_AD,\\r\\n            variant_FD_CB_dd_AF,\\r\\n            variant_FD_CB_dd_AF_pseudo,\\r\\n            variant_FD_CB_dd_B0,\\r\\n            variant_FD_CB_dd_B1,\\r\\n            variant_FD_CB_dd_B2,\\r\\n            variant_FD_CB_dd_B3,\\r\\n            variant_FD_CB_dd_B4,\\r\\n            variant_FD_CB_dd_B5,\\r\\n            variant_FD_CB_dd_B7,\\r\\n            variant_FD_CB_dd_B7_pseudo,\\r\\n            variant_FD_CB_dd_B8,\\r\\n            variant_FD_CB_dd_B9,\\r\\n            variant_FD_CB_dd_BA,\\r\\n            variant_FD_CB_dd_BB,\\r\\n            variant_FD_CB_dd_BC,\\r\\n            variant_FD_CB_dd_BD,\\r\\n            variant_FD_CB_dd_BF,\\r\\n            variant_FD_CB_dd_BF_pseudo,\\r\\n            variant_FD_CB_dd_C0,\\r\\n            variant_FD_CB_dd_C1,\\r\\n            variant_FD_CB_dd_C2,\\r\\n            variant_FD_CB_dd_C3,\\r\\n            variant_FD_CB_dd_C4,\\r\\n            variant_FD_CB_dd_C5,\\r\\n            variant_FD_CB_dd_C7,\\r\\n            variant_FD_CB_dd_C7_pseudo,\\r\\n            variant_FD_CB_dd_C8,\\r\\n            variant_FD_CB_dd_C9,\\r\\n            variant_FD_CB_dd_CA,\\r\\n            variant_FD_CB_dd_CB,\\r\\n            variant_FD_CB_dd_CC,\\r\\n            variant_FD_CB_dd_CD,\\r\\n            variant_FD_CB_dd_CF,\\r\\n            variant_FD_CB_dd_CF_pseudo,\\r\\n            variant_FD_CB_dd_D0,\\r\\n            variant_FD_CB_dd_D1,\\r\\n            variant_FD_CB_dd_D2,\\r\\n            variant_FD_CB_dd_D3,\\r\\n            variant_FD_CB_dd_D4,\\r\\n            variant_FD_CB_dd_D5,\\r\\n            variant_FD_CB_dd_D7,\\r\\n            variant_FD_CB_dd_D7_pseudo,\\r\\n            variant_FD_CB_dd_D8,\\r\\n            variant_FD_CB_dd_D9,\\r\\n            variant_FD_CB_dd_DA,\\r\\n            variant_FD_CB_dd_DB,\\r\\n            variant_FD_CB_dd_DC,\\r\\n            variant_FD_CB_dd_DD,\\r\\n            variant_FD_CB_dd_DF,\\r\\n            variant_FD_CB_dd_DF_pseudo,\\r\\n            variant_FD_CB_dd_E0,\\r\\n            variant_FD_CB_dd_E1,\\r\\n            variant_FD_CB_dd_E2,\\r\\n            variant_FD_CB_dd_E3,\\r\\n            variant_FD_CB_dd_E4,\\r\\n            variant_FD_CB_dd_E5,\\r\\n            variant_FD_CB_dd_E7,\\r\\n            variant_FD_CB_dd_E7_pseudo,\\r\\n            variant_FD_CB_dd_E8,\\r\\n            variant_FD_CB_dd_E9,\\r\\n            variant_FD_CB_dd_EA,\\r\\n            variant_FD_CB_dd_EB,\\r\\n            variant_FD_CB_dd_EC,\\r\\n            variant_FD_CB_dd_ED,\\r\\n            variant_FD_CB_dd_EF,\\r\\n            variant_FD_CB_dd_EF_pseudo,\\r\\n            variant_FD_CB_dd_F0,\\r\\n            variant_FD_CB_dd_F1,\\r\\n            variant_FD_CB_dd_F2,\\r\\n            variant_FD_CB_dd_F3,\\r\\n            variant_FD_CB_dd_F4,\\r\\n            variant_FD_CB_dd_F5,\\r\\n            variant_FD_CB_dd_F7,\\r\\n            variant_FD_CB_dd_F7_pseudo,\\r\\n            variant_FD_CB_dd_F8,\\r\\n            variant_FD_CB_dd_F9,\\r\\n            variant_FD_CB_dd_FA,\\r\\n            variant_FD_CB_dd_FB,\\r\\n            variant_FD_CB_dd_FC,\\r\\n            variant_FD_CB_dd_FD,\\r\\n            variant_FD_CB_dd_FF,\\r\\n            variant_FD_CB_dd_FF_pseudo,\\r\\n            variant_FD_F9,\\r\\n            variant_60_69_pseudo,\\r\\n            variant_44_4D_pseudo,\\r\\n            variant_54_5D_pseudo,\\r\\n            variant_62_6B_pseudo,\\r\\n            variant_4E_23_46_2B_pseudo,\\r\\n            variant_71_23_70_2B_pseudo,\\r\\n            variant_73_23_72_2B_pseudo,\\r\\n            variant_50_59_pseudo, // ld de,bc\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"inc\\",\\r\\n        [\\r\\n            variant_03,\\r\\n            variant_04,\\r\\n            variant_0C,\\r\\n            variant_13,\\r\\n            variant_14,\\r\\n            variant_1C,\\r\\n            variant_23,\\r\\n            variant_24,\\r\\n            variant_2C,\\r\\n            variant_33,\\r\\n            variant_34,\\r\\n            variant_3C,\\r\\n            variant_DD_23,\\r\\n            variant_DD_24,\\r\\n            variant_DD_2C,\\r\\n            variant_DD_34_dd,\\r\\n            variant_FD_23,\\r\\n            variant_FD_24,\\r\\n            variant_FD_2C,\\r\\n            variant_FD_34_dd, // inc (iy+dd)\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"dec\\",\\r\\n        [\\r\\n            variant_05,\\r\\n            variant_0B,\\r\\n            variant_0D,\\r\\n            variant_15,\\r\\n            variant_1B,\\r\\n            variant_1D,\\r\\n            variant_25,\\r\\n            variant_2B,\\r\\n            variant_2D,\\r\\n            variant_35,\\r\\n            variant_3B,\\r\\n            variant_3D,\\r\\n            variant_DD_25,\\r\\n            variant_DD_2B,\\r\\n            variant_DD_2D,\\r\\n            variant_DD_35_dd,\\r\\n            variant_FD_25,\\r\\n            variant_FD_2B,\\r\\n            variant_FD_2D,\\r\\n            variant_FD_35_dd, // dec (iy+dd)\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"rlca\\",\\r\\n        [\\r\\n            variant_07, // rlca\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"ex\\",\\r\\n        [\\r\\n            variant_08,\\r\\n            variant_DD_E3,\\r\\n            variant_E3,\\r\\n            variant_EB,\\r\\n            variant_FD_E3, // ex (sp),iy\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"add\\",\\r\\n        [\\r\\n            variant_09,\\r\\n            variant_19,\\r\\n            variant_29,\\r\\n            variant_39,\\r\\n            variant_80,\\r\\n            variant_80_pseudo,\\r\\n            variant_81,\\r\\n            variant_81_pseudo,\\r\\n            variant_82,\\r\\n            variant_82_pseudo,\\r\\n            variant_83,\\r\\n            variant_83_pseudo,\\r\\n            variant_84,\\r\\n            variant_84_pseudo,\\r\\n            variant_85,\\r\\n            variant_85_pseudo,\\r\\n            variant_86,\\r\\n            variant_86_pseudo,\\r\\n            variant_87,\\r\\n            variant_87_pseudo,\\r\\n            variant_C6_nn,\\r\\n            variant_C6_nn_pseudo,\\r\\n            variant_DD_09,\\r\\n            variant_DD_19,\\r\\n            variant_DD_29,\\r\\n            variant_DD_39,\\r\\n            variant_DD_84,\\r\\n            variant_DD_84_pseudo,\\r\\n            variant_DD_85,\\r\\n            variant_DD_85_pseudo,\\r\\n            variant_DD_86_dd,\\r\\n            variant_DD_86_dd_pseudo,\\r\\n            variant_FD_09,\\r\\n            variant_FD_19,\\r\\n            variant_FD_29,\\r\\n            variant_FD_39,\\r\\n            variant_FD_84,\\r\\n            variant_FD_84_pseudo,\\r\\n            variant_FD_85,\\r\\n            variant_FD_85_pseudo,\\r\\n            variant_FD_86_dd,\\r\\n            variant_FD_86_dd_pseudo, // add (iy+dd)\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"rrca\\",\\r\\n        [\\r\\n            variant_0F, // rrca\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"djnz\\",\\r\\n        [\\r\\n            variant_10_offset, // djnz offset\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"rla\\",\\r\\n        [\\r\\n            variant_17, // rla\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"jr\\",\\r\\n        [\\r\\n            variant_18_offset,\\r\\n            variant_20_offset,\\r\\n            variant_28_offset,\\r\\n            variant_30_offset,\\r\\n            variant_38_offset, // jr c,offset\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"rra\\",\\r\\n        [\\r\\n            variant_1F, // rra\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"daa\\",\\r\\n        [\\r\\n            variant_27, // daa\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"cpl\\",\\r\\n        [\\r\\n            variant_2F, // cpl\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"scf\\",\\r\\n        [\\r\\n            variant_37, // scf\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"ccf\\",\\r\\n        [\\r\\n            variant_3F, // ccf\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"halt\\",\\r\\n        [\\r\\n            variant_76, // halt\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"adc\\",\\r\\n        [\\r\\n            variant_88,\\r\\n            variant_88_pseudo,\\r\\n            variant_89,\\r\\n            variant_89_pseudo,\\r\\n            variant_8A,\\r\\n            variant_8A_pseudo,\\r\\n            variant_8B,\\r\\n            variant_8B_pseudo,\\r\\n            variant_8C,\\r\\n            variant_8C_pseudo,\\r\\n            variant_8D,\\r\\n            variant_8D_pseudo,\\r\\n            variant_8E,\\r\\n            variant_8E_pseudo,\\r\\n            variant_8F,\\r\\n            variant_8F_pseudo,\\r\\n            variant_CE_nn,\\r\\n            variant_CE_nn_pseudo,\\r\\n            variant_DD_8C,\\r\\n            variant_DD_8C_pseudo,\\r\\n            variant_DD_8D,\\r\\n            variant_DD_8D_pseudo,\\r\\n            variant_DD_8E_dd,\\r\\n            variant_DD_8E_dd_pseudo,\\r\\n            variant_ED_4A,\\r\\n            variant_ED_5A,\\r\\n            variant_ED_6A,\\r\\n            variant_ED_7A,\\r\\n            variant_FD_8C,\\r\\n            variant_FD_8C_pseudo,\\r\\n            variant_FD_8D,\\r\\n            variant_FD_8D_pseudo,\\r\\n            variant_FD_8E_dd,\\r\\n            variant_FD_8E_dd_pseudo, // adc (iy+dd)\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"sub\\",\\r\\n        [\\r\\n            variant_90,\\r\\n            variant_90_pseudo,\\r\\n            variant_91,\\r\\n            variant_91_pseudo,\\r\\n            variant_92,\\r\\n            variant_92_pseudo,\\r\\n            variant_93,\\r\\n            variant_93_pseudo,\\r\\n            variant_94,\\r\\n            variant_94_pseudo,\\r\\n            variant_95,\\r\\n            variant_95_pseudo,\\r\\n            variant_96,\\r\\n            variant_96_pseudo,\\r\\n            variant_97,\\r\\n            variant_97_pseudo,\\r\\n            variant_D6_nn,\\r\\n            variant_D6_nn_pseudo,\\r\\n            variant_DD_94,\\r\\n            variant_DD_94_pseudo,\\r\\n            variant_DD_95,\\r\\n            variant_DD_95_pseudo,\\r\\n            variant_DD_96_dd,\\r\\n            variant_DD_96_dd_pseudo,\\r\\n            variant_FD_94,\\r\\n            variant_FD_94_pseudo,\\r\\n            variant_FD_95,\\r\\n            variant_FD_95_pseudo,\\r\\n            variant_FD_96_dd,\\r\\n            variant_FD_96_dd_pseudo, // sub (iy+dd)\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"sbc\\",\\r\\n        [\\r\\n            variant_98,\\r\\n            variant_98_pseudo,\\r\\n            variant_99,\\r\\n            variant_99_pseudo,\\r\\n            variant_9A,\\r\\n            variant_9A_pseudo,\\r\\n            variant_9B,\\r\\n            variant_9B_pseudo,\\r\\n            variant_9C,\\r\\n            variant_9C_pseudo,\\r\\n            variant_9D,\\r\\n            variant_9D_pseudo,\\r\\n            variant_9E,\\r\\n            variant_9E_pseudo,\\r\\n            variant_9F,\\r\\n            variant_9F_pseudo,\\r\\n            variant_DD_9C,\\r\\n            variant_DD_9C_pseudo,\\r\\n            variant_DD_9D,\\r\\n            variant_DD_9D_pseudo,\\r\\n            variant_DD_9E_dd,\\r\\n            variant_DD_9E_dd_pseudo,\\r\\n            variant_DE_nn,\\r\\n            variant_DE_nn_pseudo,\\r\\n            variant_ED_42,\\r\\n            variant_ED_52,\\r\\n            variant_ED_62,\\r\\n            variant_ED_72,\\r\\n            variant_FD_9C,\\r\\n            variant_FD_9C_pseudo,\\r\\n            variant_FD_9D,\\r\\n            variant_FD_9D_pseudo,\\r\\n            variant_FD_9E_dd,\\r\\n            variant_FD_9E_dd_pseudo, // sbc (iy+dd)\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"and\\",\\r\\n        [\\r\\n            variant_A0,\\r\\n            variant_A0_pseudo,\\r\\n            variant_A1,\\r\\n            variant_A1_pseudo,\\r\\n            variant_A2,\\r\\n            variant_A2_pseudo,\\r\\n            variant_A3,\\r\\n            variant_A3_pseudo,\\r\\n            variant_A4,\\r\\n            variant_A4_pseudo,\\r\\n            variant_A5,\\r\\n            variant_A5_pseudo,\\r\\n            variant_A6,\\r\\n            variant_A6_pseudo,\\r\\n            variant_A7,\\r\\n            variant_A7_pseudo,\\r\\n            variant_DD_A4,\\r\\n            variant_DD_A4_pseudo,\\r\\n            variant_DD_A5,\\r\\n            variant_DD_A5_pseudo,\\r\\n            variant_DD_A6_dd,\\r\\n            variant_DD_A6_dd_pseudo,\\r\\n            variant_E6_nn,\\r\\n            variant_FD_A4,\\r\\n            variant_FD_A4_pseudo,\\r\\n            variant_FD_A5,\\r\\n            variant_FD_A5_pseudo,\\r\\n            variant_FD_A6_dd,\\r\\n            variant_FD_A6_dd_pseudo, // and (iy+dd)\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"xor\\",\\r\\n        [\\r\\n            variant_A8,\\r\\n            variant_A8_pseudo,\\r\\n            variant_A9,\\r\\n            variant_A9_pseudo,\\r\\n            variant_AA,\\r\\n            variant_AA_pseudo,\\r\\n            variant_AB,\\r\\n            variant_AB_pseudo,\\r\\n            variant_AC,\\r\\n            variant_AC_pseudo,\\r\\n            variant_AD,\\r\\n            variant_AD_pseudo,\\r\\n            variant_AE,\\r\\n            variant_AE_pseudo,\\r\\n            variant_AF,\\r\\n            variant_AF_pseudo,\\r\\n            variant_DD_AC,\\r\\n            variant_DD_AC_pseudo,\\r\\n            variant_DD_AD,\\r\\n            variant_DD_AD_pseudo,\\r\\n            variant_DD_AE_dd,\\r\\n            variant_DD_AE_dd_pseudo,\\r\\n            variant_EE_nn,\\r\\n            variant_EE_nn_pseudo,\\r\\n            variant_FD_AC,\\r\\n            variant_FD_AC_pseudo,\\r\\n            variant_FD_AD,\\r\\n            variant_FD_AD_pseudo,\\r\\n            variant_FD_AE_dd,\\r\\n            variant_FD_AE_dd_pseudo, // xor (iy+dd)\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"or\\",\\r\\n        [\\r\\n            variant_B0,\\r\\n            variant_B0_pseudo,\\r\\n            variant_B1,\\r\\n            variant_B1_pseudo,\\r\\n            variant_B2,\\r\\n            variant_B2_pseudo,\\r\\n            variant_B3,\\r\\n            variant_B3_pseudo,\\r\\n            variant_B4,\\r\\n            variant_B4_pseudo,\\r\\n            variant_B5,\\r\\n            variant_B5_pseudo,\\r\\n            variant_B6,\\r\\n            variant_B6_pseudo,\\r\\n            variant_B7,\\r\\n            variant_B7_pseudo,\\r\\n            variant_DD_B4,\\r\\n            variant_DD_B4_pseudo,\\r\\n            variant_DD_B5,\\r\\n            variant_DD_B5_pseudo,\\r\\n            variant_DD_B6_dd,\\r\\n            variant_DD_B6_dd_pseudo,\\r\\n            variant_F6_nn,\\r\\n            variant_FD_B4,\\r\\n            variant_FD_B4_pseudo,\\r\\n            variant_FD_B5,\\r\\n            variant_FD_B5_pseudo,\\r\\n            variant_FD_B6_dd,\\r\\n            variant_FD_B6_dd_pseudo, // or (iy+dd)\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"cp\\",\\r\\n        [\\r\\n            variant_B8,\\r\\n            variant_B9,\\r\\n            variant_BA,\\r\\n            variant_BB,\\r\\n            variant_BC,\\r\\n            variant_BD,\\r\\n            variant_BE,\\r\\n            variant_BF,\\r\\n            variant_DD_BC,\\r\\n            variant_DD_BD,\\r\\n            variant_DD_BE_dd,\\r\\n            variant_FD_BC,\\r\\n            variant_FD_BD,\\r\\n            variant_FD_BE_dd,\\r\\n            variant_FE_nn, // cp nn\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"ret\\",\\r\\n        [\\r\\n            variant_C0,\\r\\n            variant_C8,\\r\\n            variant_C9,\\r\\n            variant_D0,\\r\\n            variant_D8,\\r\\n            variant_E0,\\r\\n            variant_E8,\\r\\n            variant_F0,\\r\\n            variant_F8, // ret m\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"pop\\",\\r\\n        [\\r\\n            variant_C1,\\r\\n            variant_D1,\\r\\n            variant_DD_E1,\\r\\n            variant_E1,\\r\\n            variant_F1,\\r\\n            variant_FD_E1, // pop iy\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"jp\\",\\r\\n        [\\r\\n            variant_C2_nnnn,\\r\\n            variant_C3_nnnn,\\r\\n            variant_CA_nnnn,\\r\\n            variant_D2_nnnn,\\r\\n            variant_DA_nnnn,\\r\\n            variant_DD_E9,\\r\\n            variant_E2_nnnn,\\r\\n            variant_E9,\\r\\n            variant_E9_pseudo,\\r\\n            variant_EA_nnnn,\\r\\n            variant_F2_nnnn,\\r\\n            variant_FA_nnnn,\\r\\n            variant_FD_E9, // jp iy\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"call\\",\\r\\n        [\\r\\n            variant_C4_nnnn,\\r\\n            variant_CC_nnnn,\\r\\n            variant_CD_nnnn,\\r\\n            variant_D4_nnnn,\\r\\n            variant_DC_nnnn,\\r\\n            variant_E4_nnnn,\\r\\n            variant_EC_nnnn,\\r\\n            variant_F4_nnnn,\\r\\n            variant_FC_nnnn, // call m,nnnn\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"push\\",\\r\\n        [\\r\\n            variant_C5,\\r\\n            variant_D5,\\r\\n            variant_DD_E5,\\r\\n            variant_E5,\\r\\n            variant_F5,\\r\\n            variant_FD_E5, // push iy\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"rst\\",\\r\\n        [\\r\\n            variant_C7,\\r\\n            variant_CF,\\r\\n            variant_D7,\\r\\n            variant_DF,\\r\\n            variant_E7,\\r\\n            variant_EF,\\r\\n            variant_F7,\\r\\n            variant_FF, // rst 38\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"rlc\\",\\r\\n        [\\r\\n            variant_CB_00,\\r\\n            variant_CB_01,\\r\\n            variant_CB_02,\\r\\n            variant_CB_03,\\r\\n            variant_CB_04,\\r\\n            variant_CB_05,\\r\\n            variant_CB_06,\\r\\n            variant_CB_07,\\r\\n            variant_DD_CB_dd_06,\\r\\n            variant_FD_CB_dd_06, // rlc (iy+dd)\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"rrc\\",\\r\\n        [\\r\\n            variant_CB_08,\\r\\n            variant_CB_09,\\r\\n            variant_CB_0A,\\r\\n            variant_CB_0B,\\r\\n            variant_CB_0C,\\r\\n            variant_CB_0D,\\r\\n            variant_CB_0E,\\r\\n            variant_CB_0F,\\r\\n            variant_DD_CB_dd_0E,\\r\\n            variant_FD_CB_dd_0E, // rrc (iy+dd)\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"rl\\",\\r\\n        [\\r\\n            variant_CB_10,\\r\\n            variant_CB_11,\\r\\n            variant_CB_12,\\r\\n            variant_CB_13,\\r\\n            variant_CB_14,\\r\\n            variant_CB_15,\\r\\n            variant_CB_16,\\r\\n            variant_CB_17,\\r\\n            variant_DD_CB_dd_16,\\r\\n            variant_FD_CB_dd_16, // rl (iy+dd)\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"rr\\",\\r\\n        [\\r\\n            variant_CB_18,\\r\\n            variant_CB_19,\\r\\n            variant_CB_1A,\\r\\n            variant_CB_1B,\\r\\n            variant_CB_1C,\\r\\n            variant_CB_1D,\\r\\n            variant_CB_1E,\\r\\n            variant_CB_1F,\\r\\n            variant_DD_CB_dd_1E,\\r\\n            variant_FD_CB_dd_1E, // rr (iy+dd)\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"sla\\",\\r\\n        [\\r\\n            variant_CB_20,\\r\\n            variant_CB_21,\\r\\n            variant_CB_22,\\r\\n            variant_CB_23,\\r\\n            variant_CB_24,\\r\\n            variant_CB_25,\\r\\n            variant_CB_26,\\r\\n            variant_CB_27,\\r\\n            variant_DD_CB_dd_26,\\r\\n            variant_FD_CB_dd_26, // sla (iy+dd)\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"sra\\",\\r\\n        [\\r\\n            variant_CB_28,\\r\\n            variant_CB_29,\\r\\n            variant_CB_2A,\\r\\n            variant_CB_2B,\\r\\n            variant_CB_2C,\\r\\n            variant_CB_2D,\\r\\n            variant_CB_2E,\\r\\n            variant_CB_2F,\\r\\n            variant_DD_CB_dd_2E,\\r\\n            variant_FD_CB_dd_2E, // sra (iy+dd)\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"sll\\",\\r\\n        [\\r\\n            variant_CB_30,\\r\\n            variant_CB_31,\\r\\n            variant_CB_32,\\r\\n            variant_CB_33,\\r\\n            variant_CB_34,\\r\\n            variant_CB_35,\\r\\n            variant_CB_36,\\r\\n            variant_CB_37,\\r\\n            variant_DD_CB_dd_36,\\r\\n            variant_FD_CB_dd_36, // sll (iy+dd)\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"srl\\",\\r\\n        [\\r\\n            variant_CB_38,\\r\\n            variant_CB_39,\\r\\n            variant_CB_3A,\\r\\n            variant_CB_3B,\\r\\n            variant_CB_3C,\\r\\n            variant_CB_3D,\\r\\n            variant_CB_3E,\\r\\n            variant_CB_3F,\\r\\n            variant_DD_CB_dd_3E,\\r\\n            variant_FD_CB_dd_3E, // srl (iy+dd)\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"bit\\",\\r\\n        [\\r\\n            variant_CB_40,\\r\\n            variant_CB_41,\\r\\n            variant_CB_42,\\r\\n            variant_CB_43,\\r\\n            variant_CB_44,\\r\\n            variant_CB_45,\\r\\n            variant_CB_46,\\r\\n            variant_CB_47,\\r\\n            variant_CB_48,\\r\\n            variant_CB_49,\\r\\n            variant_CB_4A,\\r\\n            variant_CB_4B,\\r\\n            variant_CB_4C,\\r\\n            variant_CB_4D,\\r\\n            variant_CB_4E,\\r\\n            variant_CB_4F,\\r\\n            variant_CB_50,\\r\\n            variant_CB_51,\\r\\n            variant_CB_52,\\r\\n            variant_CB_53,\\r\\n            variant_CB_54,\\r\\n            variant_CB_55,\\r\\n            variant_CB_56,\\r\\n            variant_CB_57,\\r\\n            variant_CB_58,\\r\\n            variant_CB_59,\\r\\n            variant_CB_5A,\\r\\n            variant_CB_5B,\\r\\n            variant_CB_5C,\\r\\n            variant_CB_5D,\\r\\n            variant_CB_5E,\\r\\n            variant_CB_5F,\\r\\n            variant_CB_60,\\r\\n            variant_CB_61,\\r\\n            variant_CB_62,\\r\\n            variant_CB_63,\\r\\n            variant_CB_64,\\r\\n            variant_CB_65,\\r\\n            variant_CB_66,\\r\\n            variant_CB_67,\\r\\n            variant_CB_68,\\r\\n            variant_CB_69,\\r\\n            variant_CB_6A,\\r\\n            variant_CB_6B,\\r\\n            variant_CB_6C,\\r\\n            variant_CB_6D,\\r\\n            variant_CB_6E,\\r\\n            variant_CB_6F,\\r\\n            variant_CB_70,\\r\\n            variant_CB_71,\\r\\n            variant_CB_72,\\r\\n            variant_CB_73,\\r\\n            variant_CB_74,\\r\\n            variant_CB_75,\\r\\n            variant_CB_76,\\r\\n            variant_CB_77,\\r\\n            variant_CB_78,\\r\\n            variant_CB_79,\\r\\n            variant_CB_7A,\\r\\n            variant_CB_7B,\\r\\n            variant_CB_7C,\\r\\n            variant_CB_7D,\\r\\n            variant_CB_7E,\\r\\n            variant_CB_7F,\\r\\n            variant_DD_CB_dd_47,\\r\\n            variant_DD_CB_dd_4F,\\r\\n            variant_DD_CB_dd_57,\\r\\n            variant_DD_CB_dd_5F,\\r\\n            variant_DD_CB_dd_67,\\r\\n            variant_DD_CB_dd_6F,\\r\\n            variant_DD_CB_dd_77,\\r\\n            variant_DD_CB_dd_7F,\\r\\n            variant_FD_CB_dd_47,\\r\\n            variant_FD_CB_dd_4F,\\r\\n            variant_FD_CB_dd_57,\\r\\n            variant_FD_CB_dd_5F,\\r\\n            variant_FD_CB_dd_67,\\r\\n            variant_FD_CB_dd_6F,\\r\\n            variant_FD_CB_dd_77,\\r\\n            variant_FD_CB_dd_7F, // bit 7,(iy+dd)\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"res\\",\\r\\n        [\\r\\n            variant_CB_80,\\r\\n            variant_CB_81,\\r\\n            variant_CB_82,\\r\\n            variant_CB_83,\\r\\n            variant_CB_84,\\r\\n            variant_CB_85,\\r\\n            variant_CB_86,\\r\\n            variant_CB_87,\\r\\n            variant_CB_88,\\r\\n            variant_CB_89,\\r\\n            variant_CB_8A,\\r\\n            variant_CB_8B,\\r\\n            variant_CB_8C,\\r\\n            variant_CB_8D,\\r\\n            variant_CB_8E,\\r\\n            variant_CB_8F,\\r\\n            variant_CB_90,\\r\\n            variant_CB_91,\\r\\n            variant_CB_92,\\r\\n            variant_CB_93,\\r\\n            variant_CB_94,\\r\\n            variant_CB_95,\\r\\n            variant_CB_96,\\r\\n            variant_CB_97,\\r\\n            variant_CB_98,\\r\\n            variant_CB_99,\\r\\n            variant_CB_9A,\\r\\n            variant_CB_9B,\\r\\n            variant_CB_9C,\\r\\n            variant_CB_9D,\\r\\n            variant_CB_9E,\\r\\n            variant_CB_9F,\\r\\n            variant_CB_A0,\\r\\n            variant_CB_A1,\\r\\n            variant_CB_A2,\\r\\n            variant_CB_A3,\\r\\n            variant_CB_A4,\\r\\n            variant_CB_A5,\\r\\n            variant_CB_A6,\\r\\n            variant_CB_A7,\\r\\n            variant_CB_A8,\\r\\n            variant_CB_A9,\\r\\n            variant_CB_AA,\\r\\n            variant_CB_AB,\\r\\n            variant_CB_AC,\\r\\n            variant_CB_AD,\\r\\n            variant_CB_AE,\\r\\n            variant_CB_AF,\\r\\n            variant_CB_B0,\\r\\n            variant_CB_B1,\\r\\n            variant_CB_B2,\\r\\n            variant_CB_B3,\\r\\n            variant_CB_B4,\\r\\n            variant_CB_B5,\\r\\n            variant_CB_B6,\\r\\n            variant_CB_B7,\\r\\n            variant_CB_B8,\\r\\n            variant_CB_B9,\\r\\n            variant_CB_BA,\\r\\n            variant_CB_BB,\\r\\n            variant_CB_BC,\\r\\n            variant_CB_BD,\\r\\n            variant_CB_BE,\\r\\n            variant_CB_BF,\\r\\n            variant_DD_CB_dd_86,\\r\\n            variant_DD_CB_dd_8E,\\r\\n            variant_DD_CB_dd_96,\\r\\n            variant_DD_CB_dd_9E,\\r\\n            variant_DD_CB_dd_A6,\\r\\n            variant_DD_CB_dd_AE,\\r\\n            variant_DD_CB_dd_B6,\\r\\n            variant_DD_CB_dd_BE,\\r\\n            variant_FD_CB_dd_86,\\r\\n            variant_FD_CB_dd_8E,\\r\\n            variant_FD_CB_dd_96,\\r\\n            variant_FD_CB_dd_9E,\\r\\n            variant_FD_CB_dd_A6,\\r\\n            variant_FD_CB_dd_AE,\\r\\n            variant_FD_CB_dd_B6,\\r\\n            variant_FD_CB_dd_BE, // res 7,(iy+dd)\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"set\\",\\r\\n        [\\r\\n            variant_CB_C0,\\r\\n            variant_CB_C1,\\r\\n            variant_CB_C2,\\r\\n            variant_CB_C3,\\r\\n            variant_CB_C4,\\r\\n            variant_CB_C5,\\r\\n            variant_CB_C6,\\r\\n            variant_CB_C7,\\r\\n            variant_CB_C8,\\r\\n            variant_CB_C9,\\r\\n            variant_CB_CA,\\r\\n            variant_CB_CB,\\r\\n            variant_CB_CC,\\r\\n            variant_CB_CD,\\r\\n            variant_CB_CE,\\r\\n            variant_CB_CF,\\r\\n            variant_CB_D0,\\r\\n            variant_CB_D1,\\r\\n            variant_CB_D2,\\r\\n            variant_CB_D3,\\r\\n            variant_CB_D4,\\r\\n            variant_CB_D5,\\r\\n            variant_CB_D6,\\r\\n            variant_CB_D7,\\r\\n            variant_CB_D8,\\r\\n            variant_CB_D9,\\r\\n            variant_CB_DA,\\r\\n            variant_CB_DB,\\r\\n            variant_CB_DC,\\r\\n            variant_CB_DD,\\r\\n            variant_CB_DE,\\r\\n            variant_CB_DF,\\r\\n            variant_CB_E0,\\r\\n            variant_CB_E1,\\r\\n            variant_CB_E2,\\r\\n            variant_CB_E3,\\r\\n            variant_CB_E4,\\r\\n            variant_CB_E5,\\r\\n            variant_CB_E6,\\r\\n            variant_CB_E7,\\r\\n            variant_CB_E8,\\r\\n            variant_CB_E9,\\r\\n            variant_CB_EA,\\r\\n            variant_CB_EB,\\r\\n            variant_CB_EC,\\r\\n            variant_CB_ED,\\r\\n            variant_CB_EE,\\r\\n            variant_CB_EF,\\r\\n            variant_CB_F0,\\r\\n            variant_CB_F1,\\r\\n            variant_CB_F2,\\r\\n            variant_CB_F3,\\r\\n            variant_CB_F4,\\r\\n            variant_CB_F5,\\r\\n            variant_CB_F6,\\r\\n            variant_CB_F7,\\r\\n            variant_CB_F8,\\r\\n            variant_CB_F9,\\r\\n            variant_CB_FA,\\r\\n            variant_CB_FB,\\r\\n            variant_CB_FC,\\r\\n            variant_CB_FD,\\r\\n            variant_CB_FE,\\r\\n            variant_CB_FF,\\r\\n            variant_DD_CB_dd_C6,\\r\\n            variant_DD_CB_dd_CE,\\r\\n            variant_DD_CB_dd_D6,\\r\\n            variant_DD_CB_dd_DE,\\r\\n            variant_DD_CB_dd_E6,\\r\\n            variant_DD_CB_dd_EE,\\r\\n            variant_DD_CB_dd_F6,\\r\\n            variant_DD_CB_dd_FE,\\r\\n            variant_FD_CB_dd_C6,\\r\\n            variant_FD_CB_dd_CE,\\r\\n            variant_FD_CB_dd_D6,\\r\\n            variant_FD_CB_dd_DE,\\r\\n            variant_FD_CB_dd_E6,\\r\\n            variant_FD_CB_dd_EE,\\r\\n            variant_FD_CB_dd_F6,\\r\\n            variant_FD_CB_dd_FE, // set 7,(iy+dd)\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"out\\",\\r\\n        [\\r\\n            variant_D3_nn,\\r\\n            variant_ED_41,\\r\\n            variant_ED_49,\\r\\n            variant_ED_51,\\r\\n            variant_ED_59,\\r\\n            variant_ED_61,\\r\\n            variant_ED_69,\\r\\n            variant_ED_71,\\r\\n            variant_ED_79, // out (c),a\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"exx\\",\\r\\n        [\\r\\n            variant_D9, // exx\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"in\\",\\r\\n        [\\r\\n            variant_DB_nn,\\r\\n            variant_DB_nn_pseudo,\\r\\n            variant_ED_40,\\r\\n            variant_ED_48,\\r\\n            variant_ED_50,\\r\\n            variant_ED_58,\\r\\n            variant_ED_60,\\r\\n            variant_ED_68,\\r\\n            variant_ED_70,\\r\\n            variant_ED_78,\\r\\n            variant_ED_78_pseudo, // in (c)\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"neg\\",\\r\\n        [\\r\\n            variant_ED_7C, // neg\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"retn\\",\\r\\n        [\\r\\n            variant_ED_7D, // retn\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"im\\",\\r\\n        [\\r\\n            variant_ED_6E,\\r\\n            variant_ED_76,\\r\\n            variant_ED_7E, // im 2\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"reti\\",\\r\\n        [\\r\\n            variant_ED_4D, // reti\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"rrd\\",\\r\\n        [\\r\\n            variant_ED_67, // rrd\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"rld\\",\\r\\n        [\\r\\n            variant_ED_6F, // rld\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"ldi\\",\\r\\n        [\\r\\n            variant_ED_A0, // ldi\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"cpi\\",\\r\\n        [\\r\\n            variant_ED_A1, // cpi\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"ini\\",\\r\\n        [\\r\\n            variant_ED_A2, // ini\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"outi\\",\\r\\n        [\\r\\n            variant_ED_A3, // outi\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"ldd\\",\\r\\n        [\\r\\n            variant_ED_A8, // ldd\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"cpd\\",\\r\\n        [\\r\\n            variant_ED_A9, // cpd\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"ind\\",\\r\\n        [\\r\\n            variant_ED_AA, // ind\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"outd\\",\\r\\n        [\\r\\n            variant_ED_AB, // outd\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"ldir\\",\\r\\n        [\\r\\n            variant_ED_B0, // ldir\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"cpir\\",\\r\\n        [\\r\\n            variant_ED_B1, // cpir\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"inir\\",\\r\\n        [\\r\\n            variant_ED_B2, // inir\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"otir\\",\\r\\n        [\\r\\n            variant_ED_B3, // otir\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"lddr\\",\\r\\n        [\\r\\n            variant_ED_B8, // lddr\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"cpdr\\",\\r\\n        [\\r\\n            variant_ED_B9, // cpdr\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"indr\\",\\r\\n        [\\r\\n            variant_ED_BA, // indr\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"otdr\\",\\r\\n        [\\r\\n            variant_ED_BB, // otdr\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"di\\",\\r\\n        [\\r\\n            variant_F3, // di\\r\\n        ],\\r\\n    ],\\r\\n    [\\r\\n        \\"ei\\",\\r\\n        [\\r\\n            variant_FB, // ei\\r\\n        ],\\r\\n    ],\\r\\n]);\\r\\n// Map from opcode to variant or sub-map.\\r\\nconst opcodeMap = new Map([\\r\\n    [0x00, variant_00],\\r\\n    [0x01, variant_01_nnnn],\\r\\n    [0x02, variant_02],\\r\\n    [0x03, variant_03],\\r\\n    [0x04, variant_04],\\r\\n    [0x05, variant_05],\\r\\n    [0x06, variant_06_nn],\\r\\n    [0x07, variant_07],\\r\\n    [0x08, variant_08],\\r\\n    [0x09, variant_09],\\r\\n    [0x0A, variant_0A],\\r\\n    [0x0B, variant_0B],\\r\\n    [0x0C, variant_0C],\\r\\n    [0x0D, variant_0D],\\r\\n    [0x0E, variant_0E_nn],\\r\\n    [0x0F, variant_0F],\\r\\n    [0x10, variant_10_offset],\\r\\n    [0x11, variant_11_nnnn],\\r\\n    [0x12, variant_12],\\r\\n    [0x13, variant_13],\\r\\n    [0x14, variant_14],\\r\\n    [0x15, variant_15],\\r\\n    [0x16, variant_16_nn],\\r\\n    [0x17, variant_17],\\r\\n    [0x18, variant_18_offset],\\r\\n    [0x19, variant_19],\\r\\n    [0x1A, variant_1A],\\r\\n    [0x1B, variant_1B],\\r\\n    [0x1C, variant_1C],\\r\\n    [0x1D, variant_1D],\\r\\n    [0x1E, variant_1E_nn],\\r\\n    [0x1F, variant_1F],\\r\\n    [0x20, variant_20_offset],\\r\\n    [0x21, variant_21_nnnn],\\r\\n    [0x22, variant_22_nnnn],\\r\\n    [0x23, variant_23],\\r\\n    [0x24, variant_24],\\r\\n    [0x25, variant_25],\\r\\n    [0x26, variant_26_nn],\\r\\n    [0x27, variant_27],\\r\\n    [0x28, variant_28_offset],\\r\\n    [0x29, variant_29],\\r\\n    [0x2A, variant_2A_nnnn],\\r\\n    [0x2B, variant_2B],\\r\\n    [0x2C, variant_2C],\\r\\n    [0x2D, variant_2D],\\r\\n    [0x2E, variant_2E_nn],\\r\\n    [0x2F, variant_2F],\\r\\n    [0x30, variant_30_offset],\\r\\n    [0x31, variant_31_nnnn],\\r\\n    [0x32, variant_32_nnnn],\\r\\n    [0x33, variant_33],\\r\\n    [0x34, variant_34],\\r\\n    [0x35, variant_35],\\r\\n    [0x36, variant_36_nn],\\r\\n    [0x37, variant_37],\\r\\n    [0x38, variant_38_offset],\\r\\n    [0x39, variant_39],\\r\\n    [0x3A, variant_3A_nnnn],\\r\\n    [0x3B, variant_3B],\\r\\n    [0x3C, variant_3C],\\r\\n    [0x3D, variant_3D],\\r\\n    [0x3E, variant_3E_nn],\\r\\n    [0x3F, variant_3F],\\r\\n    [0x40, variant_40],\\r\\n    [0x41, variant_41],\\r\\n    [0x42, variant_42],\\r\\n    [0x43, variant_43],\\r\\n    [0x44, variant_44],\\r\\n    [0x45, variant_45],\\r\\n    [0x46, variant_46],\\r\\n    [0x47, variant_47],\\r\\n    [0x48, variant_48],\\r\\n    [0x49, variant_49],\\r\\n    [0x4A, variant_4A],\\r\\n    [0x4B, variant_4B],\\r\\n    [0x4C, variant_4C],\\r\\n    [0x4D, variant_4D],\\r\\n    [0x4E, variant_4E],\\r\\n    [0x4F, variant_4F],\\r\\n    [0x50, variant_50],\\r\\n    [0x51, variant_51],\\r\\n    [0x52, variant_52],\\r\\n    [0x53, variant_53],\\r\\n    [0x54, variant_54],\\r\\n    [0x55, variant_55],\\r\\n    [0x56, variant_56],\\r\\n    [0x57, variant_57],\\r\\n    [0x58, variant_58],\\r\\n    [0x59, variant_59],\\r\\n    [0x5A, variant_5A],\\r\\n    [0x5B, variant_5B],\\r\\n    [0x5C, variant_5C],\\r\\n    [0x5D, variant_5D],\\r\\n    [0x5E, variant_5E],\\r\\n    [0x5F, variant_5F],\\r\\n    [0x60, variant_60],\\r\\n    [0x61, variant_61],\\r\\n    [0x62, variant_62],\\r\\n    [0x63, variant_63],\\r\\n    [0x64, variant_64],\\r\\n    [0x65, variant_65],\\r\\n    [0x66, variant_66],\\r\\n    [0x67, variant_67],\\r\\n    [0x68, variant_68],\\r\\n    [0x69, variant_69],\\r\\n    [0x6A, variant_6A],\\r\\n    [0x6B, variant_6B],\\r\\n    [0x6C, variant_6C],\\r\\n    [0x6D, variant_6D],\\r\\n    [0x6E, variant_6E],\\r\\n    [0x6F, variant_6F],\\r\\n    [0x70, variant_70],\\r\\n    [0x71, variant_71],\\r\\n    [0x72, variant_72],\\r\\n    [0x73, variant_73],\\r\\n    [0x74, variant_74],\\r\\n    [0x75, variant_75],\\r\\n    [0x76, variant_76],\\r\\n    [0x77, variant_77],\\r\\n    [0x78, variant_78],\\r\\n    [0x79, variant_79],\\r\\n    [0x7A, variant_7A],\\r\\n    [0x7B, variant_7B],\\r\\n    [0x7C, variant_7C],\\r\\n    [0x7D, variant_7D],\\r\\n    [0x7E, variant_7E],\\r\\n    [0x7F, variant_7F],\\r\\n    [0x80, variant_80],\\r\\n    [0x81, variant_81],\\r\\n    [0x82, variant_82],\\r\\n    [0x83, variant_83],\\r\\n    [0x84, variant_84],\\r\\n    [0x85, variant_85],\\r\\n    [0x86, variant_86],\\r\\n    [0x87, variant_87],\\r\\n    [0x88, variant_88],\\r\\n    [0x89, variant_89],\\r\\n    [0x8A, variant_8A],\\r\\n    [0x8B, variant_8B],\\r\\n    [0x8C, variant_8C],\\r\\n    [0x8D, variant_8D],\\r\\n    [0x8E, variant_8E],\\r\\n    [0x8F, variant_8F],\\r\\n    [0x90, variant_90],\\r\\n    [0x91, variant_91],\\r\\n    [0x92, variant_92],\\r\\n    [0x93, variant_93],\\r\\n    [0x94, variant_94],\\r\\n    [0x95, variant_95],\\r\\n    [0x96, variant_96],\\r\\n    [0x97, variant_97],\\r\\n    [0x98, variant_98],\\r\\n    [0x99, variant_99],\\r\\n    [0x9A, variant_9A],\\r\\n    [0x9B, variant_9B],\\r\\n    [0x9C, variant_9C],\\r\\n    [0x9D, variant_9D],\\r\\n    [0x9E, variant_9E],\\r\\n    [0x9F, variant_9F],\\r\\n    [0xA0, variant_A0],\\r\\n    [0xA1, variant_A1],\\r\\n    [0xA2, variant_A2],\\r\\n    [0xA3, variant_A3],\\r\\n    [0xA4, variant_A4],\\r\\n    [0xA5, variant_A5],\\r\\n    [0xA6, variant_A6],\\r\\n    [0xA7, variant_A7],\\r\\n    [0xA8, variant_A8],\\r\\n    [0xA9, variant_A9],\\r\\n    [0xAA, variant_AA],\\r\\n    [0xAB, variant_AB],\\r\\n    [0xAC, variant_AC],\\r\\n    [0xAD, variant_AD],\\r\\n    [0xAE, variant_AE],\\r\\n    [0xAF, variant_AF],\\r\\n    [0xB0, variant_B0],\\r\\n    [0xB1, variant_B1],\\r\\n    [0xB2, variant_B2],\\r\\n    [0xB3, variant_B3],\\r\\n    [0xB4, variant_B4],\\r\\n    [0xB5, variant_B5],\\r\\n    [0xB6, variant_B6],\\r\\n    [0xB7, variant_B7],\\r\\n    [0xB8, variant_B8],\\r\\n    [0xB9, variant_B9],\\r\\n    [0xBA, variant_BA],\\r\\n    [0xBB, variant_BB],\\r\\n    [0xBC, variant_BC],\\r\\n    [0xBD, variant_BD],\\r\\n    [0xBE, variant_BE],\\r\\n    [0xBF, variant_BF],\\r\\n    [0xC0, variant_C0],\\r\\n    [0xC1, variant_C1],\\r\\n    [0xC2, variant_C2_nnnn],\\r\\n    [0xC3, variant_C3_nnnn],\\r\\n    [0xC4, variant_C4_nnnn],\\r\\n    [0xC5, variant_C5],\\r\\n    [0xC6, variant_C6_nn],\\r\\n    [0xC7, variant_C7],\\r\\n    [0xC8, variant_C8],\\r\\n    [0xC9, variant_C9],\\r\\n    [0xCA, variant_CA_nnnn],\\r\\n    [0xCB, new Map([\\r\\n            [0x00, variant_CB_00],\\r\\n            [0x01, variant_CB_01],\\r\\n            [0x02, variant_CB_02],\\r\\n            [0x03, variant_CB_03],\\r\\n            [0x04, variant_CB_04],\\r\\n            [0x05, variant_CB_05],\\r\\n            [0x06, variant_CB_06],\\r\\n            [0x07, variant_CB_07],\\r\\n            [0x08, variant_CB_08],\\r\\n            [0x09, variant_CB_09],\\r\\n            [0x0A, variant_CB_0A],\\r\\n            [0x0B, variant_CB_0B],\\r\\n            [0x0C, variant_CB_0C],\\r\\n            [0x0D, variant_CB_0D],\\r\\n            [0x0E, variant_CB_0E],\\r\\n            [0x0F, variant_CB_0F],\\r\\n            [0x10, variant_CB_10],\\r\\n            [0x11, variant_CB_11],\\r\\n            [0x12, variant_CB_12],\\r\\n            [0x13, variant_CB_13],\\r\\n            [0x14, variant_CB_14],\\r\\n            [0x15, variant_CB_15],\\r\\n            [0x16, variant_CB_16],\\r\\n            [0x17, variant_CB_17],\\r\\n            [0x18, variant_CB_18],\\r\\n            [0x19, variant_CB_19],\\r\\n            [0x1A, variant_CB_1A],\\r\\n            [0x1B, variant_CB_1B],\\r\\n            [0x1C, variant_CB_1C],\\r\\n            [0x1D, variant_CB_1D],\\r\\n            [0x1E, variant_CB_1E],\\r\\n            [0x1F, variant_CB_1F],\\r\\n            [0x20, variant_CB_20],\\r\\n            [0x21, variant_CB_21],\\r\\n            [0x22, variant_CB_22],\\r\\n            [0x23, variant_CB_23],\\r\\n            [0x24, variant_CB_24],\\r\\n            [0x25, variant_CB_25],\\r\\n            [0x26, variant_CB_26],\\r\\n            [0x27, variant_CB_27],\\r\\n            [0x28, variant_CB_28],\\r\\n            [0x29, variant_CB_29],\\r\\n            [0x2A, variant_CB_2A],\\r\\n            [0x2B, variant_CB_2B],\\r\\n            [0x2C, variant_CB_2C],\\r\\n            [0x2D, variant_CB_2D],\\r\\n            [0x2E, variant_CB_2E],\\r\\n            [0x2F, variant_CB_2F],\\r\\n            [0x30, variant_CB_30],\\r\\n            [0x31, variant_CB_31],\\r\\n            [0x32, variant_CB_32],\\r\\n            [0x33, variant_CB_33],\\r\\n            [0x34, variant_CB_34],\\r\\n            [0x35, variant_CB_35],\\r\\n            [0x36, variant_CB_36],\\r\\n            [0x37, variant_CB_37],\\r\\n            [0x38, variant_CB_38],\\r\\n            [0x39, variant_CB_39],\\r\\n            [0x3A, variant_CB_3A],\\r\\n            [0x3B, variant_CB_3B],\\r\\n            [0x3C, variant_CB_3C],\\r\\n            [0x3D, variant_CB_3D],\\r\\n            [0x3E, variant_CB_3E],\\r\\n            [0x3F, variant_CB_3F],\\r\\n            [0x40, variant_CB_40],\\r\\n            [0x41, variant_CB_41],\\r\\n            [0x42, variant_CB_42],\\r\\n            [0x43, variant_CB_43],\\r\\n            [0x44, variant_CB_44],\\r\\n            [0x45, variant_CB_45],\\r\\n            [0x46, variant_CB_46],\\r\\n            [0x47, variant_CB_47],\\r\\n            [0x48, variant_CB_48],\\r\\n            [0x49, variant_CB_49],\\r\\n            [0x4A, variant_CB_4A],\\r\\n            [0x4B, variant_CB_4B],\\r\\n            [0x4C, variant_CB_4C],\\r\\n            [0x4D, variant_CB_4D],\\r\\n            [0x4E, variant_CB_4E],\\r\\n            [0x4F, variant_CB_4F],\\r\\n            [0x50, variant_CB_50],\\r\\n            [0x51, variant_CB_51],\\r\\n            [0x52, variant_CB_52],\\r\\n            [0x53, variant_CB_53],\\r\\n            [0x54, variant_CB_54],\\r\\n            [0x55, variant_CB_55],\\r\\n            [0x56, variant_CB_56],\\r\\n            [0x57, variant_CB_57],\\r\\n            [0x58, variant_CB_58],\\r\\n            [0x59, variant_CB_59],\\r\\n            [0x5A, variant_CB_5A],\\r\\n            [0x5B, variant_CB_5B],\\r\\n            [0x5C, variant_CB_5C],\\r\\n            [0x5D, variant_CB_5D],\\r\\n            [0x5E, variant_CB_5E],\\r\\n            [0x5F, variant_CB_5F],\\r\\n            [0x60, variant_CB_60],\\r\\n            [0x61, variant_CB_61],\\r\\n            [0x62, variant_CB_62],\\r\\n            [0x63, variant_CB_63],\\r\\n            [0x64, variant_CB_64],\\r\\n            [0x65, variant_CB_65],\\r\\n            [0x66, variant_CB_66],\\r\\n            [0x67, variant_CB_67],\\r\\n            [0x68, variant_CB_68],\\r\\n            [0x69, variant_CB_69],\\r\\n            [0x6A, variant_CB_6A],\\r\\n            [0x6B, variant_CB_6B],\\r\\n            [0x6C, variant_CB_6C],\\r\\n            [0x6D, variant_CB_6D],\\r\\n            [0x6E, variant_CB_6E],\\r\\n            [0x6F, variant_CB_6F],\\r\\n            [0x70, variant_CB_70],\\r\\n            [0x71, variant_CB_71],\\r\\n            [0x72, variant_CB_72],\\r\\n            [0x73, variant_CB_73],\\r\\n            [0x74, variant_CB_74],\\r\\n            [0x75, variant_CB_75],\\r\\n            [0x76, variant_CB_76],\\r\\n            [0x77, variant_CB_77],\\r\\n            [0x78, variant_CB_78],\\r\\n            [0x79, variant_CB_79],\\r\\n            [0x7A, variant_CB_7A],\\r\\n            [0x7B, variant_CB_7B],\\r\\n            [0x7C, variant_CB_7C],\\r\\n            [0x7D, variant_CB_7D],\\r\\n            [0x7E, variant_CB_7E],\\r\\n            [0x7F, variant_CB_7F],\\r\\n            [0x80, variant_CB_80],\\r\\n            [0x81, variant_CB_81],\\r\\n            [0x82, variant_CB_82],\\r\\n            [0x83, variant_CB_83],\\r\\n            [0x84, variant_CB_84],\\r\\n            [0x85, variant_CB_85],\\r\\n            [0x86, variant_CB_86],\\r\\n            [0x87, variant_CB_87],\\r\\n            [0x88, variant_CB_88],\\r\\n            [0x89, variant_CB_89],\\r\\n            [0x8A, variant_CB_8A],\\r\\n            [0x8B, variant_CB_8B],\\r\\n            [0x8C, variant_CB_8C],\\r\\n            [0x8D, variant_CB_8D],\\r\\n            [0x8E, variant_CB_8E],\\r\\n            [0x8F, variant_CB_8F],\\r\\n            [0x90, variant_CB_90],\\r\\n            [0x91, variant_CB_91],\\r\\n            [0x92, variant_CB_92],\\r\\n            [0x93, variant_CB_93],\\r\\n            [0x94, variant_CB_94],\\r\\n            [0x95, variant_CB_95],\\r\\n            [0x96, variant_CB_96],\\r\\n            [0x97, variant_CB_97],\\r\\n            [0x98, variant_CB_98],\\r\\n            [0x99, variant_CB_99],\\r\\n            [0x9A, variant_CB_9A],\\r\\n            [0x9B, variant_CB_9B],\\r\\n            [0x9C, variant_CB_9C],\\r\\n            [0x9D, variant_CB_9D],\\r\\n            [0x9E, variant_CB_9E],\\r\\n            [0x9F, variant_CB_9F],\\r\\n            [0xA0, variant_CB_A0],\\r\\n            [0xA1, variant_CB_A1],\\r\\n            [0xA2, variant_CB_A2],\\r\\n            [0xA3, variant_CB_A3],\\r\\n            [0xA4, variant_CB_A4],\\r\\n            [0xA5, variant_CB_A5],\\r\\n            [0xA6, variant_CB_A6],\\r\\n            [0xA7, variant_CB_A7],\\r\\n            [0xA8, variant_CB_A8],\\r\\n            [0xA9, variant_CB_A9],\\r\\n            [0xAA, variant_CB_AA],\\r\\n            [0xAB, variant_CB_AB],\\r\\n            [0xAC, variant_CB_AC],\\r\\n            [0xAD, variant_CB_AD],\\r\\n            [0xAE, variant_CB_AE],\\r\\n            [0xAF, variant_CB_AF],\\r\\n            [0xB0, variant_CB_B0],\\r\\n            [0xB1, variant_CB_B1],\\r\\n            [0xB2, variant_CB_B2],\\r\\n            [0xB3, variant_CB_B3],\\r\\n            [0xB4, variant_CB_B4],\\r\\n            [0xB5, variant_CB_B5],\\r\\n            [0xB6, variant_CB_B6],\\r\\n            [0xB7, variant_CB_B7],\\r\\n            [0xB8, variant_CB_B8],\\r\\n            [0xB9, variant_CB_B9],\\r\\n            [0xBA, variant_CB_BA],\\r\\n            [0xBB, variant_CB_BB],\\r\\n            [0xBC, variant_CB_BC],\\r\\n            [0xBD, variant_CB_BD],\\r\\n            [0xBE, variant_CB_BE],\\r\\n            [0xBF, variant_CB_BF],\\r\\n            [0xC0, variant_CB_C0],\\r\\n            [0xC1, variant_CB_C1],\\r\\n            [0xC2, variant_CB_C2],\\r\\n            [0xC3, variant_CB_C3],\\r\\n            [0xC4, variant_CB_C4],\\r\\n            [0xC5, variant_CB_C5],\\r\\n            [0xC6, variant_CB_C6],\\r\\n            [0xC7, variant_CB_C7],\\r\\n            [0xC8, variant_CB_C8],\\r\\n            [0xC9, variant_CB_C9],\\r\\n            [0xCA, variant_CB_CA],\\r\\n            [0xCB, variant_CB_CB],\\r\\n            [0xCC, variant_CB_CC],\\r\\n            [0xCD, variant_CB_CD],\\r\\n            [0xCE, variant_CB_CE],\\r\\n            [0xCF, variant_CB_CF],\\r\\n            [0xD0, variant_CB_D0],\\r\\n            [0xD1, variant_CB_D1],\\r\\n            [0xD2, variant_CB_D2],\\r\\n            [0xD3, variant_CB_D3],\\r\\n            [0xD4, variant_CB_D4],\\r\\n            [0xD5, variant_CB_D5],\\r\\n            [0xD6, variant_CB_D6],\\r\\n            [0xD7, variant_CB_D7],\\r\\n            [0xD8, variant_CB_D8],\\r\\n            [0xD9, variant_CB_D9],\\r\\n            [0xDA, variant_CB_DA],\\r\\n            [0xDB, variant_CB_DB],\\r\\n            [0xDC, variant_CB_DC],\\r\\n            [0xDD, variant_CB_DD],\\r\\n            [0xDE, variant_CB_DE],\\r\\n            [0xDF, variant_CB_DF],\\r\\n            [0xE0, variant_CB_E0],\\r\\n            [0xE1, variant_CB_E1],\\r\\n            [0xE2, variant_CB_E2],\\r\\n            [0xE3, variant_CB_E3],\\r\\n            [0xE4, variant_CB_E4],\\r\\n            [0xE5, variant_CB_E5],\\r\\n            [0xE6, variant_CB_E6],\\r\\n            [0xE7, variant_CB_E7],\\r\\n            [0xE8, variant_CB_E8],\\r\\n            [0xE9, variant_CB_E9],\\r\\n            [0xEA, variant_CB_EA],\\r\\n            [0xEB, variant_CB_EB],\\r\\n            [0xEC, variant_CB_EC],\\r\\n            [0xED, variant_CB_ED],\\r\\n            [0xEE, variant_CB_EE],\\r\\n            [0xEF, variant_CB_EF],\\r\\n            [0xF0, variant_CB_F0],\\r\\n            [0xF1, variant_CB_F1],\\r\\n            [0xF2, variant_CB_F2],\\r\\n            [0xF3, variant_CB_F3],\\r\\n            [0xF4, variant_CB_F4],\\r\\n            [0xF5, variant_CB_F5],\\r\\n            [0xF6, variant_CB_F6],\\r\\n            [0xF7, variant_CB_F7],\\r\\n            [0xF8, variant_CB_F8],\\r\\n            [0xF9, variant_CB_F9],\\r\\n            [0xFA, variant_CB_FA],\\r\\n            [0xFB, variant_CB_FB],\\r\\n            [0xFC, variant_CB_FC],\\r\\n            [0xFD, variant_CB_FD],\\r\\n            [0xFE, variant_CB_FE],\\r\\n            [0xFF, variant_CB_FF], // set 7,a\\r\\n        ])],\\r\\n    [0xCC, variant_CC_nnnn],\\r\\n    [0xCD, variant_CD_nnnn],\\r\\n    [0xCE, variant_CE_nn],\\r\\n    [0xCF, variant_CF],\\r\\n    [0xD0, variant_D0],\\r\\n    [0xD1, variant_D1],\\r\\n    [0xD2, variant_D2_nnnn],\\r\\n    [0xD3, variant_D3_nn],\\r\\n    [0xD4, variant_D4_nnnn],\\r\\n    [0xD5, variant_D5],\\r\\n    [0xD6, variant_D6_nn],\\r\\n    [0xD7, variant_D7],\\r\\n    [0xD8, variant_D8],\\r\\n    [0xD9, variant_D9],\\r\\n    [0xDA, variant_DA_nnnn],\\r\\n    [0xDB, variant_DB_nn],\\r\\n    [0xDC, variant_DC_nnnn],\\r\\n    [0xDD, new Map([\\r\\n            [0x09, variant_DD_09],\\r\\n            [0x19, variant_DD_19],\\r\\n            [0x21, variant_DD_21_nnnn],\\r\\n            [0x22, variant_DD_22_nnnn],\\r\\n            [0x23, variant_DD_23],\\r\\n            [0x24, variant_DD_24],\\r\\n            [0x25, variant_DD_25],\\r\\n            [0x26, variant_DD_26_nn],\\r\\n            [0x29, variant_DD_29],\\r\\n            [0x2A, variant_DD_2A_nnnn],\\r\\n            [0x2B, variant_DD_2B],\\r\\n            [0x2C, variant_DD_2C],\\r\\n            [0x2D, variant_DD_2D],\\r\\n            [0x2E, variant_DD_2E_nn],\\r\\n            [0x34, variant_DD_34_dd],\\r\\n            [0x35, variant_DD_35_dd],\\r\\n            [0x36, variant_DD_36_dd_nn],\\r\\n            [0x39, variant_DD_39],\\r\\n            [0x44, variant_DD_44],\\r\\n            [0x45, variant_DD_45],\\r\\n            [0x46, variant_DD_46_dd],\\r\\n            [0x4C, variant_DD_4C],\\r\\n            [0x4D, variant_DD_4D],\\r\\n            [0x4E, variant_DD_4E_dd],\\r\\n            [0x54, variant_DD_54],\\r\\n            [0x55, variant_DD_55],\\r\\n            [0x56, variant_DD_56_dd],\\r\\n            [0x5C, variant_DD_5C],\\r\\n            [0x5D, variant_DD_5D],\\r\\n            [0x5E, variant_DD_5E_dd],\\r\\n            [0x60, variant_DD_60],\\r\\n            [0x61, variant_DD_61],\\r\\n            [0x62, variant_DD_62],\\r\\n            [0x63, variant_DD_63],\\r\\n            [0x64, variant_DD_64],\\r\\n            [0x65, variant_DD_65],\\r\\n            [0x66, variant_DD_66_dd],\\r\\n            [0x67, variant_DD_67],\\r\\n            [0x68, variant_DD_68],\\r\\n            [0x69, variant_DD_69],\\r\\n            [0x6A, variant_DD_6A],\\r\\n            [0x6B, variant_DD_6B],\\r\\n            [0x6C, variant_DD_6C],\\r\\n            [0x6D, variant_DD_6D],\\r\\n            [0x6E, variant_DD_6E_dd],\\r\\n            [0x6F, variant_DD_6F],\\r\\n            [0x70, variant_DD_70_dd],\\r\\n            [0x71, variant_DD_71_dd],\\r\\n            [0x72, variant_DD_72_dd],\\r\\n            [0x73, variant_DD_73_dd],\\r\\n            [0x74, variant_DD_74_dd],\\r\\n            [0x75, variant_DD_75_dd],\\r\\n            [0x77, variant_DD_77_dd],\\r\\n            [0x7C, variant_DD_7C],\\r\\n            [0x7D, variant_DD_7D],\\r\\n            [0x7E, variant_DD_7E_dd],\\r\\n            [0x84, variant_DD_84],\\r\\n            [0x85, variant_DD_85],\\r\\n            [0x86, variant_DD_86_dd],\\r\\n            [0x8C, variant_DD_8C],\\r\\n            [0x8D, variant_DD_8D],\\r\\n            [0x8E, variant_DD_8E_dd],\\r\\n            [0x94, variant_DD_94],\\r\\n            [0x95, variant_DD_95],\\r\\n            [0x96, variant_DD_96_dd],\\r\\n            [0x9C, variant_DD_9C],\\r\\n            [0x9D, variant_DD_9D],\\r\\n            [0x9E, variant_DD_9E_dd],\\r\\n            [0xA4, variant_DD_A4],\\r\\n            [0xA5, variant_DD_A5],\\r\\n            [0xA6, variant_DD_A6_dd],\\r\\n            [0xAC, variant_DD_AC],\\r\\n            [0xAD, variant_DD_AD],\\r\\n            [0xAE, variant_DD_AE_dd],\\r\\n            [0xB4, variant_DD_B4],\\r\\n            [0xB5, variant_DD_B5],\\r\\n            [0xB6, variant_DD_B6_dd],\\r\\n            [0xBC, variant_DD_BC],\\r\\n            [0xBD, variant_DD_BD],\\r\\n            [0xBE, variant_DD_BE_dd],\\r\\n            [0xCB, new Map([\\r\\n                    [0x00, variant_DD_CB_dd_00],\\r\\n                    [0x01, variant_DD_CB_dd_01],\\r\\n                    [0x02, variant_DD_CB_dd_02],\\r\\n                    [0x03, variant_DD_CB_dd_03],\\r\\n                    [0x04, variant_DD_CB_dd_04],\\r\\n                    [0x05, variant_DD_CB_dd_05],\\r\\n                    [0x06, variant_DD_CB_dd_06],\\r\\n                    [0x07, variant_DD_CB_dd_07],\\r\\n                    [0x08, variant_DD_CB_dd_08],\\r\\n                    [0x09, variant_DD_CB_dd_09],\\r\\n                    [0x0A, variant_DD_CB_dd_0A],\\r\\n                    [0x0B, variant_DD_CB_dd_0B],\\r\\n                    [0x0C, variant_DD_CB_dd_0C],\\r\\n                    [0x0D, variant_DD_CB_dd_0D],\\r\\n                    [0x0E, variant_DD_CB_dd_0E],\\r\\n                    [0x0F, variant_DD_CB_dd_0F],\\r\\n                    [0x10, variant_DD_CB_dd_10],\\r\\n                    [0x11, variant_DD_CB_dd_11],\\r\\n                    [0x12, variant_DD_CB_dd_12],\\r\\n                    [0x13, variant_DD_CB_dd_13],\\r\\n                    [0x14, variant_DD_CB_dd_14],\\r\\n                    [0x15, variant_DD_CB_dd_15],\\r\\n                    [0x16, variant_DD_CB_dd_16],\\r\\n                    [0x17, variant_DD_CB_dd_17],\\r\\n                    [0x18, variant_DD_CB_dd_18],\\r\\n                    [0x19, variant_DD_CB_dd_19],\\r\\n                    [0x1A, variant_DD_CB_dd_1A],\\r\\n                    [0x1B, variant_DD_CB_dd_1B],\\r\\n                    [0x1C, variant_DD_CB_dd_1C],\\r\\n                    [0x1D, variant_DD_CB_dd_1D],\\r\\n                    [0x1E, variant_DD_CB_dd_1E],\\r\\n                    [0x1F, variant_DD_CB_dd_1F],\\r\\n                    [0x20, variant_DD_CB_dd_20],\\r\\n                    [0x21, variant_DD_CB_dd_21],\\r\\n                    [0x22, variant_DD_CB_dd_22],\\r\\n                    [0x23, variant_DD_CB_dd_23],\\r\\n                    [0x24, variant_DD_CB_dd_24],\\r\\n                    [0x25, variant_DD_CB_dd_25],\\r\\n                    [0x26, variant_DD_CB_dd_26],\\r\\n                    [0x27, variant_DD_CB_dd_27],\\r\\n                    [0x28, variant_DD_CB_dd_28],\\r\\n                    [0x29, variant_DD_CB_dd_29],\\r\\n                    [0x2A, variant_DD_CB_dd_2A],\\r\\n                    [0x2B, variant_DD_CB_dd_2B],\\r\\n                    [0x2C, variant_DD_CB_dd_2C],\\r\\n                    [0x2D, variant_DD_CB_dd_2D],\\r\\n                    [0x2E, variant_DD_CB_dd_2E],\\r\\n                    [0x2F, variant_DD_CB_dd_2F],\\r\\n                    [0x30, variant_DD_CB_dd_30],\\r\\n                    [0x31, variant_DD_CB_dd_31],\\r\\n                    [0x32, variant_DD_CB_dd_32],\\r\\n                    [0x33, variant_DD_CB_dd_33],\\r\\n                    [0x34, variant_DD_CB_dd_34],\\r\\n                    [0x35, variant_DD_CB_dd_35],\\r\\n                    [0x36, variant_DD_CB_dd_36],\\r\\n                    [0x37, variant_DD_CB_dd_37],\\r\\n                    [0x38, variant_DD_CB_dd_38],\\r\\n                    [0x39, variant_DD_CB_dd_39],\\r\\n                    [0x3A, variant_DD_CB_dd_3A],\\r\\n                    [0x3B, variant_DD_CB_dd_3B],\\r\\n                    [0x3C, variant_DD_CB_dd_3C],\\r\\n                    [0x3D, variant_DD_CB_dd_3D],\\r\\n                    [0x3E, variant_DD_CB_dd_3E],\\r\\n                    [0x3F, variant_DD_CB_dd_3F],\\r\\n                    [0x40, variant_DD_CB_dd_40],\\r\\n                    [0x41, variant_DD_CB_dd_41],\\r\\n                    [0x42, variant_DD_CB_dd_42],\\r\\n                    [0x43, variant_DD_CB_dd_43],\\r\\n                    [0x44, variant_DD_CB_dd_44],\\r\\n                    [0x45, variant_DD_CB_dd_45],\\r\\n                    [0x46, variant_DD_CB_dd_46],\\r\\n                    [0x47, variant_DD_CB_dd_47],\\r\\n                    [0x48, variant_DD_CB_dd_48],\\r\\n                    [0x49, variant_DD_CB_dd_49],\\r\\n                    [0x4A, variant_DD_CB_dd_4A],\\r\\n                    [0x4B, variant_DD_CB_dd_4B],\\r\\n                    [0x4C, variant_DD_CB_dd_4C],\\r\\n                    [0x4D, variant_DD_CB_dd_4D],\\r\\n                    [0x4E, variant_DD_CB_dd_4E],\\r\\n                    [0x4F, variant_DD_CB_dd_4F],\\r\\n                    [0x50, variant_DD_CB_dd_50],\\r\\n                    [0x51, variant_DD_CB_dd_51],\\r\\n                    [0x52, variant_DD_CB_dd_52],\\r\\n                    [0x53, variant_DD_CB_dd_53],\\r\\n                    [0x54, variant_DD_CB_dd_54],\\r\\n                    [0x55, variant_DD_CB_dd_55],\\r\\n                    [0x56, variant_DD_CB_dd_56],\\r\\n                    [0x57, variant_DD_CB_dd_57],\\r\\n                    [0x58, variant_DD_CB_dd_58],\\r\\n                    [0x59, variant_DD_CB_dd_59],\\r\\n                    [0x5A, variant_DD_CB_dd_5A],\\r\\n                    [0x5B, variant_DD_CB_dd_5B],\\r\\n                    [0x5C, variant_DD_CB_dd_5C],\\r\\n                    [0x5D, variant_DD_CB_dd_5D],\\r\\n                    [0x5E, variant_DD_CB_dd_5E],\\r\\n                    [0x5F, variant_DD_CB_dd_5F],\\r\\n                    [0x60, variant_DD_CB_dd_60],\\r\\n                    [0x61, variant_DD_CB_dd_61],\\r\\n                    [0x62, variant_DD_CB_dd_62],\\r\\n                    [0x63, variant_DD_CB_dd_63],\\r\\n                    [0x64, variant_DD_CB_dd_64],\\r\\n                    [0x65, variant_DD_CB_dd_65],\\r\\n                    [0x66, variant_DD_CB_dd_66],\\r\\n                    [0x67, variant_DD_CB_dd_67],\\r\\n                    [0x68, variant_DD_CB_dd_68],\\r\\n                    [0x69, variant_DD_CB_dd_69],\\r\\n                    [0x6A, variant_DD_CB_dd_6A],\\r\\n                    [0x6B, variant_DD_CB_dd_6B],\\r\\n                    [0x6C, variant_DD_CB_dd_6C],\\r\\n                    [0x6D, variant_DD_CB_dd_6D],\\r\\n                    [0x6E, variant_DD_CB_dd_6E],\\r\\n                    [0x6F, variant_DD_CB_dd_6F],\\r\\n                    [0x70, variant_DD_CB_dd_70],\\r\\n                    [0x71, variant_DD_CB_dd_71],\\r\\n                    [0x72, variant_DD_CB_dd_72],\\r\\n                    [0x73, variant_DD_CB_dd_73],\\r\\n                    [0x74, variant_DD_CB_dd_74],\\r\\n                    [0x75, variant_DD_CB_dd_75],\\r\\n                    [0x76, variant_DD_CB_dd_76],\\r\\n                    [0x77, variant_DD_CB_dd_77],\\r\\n                    [0x78, variant_DD_CB_dd_78],\\r\\n                    [0x79, variant_DD_CB_dd_79],\\r\\n                    [0x7A, variant_DD_CB_dd_7A],\\r\\n                    [0x7B, variant_DD_CB_dd_7B],\\r\\n                    [0x7C, variant_DD_CB_dd_7C],\\r\\n                    [0x7D, variant_DD_CB_dd_7D],\\r\\n                    [0x7E, variant_DD_CB_dd_7E],\\r\\n                    [0x7F, variant_DD_CB_dd_7F],\\r\\n                    [0x80, variant_DD_CB_dd_80],\\r\\n                    [0x81, variant_DD_CB_dd_81],\\r\\n                    [0x82, variant_DD_CB_dd_82],\\r\\n                    [0x83, variant_DD_CB_dd_83],\\r\\n                    [0x84, variant_DD_CB_dd_84],\\r\\n                    [0x85, variant_DD_CB_dd_85],\\r\\n                    [0x86, variant_DD_CB_dd_86],\\r\\n                    [0x87, variant_DD_CB_dd_87],\\r\\n                    [0x88, variant_DD_CB_dd_88],\\r\\n                    [0x89, variant_DD_CB_dd_89],\\r\\n                    [0x8A, variant_DD_CB_dd_8A],\\r\\n                    [0x8B, variant_DD_CB_dd_8B],\\r\\n                    [0x8C, variant_DD_CB_dd_8C],\\r\\n                    [0x8D, variant_DD_CB_dd_8D],\\r\\n                    [0x8E, variant_DD_CB_dd_8E],\\r\\n                    [0x8F, variant_DD_CB_dd_8F],\\r\\n                    [0x90, variant_DD_CB_dd_90],\\r\\n                    [0x91, variant_DD_CB_dd_91],\\r\\n                    [0x92, variant_DD_CB_dd_92],\\r\\n                    [0x93, variant_DD_CB_dd_93],\\r\\n                    [0x94, variant_DD_CB_dd_94],\\r\\n                    [0x95, variant_DD_CB_dd_95],\\r\\n                    [0x96, variant_DD_CB_dd_96],\\r\\n                    [0x97, variant_DD_CB_dd_97],\\r\\n                    [0x98, variant_DD_CB_dd_98],\\r\\n                    [0x99, variant_DD_CB_dd_99],\\r\\n                    [0x9A, variant_DD_CB_dd_9A],\\r\\n                    [0x9B, variant_DD_CB_dd_9B],\\r\\n                    [0x9C, variant_DD_CB_dd_9C],\\r\\n                    [0x9D, variant_DD_CB_dd_9D],\\r\\n                    [0x9E, variant_DD_CB_dd_9E],\\r\\n                    [0x9F, variant_DD_CB_dd_9F],\\r\\n                    [0xA0, variant_DD_CB_dd_A0],\\r\\n                    [0xA1, variant_DD_CB_dd_A1],\\r\\n                    [0xA2, variant_DD_CB_dd_A2],\\r\\n                    [0xA3, variant_DD_CB_dd_A3],\\r\\n                    [0xA4, variant_DD_CB_dd_A4],\\r\\n                    [0xA5, variant_DD_CB_dd_A5],\\r\\n                    [0xA6, variant_DD_CB_dd_A6],\\r\\n                    [0xA7, variant_DD_CB_dd_A7],\\r\\n                    [0xA8, variant_DD_CB_dd_A8],\\r\\n                    [0xA9, variant_DD_CB_dd_A9],\\r\\n                    [0xAA, variant_DD_CB_dd_AA],\\r\\n                    [0xAB, variant_DD_CB_dd_AB],\\r\\n                    [0xAC, variant_DD_CB_dd_AC],\\r\\n                    [0xAD, variant_DD_CB_dd_AD],\\r\\n                    [0xAE, variant_DD_CB_dd_AE],\\r\\n                    [0xAF, variant_DD_CB_dd_AF],\\r\\n                    [0xB0, variant_DD_CB_dd_B0],\\r\\n                    [0xB1, variant_DD_CB_dd_B1],\\r\\n                    [0xB2, variant_DD_CB_dd_B2],\\r\\n                    [0xB3, variant_DD_CB_dd_B3],\\r\\n                    [0xB4, variant_DD_CB_dd_B4],\\r\\n                    [0xB5, variant_DD_CB_dd_B5],\\r\\n                    [0xB6, variant_DD_CB_dd_B6],\\r\\n                    [0xB7, variant_DD_CB_dd_B7],\\r\\n                    [0xB8, variant_DD_CB_dd_B8],\\r\\n                    [0xB9, variant_DD_CB_dd_B9],\\r\\n                    [0xBA, variant_DD_CB_dd_BA],\\r\\n                    [0xBB, variant_DD_CB_dd_BB],\\r\\n                    [0xBC, variant_DD_CB_dd_BC],\\r\\n                    [0xBD, variant_DD_CB_dd_BD],\\r\\n                    [0xBE, variant_DD_CB_dd_BE],\\r\\n                    [0xBF, variant_DD_CB_dd_BF],\\r\\n                    [0xC0, variant_DD_CB_dd_C0],\\r\\n                    [0xC1, variant_DD_CB_dd_C1],\\r\\n                    [0xC2, variant_DD_CB_dd_C2],\\r\\n                    [0xC3, variant_DD_CB_dd_C3],\\r\\n                    [0xC4, variant_DD_CB_dd_C4],\\r\\n                    [0xC5, variant_DD_CB_dd_C5],\\r\\n                    [0xC6, variant_DD_CB_dd_C6],\\r\\n                    [0xC7, variant_DD_CB_dd_C7],\\r\\n                    [0xC8, variant_DD_CB_dd_C8],\\r\\n                    [0xC9, variant_DD_CB_dd_C9],\\r\\n                    [0xCA, variant_DD_CB_dd_CA],\\r\\n                    [0xCB, variant_DD_CB_dd_CB],\\r\\n                    [0xCC, variant_DD_CB_dd_CC],\\r\\n                    [0xCD, variant_DD_CB_dd_CD],\\r\\n                    [0xCE, variant_DD_CB_dd_CE],\\r\\n                    [0xCF, variant_DD_CB_dd_CF],\\r\\n                    [0xD0, variant_DD_CB_dd_D0],\\r\\n                    [0xD1, variant_DD_CB_dd_D1],\\r\\n                    [0xD2, variant_DD_CB_dd_D2],\\r\\n                    [0xD3, variant_DD_CB_dd_D3],\\r\\n                    [0xD4, variant_DD_CB_dd_D4],\\r\\n                    [0xD5, variant_DD_CB_dd_D5],\\r\\n                    [0xD6, variant_DD_CB_dd_D6],\\r\\n                    [0xD7, variant_DD_CB_dd_D7],\\r\\n                    [0xD8, variant_DD_CB_dd_D8],\\r\\n                    [0xD9, variant_DD_CB_dd_D9],\\r\\n                    [0xDA, variant_DD_CB_dd_DA],\\r\\n                    [0xDB, variant_DD_CB_dd_DB],\\r\\n                    [0xDC, variant_DD_CB_dd_DC],\\r\\n                    [0xDD, variant_DD_CB_dd_DD],\\r\\n                    [0xDE, variant_DD_CB_dd_DE],\\r\\n                    [0xDF, variant_DD_CB_dd_DF],\\r\\n                    [0xE0, variant_DD_CB_dd_E0],\\r\\n                    [0xE1, variant_DD_CB_dd_E1],\\r\\n                    [0xE2, variant_DD_CB_dd_E2],\\r\\n                    [0xE3, variant_DD_CB_dd_E3],\\r\\n                    [0xE4, variant_DD_CB_dd_E4],\\r\\n                    [0xE5, variant_DD_CB_dd_E5],\\r\\n                    [0xE6, variant_DD_CB_dd_E6],\\r\\n                    [0xE7, variant_DD_CB_dd_E7],\\r\\n                    [0xE8, variant_DD_CB_dd_E8],\\r\\n                    [0xE9, variant_DD_CB_dd_E9],\\r\\n                    [0xEA, variant_DD_CB_dd_EA],\\r\\n                    [0xEB, variant_DD_CB_dd_EB],\\r\\n                    [0xEC, variant_DD_CB_dd_EC],\\r\\n                    [0xED, variant_DD_CB_dd_ED],\\r\\n                    [0xEE, variant_DD_CB_dd_EE],\\r\\n                    [0xEF, variant_DD_CB_dd_EF],\\r\\n                    [0xF0, variant_DD_CB_dd_F0],\\r\\n                    [0xF1, variant_DD_CB_dd_F1],\\r\\n                    [0xF2, variant_DD_CB_dd_F2],\\r\\n                    [0xF3, variant_DD_CB_dd_F3],\\r\\n                    [0xF4, variant_DD_CB_dd_F4],\\r\\n                    [0xF5, variant_DD_CB_dd_F5],\\r\\n                    [0xF6, variant_DD_CB_dd_F6],\\r\\n                    [0xF7, variant_DD_CB_dd_F7],\\r\\n                    [0xF8, variant_DD_CB_dd_F8],\\r\\n                    [0xF9, variant_DD_CB_dd_F9],\\r\\n                    [0xFA, variant_DD_CB_dd_FA],\\r\\n                    [0xFB, variant_DD_CB_dd_FB],\\r\\n                    [0xFC, variant_DD_CB_dd_FC],\\r\\n                    [0xFD, variant_DD_CB_dd_FD],\\r\\n                    [0xFE, variant_DD_CB_dd_FE],\\r\\n                    [0xFF, variant_DD_CB_dd_FF], // ld a,set 7,(ix+dd)\\r\\n                ])],\\r\\n            [0xE1, variant_DD_E1],\\r\\n            [0xE3, variant_DD_E3],\\r\\n            [0xE5, variant_DD_E5],\\r\\n            [0xE9, variant_DD_E9],\\r\\n            [0xF9, variant_DD_F9], // ld sp,ix\\r\\n        ])],\\r\\n    [0xDE, variant_DE_nn],\\r\\n    [0xDF, variant_DF],\\r\\n    [0xE0, variant_E0],\\r\\n    [0xE1, variant_E1],\\r\\n    [0xE2, variant_E2_nnnn],\\r\\n    [0xE3, variant_E3],\\r\\n    [0xE4, variant_E4_nnnn],\\r\\n    [0xE5, variant_E5],\\r\\n    [0xE6, variant_E6_nn],\\r\\n    [0xE7, variant_E7],\\r\\n    [0xE8, variant_E8],\\r\\n    [0xE9, variant_E9],\\r\\n    [0xEA, variant_EA_nnnn],\\r\\n    [0xEB, variant_EB],\\r\\n    [0xEC, variant_EC_nnnn],\\r\\n    [0xED, new Map([\\r\\n            [0x40, variant_ED_40],\\r\\n            [0x41, variant_ED_41],\\r\\n            [0x42, variant_ED_42],\\r\\n            [0x43, variant_ED_43_nnnn],\\r\\n            [0x44, variant_ED_44],\\r\\n            [0x45, variant_ED_45],\\r\\n            [0x46, variant_ED_46],\\r\\n            [0x47, variant_ED_47],\\r\\n            [0x48, variant_ED_48],\\r\\n            [0x49, variant_ED_49],\\r\\n            [0x4A, variant_ED_4A],\\r\\n            [0x4B, variant_ED_4B_nnnn],\\r\\n            [0x4C, variant_ED_4C],\\r\\n            [0x4D, variant_ED_4D],\\r\\n            [0x4E, variant_ED_4E],\\r\\n            [0x4F, variant_ED_4F],\\r\\n            [0x50, variant_ED_50],\\r\\n            [0x51, variant_ED_51],\\r\\n            [0x52, variant_ED_52],\\r\\n            [0x53, variant_ED_53_nnnn],\\r\\n            [0x54, variant_ED_54],\\r\\n            [0x55, variant_ED_55],\\r\\n            [0x56, variant_ED_56],\\r\\n            [0x57, variant_ED_57],\\r\\n            [0x58, variant_ED_58],\\r\\n            [0x59, variant_ED_59],\\r\\n            [0x5A, variant_ED_5A],\\r\\n            [0x5B, variant_ED_5B_nnnn],\\r\\n            [0x5C, variant_ED_5C],\\r\\n            [0x5D, variant_ED_5D],\\r\\n            [0x5E, variant_ED_5E],\\r\\n            [0x5F, variant_ED_5F],\\r\\n            [0x60, variant_ED_60],\\r\\n            [0x61, variant_ED_61],\\r\\n            [0x62, variant_ED_62],\\r\\n            [0x63, variant_ED_63_nnnn],\\r\\n            [0x64, variant_ED_64],\\r\\n            [0x65, variant_ED_65],\\r\\n            [0x66, variant_ED_66],\\r\\n            [0x67, variant_ED_67],\\r\\n            [0x68, variant_ED_68],\\r\\n            [0x69, variant_ED_69],\\r\\n            [0x6A, variant_ED_6A],\\r\\n            [0x6B, variant_ED_6B_nnnn],\\r\\n            [0x6C, variant_ED_6C],\\r\\n            [0x6D, variant_ED_6D],\\r\\n            [0x6E, variant_ED_6E],\\r\\n            [0x6F, variant_ED_6F],\\r\\n            [0x70, variant_ED_70],\\r\\n            [0x71, variant_ED_71],\\r\\n            [0x72, variant_ED_72],\\r\\n            [0x73, variant_ED_73_nnnn],\\r\\n            [0x74, variant_ED_74],\\r\\n            [0x75, variant_ED_75],\\r\\n            [0x76, variant_ED_76],\\r\\n            [0x78, variant_ED_78],\\r\\n            [0x79, variant_ED_79],\\r\\n            [0x7A, variant_ED_7A],\\r\\n            [0x7B, variant_ED_7B_nnnn],\\r\\n            [0x7C, variant_ED_7C],\\r\\n            [0x7D, variant_ED_7D],\\r\\n            [0x7E, variant_ED_7E],\\r\\n            [0xA0, variant_ED_A0],\\r\\n            [0xA1, variant_ED_A1],\\r\\n            [0xA2, variant_ED_A2],\\r\\n            [0xA3, variant_ED_A3],\\r\\n            [0xA8, variant_ED_A8],\\r\\n            [0xA9, variant_ED_A9],\\r\\n            [0xAA, variant_ED_AA],\\r\\n            [0xAB, variant_ED_AB],\\r\\n            [0xB0, variant_ED_B0],\\r\\n            [0xB1, variant_ED_B1],\\r\\n            [0xB2, variant_ED_B2],\\r\\n            [0xB3, variant_ED_B3],\\r\\n            [0xB8, variant_ED_B8],\\r\\n            [0xB9, variant_ED_B9],\\r\\n            [0xBA, variant_ED_BA],\\r\\n            [0xBB, variant_ED_BB], // otdr\\r\\n        ])],\\r\\n    [0xEE, variant_EE_nn],\\r\\n    [0xEF, variant_EF],\\r\\n    [0xF0, variant_F0],\\r\\n    [0xF1, variant_F1],\\r\\n    [0xF2, variant_F2_nnnn],\\r\\n    [0xF3, variant_F3],\\r\\n    [0xF4, variant_F4_nnnn],\\r\\n    [0xF5, variant_F5],\\r\\n    [0xF6, variant_F6_nn],\\r\\n    [0xF7, variant_F7],\\r\\n    [0xF8, variant_F8],\\r\\n    [0xF9, variant_F9],\\r\\n    [0xFA, variant_FA_nnnn],\\r\\n    [0xFB, variant_FB],\\r\\n    [0xFC, variant_FC_nnnn],\\r\\n    [0xFD, new Map([\\r\\n            [0x09, variant_FD_09],\\r\\n            [0x19, variant_FD_19],\\r\\n            [0x21, variant_FD_21_nnnn],\\r\\n            [0x22, variant_FD_22_nnnn],\\r\\n            [0x23, variant_FD_23],\\r\\n            [0x24, variant_FD_24],\\r\\n            [0x25, variant_FD_25],\\r\\n            [0x26, variant_FD_26_nn],\\r\\n            [0x29, variant_FD_29],\\r\\n            [0x2A, variant_FD_2A_nnnn],\\r\\n            [0x2B, variant_FD_2B],\\r\\n            [0x2C, variant_FD_2C],\\r\\n            [0x2D, variant_FD_2D],\\r\\n            [0x2E, variant_FD_2E_nn],\\r\\n            [0x34, variant_FD_34_dd],\\r\\n            [0x35, variant_FD_35_dd],\\r\\n            [0x36, variant_FD_36_dd_nn],\\r\\n            [0x39, variant_FD_39],\\r\\n            [0x44, variant_FD_44],\\r\\n            [0x45, variant_FD_45],\\r\\n            [0x46, variant_FD_46_dd],\\r\\n            [0x4C, variant_FD_4C],\\r\\n            [0x4D, variant_FD_4D],\\r\\n            [0x4E, variant_FD_4E_dd],\\r\\n            [0x54, variant_FD_54],\\r\\n            [0x55, variant_FD_55],\\r\\n            [0x56, variant_FD_56_dd],\\r\\n            [0x5C, variant_FD_5C],\\r\\n            [0x5D, variant_FD_5D],\\r\\n            [0x5E, variant_FD_5E_dd],\\r\\n            [0x60, variant_FD_60],\\r\\n            [0x61, variant_FD_61],\\r\\n            [0x62, variant_FD_62],\\r\\n            [0x63, variant_FD_63],\\r\\n            [0x64, variant_FD_64],\\r\\n            [0x65, variant_FD_65],\\r\\n            [0x66, variant_FD_66_dd],\\r\\n            [0x67, variant_FD_67],\\r\\n            [0x68, variant_FD_68],\\r\\n            [0x69, variant_FD_69],\\r\\n            [0x6A, variant_FD_6A],\\r\\n            [0x6B, variant_FD_6B],\\r\\n            [0x6C, variant_FD_6C],\\r\\n            [0x6D, variant_FD_6D],\\r\\n            [0x6E, variant_FD_6E_dd],\\r\\n            [0x6F, variant_FD_6F],\\r\\n            [0x70, variant_FD_70_dd],\\r\\n            [0x71, variant_FD_71_dd],\\r\\n            [0x72, variant_FD_72_dd],\\r\\n            [0x73, variant_FD_73_dd],\\r\\n            [0x74, variant_FD_74_dd],\\r\\n            [0x75, variant_FD_75_dd],\\r\\n            [0x77, variant_FD_77_dd],\\r\\n            [0x7C, variant_FD_7C],\\r\\n            [0x7D, variant_FD_7D],\\r\\n            [0x7E, variant_FD_7E_dd],\\r\\n            [0x84, variant_FD_84],\\r\\n            [0x85, variant_FD_85],\\r\\n            [0x86, variant_FD_86_dd],\\r\\n            [0x8C, variant_FD_8C],\\r\\n            [0x8D, variant_FD_8D],\\r\\n            [0x8E, variant_FD_8E_dd],\\r\\n            [0x94, variant_FD_94],\\r\\n            [0x95, variant_FD_95],\\r\\n            [0x96, variant_FD_96_dd],\\r\\n            [0x9C, variant_FD_9C],\\r\\n            [0x9D, variant_FD_9D],\\r\\n            [0x9E, variant_FD_9E_dd],\\r\\n            [0xA4, variant_FD_A4],\\r\\n            [0xA5, variant_FD_A5],\\r\\n            [0xA6, variant_FD_A6_dd],\\r\\n            [0xAC, variant_FD_AC],\\r\\n            [0xAD, variant_FD_AD],\\r\\n            [0xAE, variant_FD_AE_dd],\\r\\n            [0xB4, variant_FD_B4],\\r\\n            [0xB5, variant_FD_B5],\\r\\n            [0xB6, variant_FD_B6_dd],\\r\\n            [0xBC, variant_FD_BC],\\r\\n            [0xBD, variant_FD_BD],\\r\\n            [0xBE, variant_FD_BE_dd],\\r\\n            [0xCB, new Map([\\r\\n                    [0x00, variant_FD_CB_dd_00],\\r\\n                    [0x01, variant_FD_CB_dd_01],\\r\\n                    [0x02, variant_FD_CB_dd_02],\\r\\n                    [0x03, variant_FD_CB_dd_03],\\r\\n                    [0x04, variant_FD_CB_dd_04],\\r\\n                    [0x05, variant_FD_CB_dd_05],\\r\\n                    [0x06, variant_FD_CB_dd_06],\\r\\n                    [0x07, variant_FD_CB_dd_07],\\r\\n                    [0x08, variant_FD_CB_dd_08],\\r\\n                    [0x09, variant_FD_CB_dd_09],\\r\\n                    [0x0A, variant_FD_CB_dd_0A],\\r\\n                    [0x0B, variant_FD_CB_dd_0B],\\r\\n                    [0x0C, variant_FD_CB_dd_0C],\\r\\n                    [0x0D, variant_FD_CB_dd_0D],\\r\\n                    [0x0E, variant_FD_CB_dd_0E],\\r\\n                    [0x0F, variant_FD_CB_dd_0F],\\r\\n                    [0x10, variant_FD_CB_dd_10],\\r\\n                    [0x11, variant_FD_CB_dd_11],\\r\\n                    [0x12, variant_FD_CB_dd_12],\\r\\n                    [0x13, variant_FD_CB_dd_13],\\r\\n                    [0x14, variant_FD_CB_dd_14],\\r\\n                    [0x15, variant_FD_CB_dd_15],\\r\\n                    [0x16, variant_FD_CB_dd_16],\\r\\n                    [0x17, variant_FD_CB_dd_17],\\r\\n                    [0x18, variant_FD_CB_dd_18],\\r\\n                    [0x19, variant_FD_CB_dd_19],\\r\\n                    [0x1A, variant_FD_CB_dd_1A],\\r\\n                    [0x1B, variant_FD_CB_dd_1B],\\r\\n                    [0x1C, variant_FD_CB_dd_1C],\\r\\n                    [0x1D, variant_FD_CB_dd_1D],\\r\\n                    [0x1E, variant_FD_CB_dd_1E],\\r\\n                    [0x1F, variant_FD_CB_dd_1F],\\r\\n                    [0x20, variant_FD_CB_dd_20],\\r\\n                    [0x21, variant_FD_CB_dd_21],\\r\\n                    [0x22, variant_FD_CB_dd_22],\\r\\n                    [0x23, variant_FD_CB_dd_23],\\r\\n                    [0x24, variant_FD_CB_dd_24],\\r\\n                    [0x25, variant_FD_CB_dd_25],\\r\\n                    [0x26, variant_FD_CB_dd_26],\\r\\n                    [0x27, variant_FD_CB_dd_27],\\r\\n                    [0x28, variant_FD_CB_dd_28],\\r\\n                    [0x29, variant_FD_CB_dd_29],\\r\\n                    [0x2A, variant_FD_CB_dd_2A],\\r\\n                    [0x2B, variant_FD_CB_dd_2B],\\r\\n                    [0x2C, variant_FD_CB_dd_2C],\\r\\n                    [0x2D, variant_FD_CB_dd_2D],\\r\\n                    [0x2E, variant_FD_CB_dd_2E],\\r\\n                    [0x2F, variant_FD_CB_dd_2F],\\r\\n                    [0x30, variant_FD_CB_dd_30],\\r\\n                    [0x31, variant_FD_CB_dd_31],\\r\\n                    [0x32, variant_FD_CB_dd_32],\\r\\n                    [0x33, variant_FD_CB_dd_33],\\r\\n                    [0x34, variant_FD_CB_dd_34],\\r\\n                    [0x35, variant_FD_CB_dd_35],\\r\\n                    [0x36, variant_FD_CB_dd_36],\\r\\n                    [0x37, variant_FD_CB_dd_37],\\r\\n                    [0x38, variant_FD_CB_dd_38],\\r\\n                    [0x39, variant_FD_CB_dd_39],\\r\\n                    [0x3A, variant_FD_CB_dd_3A],\\r\\n                    [0x3B, variant_FD_CB_dd_3B],\\r\\n                    [0x3C, variant_FD_CB_dd_3C],\\r\\n                    [0x3D, variant_FD_CB_dd_3D],\\r\\n                    [0x3E, variant_FD_CB_dd_3E],\\r\\n                    [0x3F, variant_FD_CB_dd_3F],\\r\\n                    [0x40, variant_FD_CB_dd_40],\\r\\n                    [0x41, variant_FD_CB_dd_41],\\r\\n                    [0x42, variant_FD_CB_dd_42],\\r\\n                    [0x43, variant_FD_CB_dd_43],\\r\\n                    [0x44, variant_FD_CB_dd_44],\\r\\n                    [0x45, variant_FD_CB_dd_45],\\r\\n                    [0x46, variant_FD_CB_dd_46],\\r\\n                    [0x47, variant_FD_CB_dd_47],\\r\\n                    [0x48, variant_FD_CB_dd_48],\\r\\n                    [0x49, variant_FD_CB_dd_49],\\r\\n                    [0x4A, variant_FD_CB_dd_4A],\\r\\n                    [0x4B, variant_FD_CB_dd_4B],\\r\\n                    [0x4C, variant_FD_CB_dd_4C],\\r\\n                    [0x4D, variant_FD_CB_dd_4D],\\r\\n                    [0x4E, variant_FD_CB_dd_4E],\\r\\n                    [0x4F, variant_FD_CB_dd_4F],\\r\\n                    [0x50, variant_FD_CB_dd_50],\\r\\n                    [0x51, variant_FD_CB_dd_51],\\r\\n                    [0x52, variant_FD_CB_dd_52],\\r\\n                    [0x53, variant_FD_CB_dd_53],\\r\\n                    [0x54, variant_FD_CB_dd_54],\\r\\n                    [0x55, variant_FD_CB_dd_55],\\r\\n                    [0x56, variant_FD_CB_dd_56],\\r\\n                    [0x57, variant_FD_CB_dd_57],\\r\\n                    [0x58, variant_FD_CB_dd_58],\\r\\n                    [0x59, variant_FD_CB_dd_59],\\r\\n                    [0x5A, variant_FD_CB_dd_5A],\\r\\n                    [0x5B, variant_FD_CB_dd_5B],\\r\\n                    [0x5C, variant_FD_CB_dd_5C],\\r\\n                    [0x5D, variant_FD_CB_dd_5D],\\r\\n                    [0x5E, variant_FD_CB_dd_5E],\\r\\n                    [0x5F, variant_FD_CB_dd_5F],\\r\\n                    [0x60, variant_FD_CB_dd_60],\\r\\n                    [0x61, variant_FD_CB_dd_61],\\r\\n                    [0x62, variant_FD_CB_dd_62],\\r\\n                    [0x63, variant_FD_CB_dd_63],\\r\\n                    [0x64, variant_FD_CB_dd_64],\\r\\n                    [0x65, variant_FD_CB_dd_65],\\r\\n                    [0x66, variant_FD_CB_dd_66],\\r\\n                    [0x67, variant_FD_CB_dd_67],\\r\\n                    [0x68, variant_FD_CB_dd_68],\\r\\n                    [0x69, variant_FD_CB_dd_69],\\r\\n                    [0x6A, variant_FD_CB_dd_6A],\\r\\n                    [0x6B, variant_FD_CB_dd_6B],\\r\\n                    [0x6C, variant_FD_CB_dd_6C],\\r\\n                    [0x6D, variant_FD_CB_dd_6D],\\r\\n                    [0x6E, variant_FD_CB_dd_6E],\\r\\n                    [0x6F, variant_FD_CB_dd_6F],\\r\\n                    [0x70, variant_FD_CB_dd_70],\\r\\n                    [0x71, variant_FD_CB_dd_71],\\r\\n                    [0x72, variant_FD_CB_dd_72],\\r\\n                    [0x73, variant_FD_CB_dd_73],\\r\\n                    [0x74, variant_FD_CB_dd_74],\\r\\n                    [0x75, variant_FD_CB_dd_75],\\r\\n                    [0x76, variant_FD_CB_dd_76],\\r\\n                    [0x77, variant_FD_CB_dd_77],\\r\\n                    [0x78, variant_FD_CB_dd_78],\\r\\n                    [0x79, variant_FD_CB_dd_79],\\r\\n                    [0x7A, variant_FD_CB_dd_7A],\\r\\n                    [0x7B, variant_FD_CB_dd_7B],\\r\\n                    [0x7C, variant_FD_CB_dd_7C],\\r\\n                    [0x7D, variant_FD_CB_dd_7D],\\r\\n                    [0x7E, variant_FD_CB_dd_7E],\\r\\n                    [0x7F, variant_FD_CB_dd_7F],\\r\\n                    [0x80, variant_FD_CB_dd_80],\\r\\n                    [0x81, variant_FD_CB_dd_81],\\r\\n                    [0x82, variant_FD_CB_dd_82],\\r\\n                    [0x83, variant_FD_CB_dd_83],\\r\\n                    [0x84, variant_FD_CB_dd_84],\\r\\n                    [0x85, variant_FD_CB_dd_85],\\r\\n                    [0x86, variant_FD_CB_dd_86],\\r\\n                    [0x87, variant_FD_CB_dd_87],\\r\\n                    [0x88, variant_FD_CB_dd_88],\\r\\n                    [0x89, variant_FD_CB_dd_89],\\r\\n                    [0x8A, variant_FD_CB_dd_8A],\\r\\n                    [0x8B, variant_FD_CB_dd_8B],\\r\\n                    [0x8C, variant_FD_CB_dd_8C],\\r\\n                    [0x8D, variant_FD_CB_dd_8D],\\r\\n                    [0x8E, variant_FD_CB_dd_8E],\\r\\n                    [0x8F, variant_FD_CB_dd_8F],\\r\\n                    [0x90, variant_FD_CB_dd_90],\\r\\n                    [0x91, variant_FD_CB_dd_91],\\r\\n                    [0x92, variant_FD_CB_dd_92],\\r\\n                    [0x93, variant_FD_CB_dd_93],\\r\\n                    [0x94, variant_FD_CB_dd_94],\\r\\n                    [0x95, variant_FD_CB_dd_95],\\r\\n                    [0x96, variant_FD_CB_dd_96],\\r\\n                    [0x97, variant_FD_CB_dd_97],\\r\\n                    [0x98, variant_FD_CB_dd_98],\\r\\n                    [0x99, variant_FD_CB_dd_99],\\r\\n                    [0x9A, variant_FD_CB_dd_9A],\\r\\n                    [0x9B, variant_FD_CB_dd_9B],\\r\\n                    [0x9C, variant_FD_CB_dd_9C],\\r\\n                    [0x9D, variant_FD_CB_dd_9D],\\r\\n                    [0x9E, variant_FD_CB_dd_9E],\\r\\n                    [0x9F, variant_FD_CB_dd_9F],\\r\\n                    [0xA0, variant_FD_CB_dd_A0],\\r\\n                    [0xA1, variant_FD_CB_dd_A1],\\r\\n                    [0xA2, variant_FD_CB_dd_A2],\\r\\n                    [0xA3, variant_FD_CB_dd_A3],\\r\\n                    [0xA4, variant_FD_CB_dd_A4],\\r\\n                    [0xA5, variant_FD_CB_dd_A5],\\r\\n                    [0xA6, variant_FD_CB_dd_A6],\\r\\n                    [0xA7, variant_FD_CB_dd_A7],\\r\\n                    [0xA8, variant_FD_CB_dd_A8],\\r\\n                    [0xA9, variant_FD_CB_dd_A9],\\r\\n                    [0xAA, variant_FD_CB_dd_AA],\\r\\n                    [0xAB, variant_FD_CB_dd_AB],\\r\\n                    [0xAC, variant_FD_CB_dd_AC],\\r\\n                    [0xAD, variant_FD_CB_dd_AD],\\r\\n                    [0xAE, variant_FD_CB_dd_AE],\\r\\n                    [0xAF, variant_FD_CB_dd_AF],\\r\\n                    [0xB0, variant_FD_CB_dd_B0],\\r\\n                    [0xB1, variant_FD_CB_dd_B1],\\r\\n                    [0xB2, variant_FD_CB_dd_B2],\\r\\n                    [0xB3, variant_FD_CB_dd_B3],\\r\\n                    [0xB4, variant_FD_CB_dd_B4],\\r\\n                    [0xB5, variant_FD_CB_dd_B5],\\r\\n                    [0xB6, variant_FD_CB_dd_B6],\\r\\n                    [0xB7, variant_FD_CB_dd_B7],\\r\\n                    [0xB8, variant_FD_CB_dd_B8],\\r\\n                    [0xB9, variant_FD_CB_dd_B9],\\r\\n                    [0xBA, variant_FD_CB_dd_BA],\\r\\n                    [0xBB, variant_FD_CB_dd_BB],\\r\\n                    [0xBC, variant_FD_CB_dd_BC],\\r\\n                    [0xBD, variant_FD_CB_dd_BD],\\r\\n                    [0xBE, variant_FD_CB_dd_BE],\\r\\n                    [0xBF, variant_FD_CB_dd_BF],\\r\\n                    [0xC0, variant_FD_CB_dd_C0],\\r\\n                    [0xC1, variant_FD_CB_dd_C1],\\r\\n                    [0xC2, variant_FD_CB_dd_C2],\\r\\n                    [0xC3, variant_FD_CB_dd_C3],\\r\\n                    [0xC4, variant_FD_CB_dd_C4],\\r\\n                    [0xC5, variant_FD_CB_dd_C5],\\r\\n                    [0xC6, variant_FD_CB_dd_C6],\\r\\n                    [0xC7, variant_FD_CB_dd_C7],\\r\\n                    [0xC8, variant_FD_CB_dd_C8],\\r\\n                    [0xC9, variant_FD_CB_dd_C9],\\r\\n                    [0xCA, variant_FD_CB_dd_CA],\\r\\n                    [0xCB, variant_FD_CB_dd_CB],\\r\\n                    [0xCC, variant_FD_CB_dd_CC],\\r\\n                    [0xCD, variant_FD_CB_dd_CD],\\r\\n                    [0xCE, variant_FD_CB_dd_CE],\\r\\n                    [0xCF, variant_FD_CB_dd_CF],\\r\\n                    [0xD0, variant_FD_CB_dd_D0],\\r\\n                    [0xD1, variant_FD_CB_dd_D1],\\r\\n                    [0xD2, variant_FD_CB_dd_D2],\\r\\n                    [0xD3, variant_FD_CB_dd_D3],\\r\\n                    [0xD4, variant_FD_CB_dd_D4],\\r\\n                    [0xD5, variant_FD_CB_dd_D5],\\r\\n                    [0xD6, variant_FD_CB_dd_D6],\\r\\n                    [0xD7, variant_FD_CB_dd_D7],\\r\\n                    [0xD8, variant_FD_CB_dd_D8],\\r\\n                    [0xD9, variant_FD_CB_dd_D9],\\r\\n                    [0xDA, variant_FD_CB_dd_DA],\\r\\n                    [0xDB, variant_FD_CB_dd_DB],\\r\\n                    [0xDC, variant_FD_CB_dd_DC],\\r\\n                    [0xDD, variant_FD_CB_dd_DD],\\r\\n                    [0xDE, variant_FD_CB_dd_DE],\\r\\n                    [0xDF, variant_FD_CB_dd_DF],\\r\\n                    [0xE0, variant_FD_CB_dd_E0],\\r\\n                    [0xE1, variant_FD_CB_dd_E1],\\r\\n                    [0xE2, variant_FD_CB_dd_E2],\\r\\n                    [0xE3, variant_FD_CB_dd_E3],\\r\\n                    [0xE4, variant_FD_CB_dd_E4],\\r\\n                    [0xE5, variant_FD_CB_dd_E5],\\r\\n                    [0xE6, variant_FD_CB_dd_E6],\\r\\n                    [0xE7, variant_FD_CB_dd_E7],\\r\\n                    [0xE8, variant_FD_CB_dd_E8],\\r\\n                    [0xE9, variant_FD_CB_dd_E9],\\r\\n                    [0xEA, variant_FD_CB_dd_EA],\\r\\n                    [0xEB, variant_FD_CB_dd_EB],\\r\\n                    [0xEC, variant_FD_CB_dd_EC],\\r\\n                    [0xED, variant_FD_CB_dd_ED],\\r\\n                    [0xEE, variant_FD_CB_dd_EE],\\r\\n                    [0xEF, variant_FD_CB_dd_EF],\\r\\n                    [0xF0, variant_FD_CB_dd_F0],\\r\\n                    [0xF1, variant_FD_CB_dd_F1],\\r\\n                    [0xF2, variant_FD_CB_dd_F2],\\r\\n                    [0xF3, variant_FD_CB_dd_F3],\\r\\n                    [0xF4, variant_FD_CB_dd_F4],\\r\\n                    [0xF5, variant_FD_CB_dd_F5],\\r\\n                    [0xF6, variant_FD_CB_dd_F6],\\r\\n                    [0xF7, variant_FD_CB_dd_F7],\\r\\n                    [0xF8, variant_FD_CB_dd_F8],\\r\\n                    [0xF9, variant_FD_CB_dd_F9],\\r\\n                    [0xFA, variant_FD_CB_dd_FA],\\r\\n                    [0xFB, variant_FD_CB_dd_FB],\\r\\n                    [0xFC, variant_FD_CB_dd_FC],\\r\\n                    [0xFD, variant_FD_CB_dd_FD],\\r\\n                    [0xFE, variant_FD_CB_dd_FE],\\r\\n                    [0xFF, variant_FD_CB_dd_FF], // ld a,set 7,(iy+dd)\\r\\n                ])],\\r\\n            [0xE1, variant_FD_E1],\\r\\n            [0xE3, variant_FD_E3],\\r\\n            [0xE5, variant_FD_E5],\\r\\n            [0xE9, variant_FD_E9],\\r\\n            [0xF9, variant_FD_F9], // ld sp,iy\\r\\n        ])],\\r\\n    [0xFE, variant_FE_nn],\\r\\n    [0xFF, variant_FF], // rst 38\\r\\n]);\\r\\n//# sourceMappingURL=Opcodes.js.map\\n\\n//# sourceURL=webpack://wptest/../packages/z80-inst/dist/Opcodes.js?");\n\n/***/ }),\n\n/***/ "../packages/z80-inst/dist/OpcodesTypes.js":\n/*!*************************************************!*\\\n  !*** ../packages/z80-inst/dist/OpcodesTypes.js ***!\n  \\*************************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\neval("__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\"isOpcodeTemplateOperand\\": () => (/* binding */ isOpcodeTemplateOperand)\\n/* harmony export */ });\\n/**\\r\\n * Type guard for the operand.\\r\\n */\\r\\nfunction isOpcodeTemplateOperand(operand) {\\r\\n    return operand === \\"nn\\" || operand === \\"nnnn\\" || operand === \\"dd\\" || operand === \\"offset\\";\\r\\n}\\r\\n//# sourceMappingURL=OpcodesTypes.js.map\\n\\n//# sourceURL=webpack://wptest/../packages/z80-inst/dist/OpcodesTypes.js?");\n\n/***/ }),\n\n/***/ "../packages/z80-inst/dist/Utils.js":\n/*!******************************************!*\\\n  !*** ../packages/z80-inst/dist/Utils.js ***!\n  \\******************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\neval("__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\"isDataThirdByte\\": () => (/* binding */ isDataThirdByte)\\n/* harmony export */ });\\n/**\\r\\n * Some instructions are four bytes long but the data byte is in the third\\r\\n * byte, like DDCB1247, where 12 is the data byte.\\r\\n * @param b1 First byte.\\r\\n * @param b2 Secont byte.\\r\\n * @returns Whether the data byte is the third byte. If not, then it\'s the\\r\\n * last byte (whatever that is).\\r\\n */\\r\\nfunction isDataThirdByte(b1, b2) {\\r\\n    return (b1 === 0xDD || b1 === 0xFD) && b2 === 0xCB;\\r\\n}\\r\\n//# sourceMappingURL=Utils.js.map\\n\\n//# sourceURL=webpack://wptest/../packages/z80-inst/dist/Utils.js?");\n\n/***/ }),\n\n/***/ "../packages/z80-inst/dist/index.js":\n/*!******************************************!*\\\n  !*** ../packages/z80-inst/dist/index.js ***!\n  \\******************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\neval("__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\"isDataThirdByte\\": () => (/* reexport safe */ _Utils_js__WEBPACK_IMPORTED_MODULE_2__.isDataThirdByte),\\n/* harmony export */   \\"isOpcodeTemplateOperand\\": () => (/* reexport safe */ _OpcodesTypes_js__WEBPACK_IMPORTED_MODULE_0__.isOpcodeTemplateOperand),\\n/* harmony export */   \\"mnemonicMap\\": () => (/* reexport safe */ _Opcodes_js__WEBPACK_IMPORTED_MODULE_1__.mnemonicMap),\\n/* harmony export */   \\"opcodeMap\\": () => (/* reexport safe */ _Opcodes_js__WEBPACK_IMPORTED_MODULE_1__.opcodeMap)\\n/* harmony export */ });\\n/* harmony import */ var _OpcodesTypes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./OpcodesTypes.js */ \\"../packages/z80-inst/dist/OpcodesTypes.js\\");\\n/* harmony import */ var _Opcodes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Opcodes.js */ \\"../packages/z80-inst/dist/Opcodes.js\\");\\n/* harmony import */ var _Utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Utils.js */ \\"../packages/z80-inst/dist/Utils.js\\");\\n\\r\\n\\r\\n\\r\\n//# sourceMappingURL=index.js.map\\n\\n//# sourceURL=webpack://wptest/../packages/z80-inst/dist/index.js?");\n\n/***/ }),\n\n/***/ "./src/index.js":\n/*!**********************!*\\\n  !*** ./src/index.js ***!\n  \\**********************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\neval("__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var z80_asm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! z80-asm */ \\"../packages/z80-asm/dist/index.js\\");\\n\\r\\nconst files = {\\r\\n    \\"if.asm\\": ` org 0x8000\\r\\naa equ 5\\r\\nbb equ 3\\r\\ntest macro \\r\\n if aa eq bb\\r\\n  ld a,5\\r\\n else \\r\\n  ld b,5\\r\\n endif\\r\\nendm\\r\\n test\\r\\n`,\\r\\n    \\"iff.asm\\": ` org 0x8000\\r\\niff.nz equ 0\\r\\niff.z  equ 1\\r\\niff.nc equ 2\\r\\niff.c  equ 3\\r\\ntest macro arg\\r\\n#local\\r\\n iff c, to\\r\\n  ld a,&arg\\r\\nto:\\r\\n#endlocal\\r\\nendm\\r\\niff macro cnd,to\\r\\n    if iff.&cnd eq iff.nz\\r\\n    jr z,&to\\r\\n    endif\\r\\n    if iff.&cnd eq iff.z\\r\\n    jr nz,&to\\r\\n    endif\\r\\n    if iff.&cnd eq iff.nc\\r\\n    jr c,&to\\r\\n    endif\\r\\n    if iff.&cnd eq iff.c\\r\\n    jr nc,&to\\r\\n    endif\\r\\n    if iff.&cnd\\r\\n    endif\\r\\n    if iff.c\\r\\n    endif\\r\\nendm\\r\\n test 5\\r\\n`,\\r\\n    \\"test.asm\\": ` .org 0x8000\\r\\n val equ 1+2\\r\\niftest .macro &x\\r\\n if &x>0\\r\\n    ld hl,0\\r\\n    if &x>10\\r\\n    ld a,0\\r\\n    endif\\r\\n else\\r\\n    ld de,0\\r\\n endif\\r\\nendm\\r\\ntesto .macro &xx\\r\\n#local\\r\\n    jp nz,aa\\r\\n    ld (lop&xx-2),hl \\r\\naa:\\r\\n    ld hl,(0)\\r\\nlop&xx::\\r\\n#endlocal\\r\\n.endm\\r\\n\\r\\nincs macro &n\\r\\n rept &n\\r\\n  inc hl\\r\\n endm\\r\\nendm\\r\\n\\r\\ncnt: defl val\\r\\ndefltest macro \\r\\ncnt: defl cnt+1\\r\\n ld a,cnt\\r\\nendm\\r\\n\\r\\nconcat macro &Class, &method\\r\\n ld hl, &Class.&method\\r\\nendm\\r\\n\\r\\n    jr endline\\r\\n    testo hoge\\r\\n    testo fuga\\r\\n    iftest 10\\r\\n    iftest 20\\r\\n    iftest 0\\r\\n    incs 5\\r\\n    jp lophoge\\r\\n    concat Test,foo\\r\\n    defltest\\r\\n    defltest\\r\\n    ret\\r\\nendline:\\r\\nTest.foo: \\r\\n dw 10`,\\r\\n    \\"defl.asm\\": `aa: defl 0\\r\\ntest macro \\r\\n    ld a,aa\\r\\naa: defl aa+1\\r\\nendm\\r\\n    test\\r\\n    test\\r\\n`,\\r\\n    \\"adj.asm\\": `org 8000h\\r\\nld a,5\\r\\nlabel:\\r\\njp label\\r\\n level:\\r\\n jr level\\r\\n`,\\r\\n    \\"ix.asm\\": `\\r\\nld (ix-3),a\\r\\nld (ix-2+1),a\\r\\nld (ix-(2+1)),a\\r\\n`,\\r\\n    \\"equ.asm\\": `\\r\\nval equ 1+2\\r\\n ld a,val\\r\\n`\\r\\n};\\r\\nconst fs = {\\r\\n    readTextFile(pathname) {\\r\\n        return files[pathname].split(\\"\\\\n\\");\\r\\n    },\\r\\n    readBinaryFile(pathname) {\\r\\n        throw new Error(\\"Function not implemented.\\");\\r\\n    },\\r\\n    readDirectory(pathname) {\\r\\n        throw new Error(\\"Function not implemented.\\");\\r\\n    }\\r\\n};\\r\\nfunction isDef(line) {\\r\\n    for (let s of line.symbols) {\\r\\n        let d = s.definitions.find((e) => e.lineNumber == line.listingLineNumber);\\r\\n        if (d)\\r\\n            return d;\\r\\n    }\\r\\n    return false;\\r\\n}\\r\\nconst PR = \\";PR_ADJ=\\";\\r\\nconst PRPAT = /(.*);PR_ADJ=([\\\\-\\\\d]+)/;\\r\\n//const a=new Asm(fs);\\r\\nlet fileName = \\"test.asm\\";\\r\\nif (typeof process !== \\"undefined\\") {\\r\\n    fileName = process.argv[2] || fileName;\\r\\n    let a = doAsm(files[fileName]);\\r\\n    //let r=a.assembleFile(fileName);\\r\\n    console.dir(a, { depth: null });\\r\\n    for (let e of a.assembledLines) {\\r\\n        console.log(e.address.toString(16), !!isDef(e), e.binary.map((r) => r.toString(16)), e.line, (e.error || \\"\\"));\\r\\n    }\\r\\n    for (let e of a.assembledLines) {\\r\\n        if (isDef(e) || e.binary.length > 0 || e.line.match(/#(end)?local/)) {\\r\\n            console.log(e.line);\\r\\n        }\\r\\n        //console.log(e.address.toString(16), e.symbols.length,  e.binary.map((r)=>r.toString(16)), e.line , (e.error||\\"\\"));\\r\\n    }\\r\\n    const plain = toPlain(a.assembledLines);\\r\\n    for (let e of plain) {\\r\\n        console.log(e.label, e.address.toString(16), e.bin.map(n => n.toString(16)), e.body);\\r\\n    }\\r\\n}\\r\\nif (typeof window !== \\"undefined\\") {\\r\\n    window.doAsm = doAsm;\\r\\n    window.asmToPlain = asmToPlain;\\r\\n}\\r\\nif (typeof self !== \\"undefined\\") {\\r\\n    self.doAsm = doAsm;\\r\\n    self.addEventListener(\\"message\\", (e) => {\\r\\n        try {\\r\\n            const plain = asmToPlain(e.data);\\r\\n            self.postMessage(JSON.stringify({ type: \\"success\\", result: plain }));\\r\\n        }\\r\\n        catch (e) {\\r\\n            self.postMessage(JSON.stringify({ type: \\"error\\", message: e + \\"\\\\n\\" + e.stack }));\\r\\n        }\\r\\n    });\\r\\n}\\r\\nfunction asmToPlain(src) {\\r\\n    const r = doAsm(src);\\r\\n    let errors = r.assembledLines.filter(e => e.error);\\r\\n    if (errors.length > 0) {\\r\\n        console.log(r);\\r\\n        console.log(errors);\\r\\n        throw new Error(\\"Assemble error at Line \\" + errors[0].listingLineNumber + \\"\\\\n\\" + errors[0].error);\\r\\n    }\\r\\n    const plain = toPlain(r.assembledLines);\\r\\n    return plain;\\r\\n}\\r\\nfunction toPlain(aline) {\\r\\n    let id, lines, equs;\\r\\n    let defls;\\r\\n    let scs;\\r\\n    let buf;\\r\\n    let pass;\\r\\n    let l, a, b;\\r\\n    let m;\\r\\n    let curln;\\r\\n    let com;\\r\\n    let curAddress;\\r\\n    return conv(aline);\\r\\n    function conv(s) {\\r\\n        id = 0;\\r\\n        lines = s;\\r\\n        defls = {};\\r\\n        buf = [];\\r\\n        equs = {};\\r\\n        scs = { p: null, l: {}, id };\\r\\n        pass = 1;\\r\\n        s.forEach(re1);\\r\\n        pass = 2;\\r\\n        s.forEach(re2);\\r\\n        console.log(s);\\r\\n        return buf;\\r\\n    }\\r\\n    function re1(al) {\\r\\n        l = al.line;\\r\\n        al.scs = scs;\\r\\n        if (mt(/#local/)) {\\r\\n            local();\\r\\n            return;\\r\\n        }\\r\\n        if (mt(/#endlocal/)) {\\r\\n            endlocal();\\r\\n            return;\\r\\n        }\\r\\n        if (!isDef(al) &&\\r\\n            al.binary.length == 0)\\r\\n            return;\\r\\n        if (mt(/([\\\\w\\\\.]+):\\\\s*defl\\\\b/)) {\\r\\n            defls[m[1]] = 1;\\r\\n        }\\r\\n        if (mt(/([\\\\w\\\\.]+):/)) {\\r\\n            scs.l[m[1]] = scs;\\r\\n        }\\r\\n    }\\r\\n    function re2(al, ln) {\\r\\n        l = al.line;\\r\\n        curln = ln;\\r\\n        scs = al.scs;\\r\\n        com = \\"\\";\\r\\n        if (mt(/;/)) {\\r\\n            l = b;\\r\\n            com = \\";\\" + a;\\r\\n        }\\r\\n        if (mt(/#(end)?local/)) {\\r\\n            return;\\r\\n        }\\r\\n        if (mt(/\\\\bdefl\\\\b/)) {\\r\\n            return;\\r\\n        }\\r\\n        let def = isDef(al);\\r\\n        if (!def &&\\r\\n            al.binary.length == 0) {\\r\\n            if (com)\\r\\n                w(\\"\\");\\r\\n            return;\\r\\n        }\\r\\n        repl(/[\\\\w\\\\.]+/g, reps);\\r\\n        repl(/\\\\bhi\\\\s*\\\\(/g, \\"high(\\");\\r\\n        repl(/\\\\blo\\\\s*\\\\(/g, \\"low(\\");\\r\\n        let adrval = al.address;\\r\\n        if (mt(/\\\\bequ\\\\b/)) {\\r\\n            b = b.replace(/\\\\s/g, \\"\\");\\r\\n            a = a.replace(/\\\\s/g, \\"\\");\\r\\n            if (!equs[b]) {\\r\\n                equs[b] = a;\\r\\n            }\\r\\n            else if (equs[b] !== a) {\\r\\n                throw new Error(\\"Equ not match at \\" +\\r\\n                    curln + \\" \\" + equs[b] + \\"!=\\" + a + \\" \\" + curln + \\": \\" + l);\\r\\n            }\\r\\n            else {\\r\\n                l = \\";\\" + l;\\r\\n            }\\r\\n            let info = al.symbols.find((si) => si.name == b);\\r\\n            adrval = info.value;\\r\\n        }\\r\\n        if (!mt(/^\\\\s/) &&\\r\\n            !isdefLine()) {\\r\\n            l = \\" \\" + l;\\r\\n        }\\r\\n        if (isdefLine()) {\\r\\n            l = l.replace(/^\\\\s*/, \\"\\");\\r\\n        }\\r\\n        let label;\\r\\n        if (def instanceof z80_asm__WEBPACK_IMPORTED_MODULE_0__.SymbolInfo)\\r\\n            label = reps(def.name) + \\"\\";\\r\\n        w(l, al.binary, adrval, label);\\r\\n    }\\r\\n    function w(s, bin = [], address = undefined, label = undefined) {\\r\\n        if (typeof address !== \\"number\\")\\r\\n            address = curAddress;\\r\\n        else\\r\\n            curAddress = address;\\r\\n        buf.push({ body: s + com, bin, address, label });\\r\\n        com = \\"\\";\\r\\n    }\\r\\n    function local() {\\r\\n        if (pass > 1)\\r\\n            return;\\r\\n        id++;\\r\\n        scs = {\\r\\n            p: scs,\\r\\n            l: ext(scs.l),\\r\\n            id\\r\\n        };\\r\\n        //console.log(scs);\\r\\n    }\\r\\n    function endlocal() {\\r\\n        if (pass > 1)\\r\\n            return;\\r\\n        scs = scs.p;\\r\\n    }\\r\\n    function reps(n) {\\r\\n        //console.log(n, scs);\\r\\n        if (defls[n]) {\\r\\n            return getv(n);\\r\\n        }\\r\\n        if (scs.l[n] && scs.l[n].id > 0) {\\r\\n            return \\"L\\" + scs.l[n].id + \\".\\" + n;\\r\\n        }\\r\\n        return n;\\r\\n    }\\r\\n    function getv(n) {\\r\\n        let l = lines[curln];\\r\\n        let s = l.symbols.find((e) => e.name == n);\\r\\n        if (!s)\\r\\n            return 0;\\r\\n        let i = s.references.find((e) => e.lineNumber == curln);\\r\\n        if (!i)\\r\\n            return 0;\\r\\n        return i.value;\\r\\n    }\\r\\n    function isDef(line) {\\r\\n        if (line.line.match(/^\\\\s*org /))\\r\\n            return true;\\r\\n        if (line.line.match(/^\\\\s*end /))\\r\\n            return true;\\r\\n        for (let s of line.symbols) {\\r\\n            let d = s.definitions.find((e) => e.lineNumber == line.listingLineNumber);\\r\\n            if (d)\\r\\n                return s;\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n    function isdefLine() {\\r\\n        return mt(/\\\\w+:/) || mt(/\\\\b(equ|macro|include)\\\\b/i);\\r\\n    }\\r\\n    function ext(p) {\\r\\n        return Object.create(p);\\r\\n    }\\r\\n    function repl(r, t) {\\r\\n        l = l.replace(r, t);\\r\\n    }\\r\\n    function mt(r) {\\r\\n        m = r.exec(l);\\r\\n        if (!m)\\r\\n            return m;\\r\\n        b = l.substring(0, m.index);\\r\\n        a = l.substring(m.index +\\r\\n            m[0].length);\\r\\n        return m;\\r\\n    }\\r\\n}\\r\\nfunction doAsm(s) {\\r\\n    const lines = preprocess(s);\\r\\n    console.log(\\"PREPROC\\", lines);\\r\\n    const a = new z80_asm__WEBPACK_IMPORTED_MODULE_0__.Asm({\\r\\n        readTextFile(f) { return lines; },\\r\\n        readBinaryFile(pathname) {\\r\\n            throw new Error(\\"Function not implemented.\\");\\r\\n        },\\r\\n        readDirectory(pathname) {\\r\\n            throw new Error(\\"Function not implemented.\\");\\r\\n        }\\r\\n    });\\r\\n    a.assembleFile(\\"test.asm\\");\\r\\n    const alines = a.assembledLines;\\r\\n    for (let aline of alines) {\\r\\n        const m = PRPAT.exec(aline.line);\\r\\n        if (m) {\\r\\n            let adjust = -parseInt(m[2]);\\r\\n            let oline = m[1];\\r\\n            if (adjust < 0)\\r\\n                oline = oline.substring(-adjust);\\r\\n            else {\\r\\n                for (let i = 0; i < adjust; i++)\\r\\n                    oline = \\" \\" + oline;\\r\\n            }\\r\\n            aline.line = oline;\\r\\n            aline.adjust = adjust;\\r\\n        }\\r\\n    }\\r\\n    for (let sc of a.scopes) {\\r\\n        for (let name of sc.symbols.keys()) {\\r\\n            let sy = sc.symbols.get(name);\\r\\n            for (let ref of [...sy.definitions, ...sy.references]) {\\r\\n                const a = alines[ref.lineNumber];\\r\\n                let adjust = a.adjust || 0;\\r\\n                ref.column += adjust;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    return a;\\r\\n}\\r\\nfunction preprocess(s) {\\r\\n    const lines = s.split(/\\\\r?\\\\n/);\\r\\n    const spc = /^\\\\s*/;\\r\\n    return lines.map((body) => {\\r\\n        const m = spc.exec(body);\\r\\n        const headSpace = m[0];\\r\\n        const isDef = isDefLine(body);\\r\\n        if (isDef && headSpace.length > 0) {\\r\\n            return body.replace(/^\\\\s*/, \\"\\") + PR + (-headSpace.length);\\r\\n        }\\r\\n        if (!isDef && headSpace.length == 0) {\\r\\n            return \\" \\" + body + PR + 1;\\r\\n        }\\r\\n        return body;\\r\\n    });\\r\\n}\\r\\nfunction isDefLine(line) {\\r\\n    return line.match(/\\\\w+:/) || line.match(/\\\\b(equ|macro|include)\\\\b/i);\\r\\n}\\r\\n\\n\\n//# sourceURL=webpack://wptest/./src/index.js?");\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/define property getters */\n/******/ \t(() => {\n/******/ \t\t// define getter functions for harmony exports\n/******/ \t\t__webpack_require__.d = (exports, definition) => {\n/******/ \t\t\tfor(var key in definition) {\n/******/ \t\t\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n/******/ \t\t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/hasOwnProperty shorthand */\n/******/ \t(() => {\n/******/ \t\t__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/make namespace object */\n/******/ \t(() => {\n/******/ \t\t// define __esModule on exports\n/******/ \t\t__webpack_require__.r = (exports) => {\n/******/ \t\t\tif(typeof Symbol !== \'undefined\' && Symbol.toStringTag) {\n/******/ \t\t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: \'Module\' });\n/******/ \t\t\t}\n/******/ \t\t\tObject.defineProperty(exports, \'__esModule\', { value: true });\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module can\'t be inlined because the eval devtool is used.\n/******/ \tvar __webpack_exports__ = __webpack_require__("./src/index.js");\n/******/ \t\n/******/ })()\n;\n},{}]},{},[1]);\n'],{type:"text/javascript"})));

},{}]},{},[1]);
